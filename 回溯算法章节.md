# 	回溯算法章节

###### tips.要明白回溯和递归是密不可分的。

​	1)<font color="red"> 回溯算法本质就是穷举，因此其效率不是很高，即使添加了剪枝操作.</font>

​	2) 回溯算法可以解决的问题：组合问题、切割问题、子集问题、排列问题、棋盘问题。

#### 1.组合问题

​	通过一个简单的实例来了解回溯算法

##### lc77.组合问题，

不要把回溯想的难，从穷举角度手工推就懂了

<img src="I:\U盘内容\Primer\数据结构与算法\代码随想录\pic\image-20230630214211083.png" alt="image-20230630214211083" style="zoom:67%;" />

**tips:这里递归的层数由k决定**

```C++
class Solution {
public:
    vector<vector<int>> combine(int n, int k) {
        vector<vector<int>> res;
        vector<int> path;
        backtracking(res, path, 1, n+1, k);
        return res;
    }

private:
    void backtracking(vector<vector<int>>& res, vector<int>& path, int start, int end, int k){
        if(path.size() == k){
            res.push_back(path); // 递归到叶子结点
            return;
        }

        for(int i=start; i<end && k <= (path.size() + end - i); i++){ // 这里有剪枝
            path.push_back(i);
            backtracking(res, path, i+1, end, k);
            path.pop_back();  // 这里是回溯
        }
    }
};
```



##### lc216:组合总和（一）

​	思路，从数字[1, 9]中选出k个数字使其和为n，且每个数字不重复使用，和上一题是一样的，采用回溯做，递归K层，注意可以剪枝

```C++
class Solution {
public:
    vector<vector<int>> combinationSum3(int k, int n) {
        vector<vector<int>> res;
        vector<int> path;
        int sum = 0;
        backtracking(res, path, sum, 1, 10, n, k);
        return res;
    }

void backtracking(vector<vector<int>>& res, vector<int>&path, int&sum, int start, int end, int& n, int& k){
    if(path.size() == k){
        if(sum == n){
            res.push_back(path);
        }
        return;
    }

    for(int i=start; i < end && sum < n; i++){
        path.push_back(i);
        sum += i;
        backtracking(res, path, sum, i+1, end, n, k);
        path.pop_back();
        sum -= i;
    } 
}
};
```

##### lc17.电话号码组合

以输入“23”为例

第一层遍历"abc", 在第一层的基础上遍历3,3对应"def"。通过回溯实现

```c++
class Solution {
public:
    vector<string> letterCombinations(string digits) {
        if(digits.empty()){return {};}
        vector<string> res;
        string path = "";
        backtracking(res, path, digits, 0);
        return res;
    }

private:
    vector<string> alnum = {"abc", "def", "ghi", "jkl", "mno", "pqrs", "tuv", "wxyz"}; // 这种写法简介了很多
    void backtracking(vector<string>& res, string &path, string& digits, int start){
        if(path.size() == digits.size()){
            res.push_back(path);
            return;
        }

        for(int i=0; i<alnum[digits[start]-'0'-2].size(); i++){
            path.append(1, alnum[digits[start]-'0'-2][i]); // string.append(n, c); 调用的是这个方法 
            backtracking(res, path, digits, start+1);
            path.pop_back();
        }
    }
};
```

##### lc39.组合总和2

```C++
class Solution {
public:
    vector<vector<int>> combinationSum(vector<int>& candidates, int target) {
        vector<vector<int>> res;
        vector<int> temp;
        int sum = 0;
        int n = candidates.size();  // 不需要排序
        int startIndex = 0;
        if(target<2) return res;
        backtracking(candidates, res, temp, n, startIndex, sum, target);
        return res;
        
    }
private:
    void backtracking(vector<int>& candidates,vector<vector<int>>&res, vector<int>&temp,  int& n,  int& startIndex, int& sum, int& target)
    {
            if(sum == target)
            {
                res.push_back(temp);
            }
            for(int i=startIndex; i<n && sum<target; i++)
            {       
                    // 宽度搜索的时候
                    sum+=candidates[i];
                    temp.push_back(candidates[i]);
                    backtracking(candidates, res, temp, n, i, sum, target);
                    temp.pop_back();
                    sum -= candidates[i];   
            }       
    }
};
```

##### lc40: 组合总和2

```C++
class Solution {
public:
    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {
        vector<vector<int>> res;
        vector<int> path;
        int sum = 0;
        if(candidates.size()==0){return {};} 
        sort(candidates.begin(), candidates.end());
        backtracking(res, path, candidates, 0, sum, target);
        return res;
    }

private:
    void backtracking(vector<vector<int>>& res, vector<int>& path, vector<int>& candidates, int startIndex, int& sum, int& target)
    {
        if(sum == target){
            res.push_back(path);
            return;
        }

        for(int i=startIndex; i < candidates.size() && sum <= (target - candidates[i]); i++){
            path.push_back(candidates[i]);
            sum += candidates[i];
            backtracking(res, path, candidates, i+1, sum, target);
            sum -= candidates[i];
            while(i < candidates.size() - 1 && candidates[i+1] == path.back()){
                ++i; // 当弹出和插入的元素一样时，会考虑到重复的情况
            }
            path.pop_back();
        }

    }
};
```

#### 2.分割字符串问题

##### lc131:分割回文串问题 

<img src="I:\U盘内容\Primer\数据结构与算法\代码随想录\pic\image-20230704183151108.png" alt="image-20230704183151108" style="zoom:67%;" />

```C++
class Solution {
public:
    vector<vector<string>> partition(string s) {
    vector<vector<string>> res;
    vector<string> path;

    backtracking(res, path, s);
    return res;
    }

private:
    // 回文串的判断
    bool IsRe(const string& str, int left_s, int right_s){
        // [left_r, right_s)--->传入是开区间的
        while(left_s < right_s){
            if(str[left_s] != str[right_s - 1]){
                return false;
            }
            ++left_s, --right_s;
        }
        return true;
    }

    // 回溯,传入的是右子串
    void backtracking(vector<vector<string>>& res, vector<string>& path, string s){
        if(s.empty()){
            res.push_back(path);
            return;
        }

        for(int i=1; i <= s.size(); i++){
            string left_s = s.substr(0, i);
            string right_s = s.substr(i, s.size() - i);
            if(IsRe(left_s, 0, left_s.size())){
                path.push_back(left_s);
                backtracking(res, path, right_s);
                path.pop_back();
            }
        }

    }
};
// v2版本，节省空间
class Solution {
public:
    vector<vector<string>> partition(string s) {
        vector<vector<string>> res;
        vector<string> path;
        back(res, path, s, 0);
        return res;
    }

private:
    void back(vector<vector<string>>& res, vector<string>& path, string& s, int startIndex){
        if(startIndex >= s.size()){
            res.push_back(path);
            return;
        }

        for(int i=startIndex; i < s.size(); i++){
            if(IsRe(s, startIndex, i)){
                path.push_back(s.substr(startIndex, i - startIndex + 1));
            }else{
                continue;
            }
            back(res, path, s, i + 1);
            path.pop_back();
        }
    }

    bool IsRe(const string& s, int left, int right){
        // 这里考虑闭区间
        while(left <= right){
            if(s[left] != s[right]){
                return false;
            }
            ++left, --right;
        }
        return true;
    }
};
```

##### lc93.复原IP地址 

​	要注意哪些是不符合要求的

```C++
class Solution {
public:
    vector<string> restoreIpAddresses(string s) {
        if(s.size() < 4 || s.size() > 12){return {};} // 一定不符合的
        vector<string> res;
        vector<string> path;
        back(res, path, s, 0);
        return res;
    }

private:
    void back(vector<string>& res, vector<string>& path, const string& s, int startIndex){
        if(path.size() == 4){
            add_path(res, path);
            return;
        }

        for(int i=startIndex; i < startIndex + 3; i++){
            if(((s.size() - i - 1) > (9 - 3 * path.size())) || (s.size() - i - 1) < (3 - path.size())){               // 这一步只是判断位数是否有效
                continue;
            }else if(!IsValid(s, startIndex, i)){
                return;
            }
            path.push_back(s.substr(startIndex, i - startIndex + 1));
            back(res, path, s, i + 1);
            path.pop_back();
        }
    }
    
    void add_path(vector<string>& res, const vector<string>& path){
        string str;
        for(int i=0; i < path.size()-1; i++){
            str += (path[i] + ".");
        }
        str += path.back();
        res.push_back(str);
        return;
    }

    bool IsValid(const string& s, int left, int right){
        // 消除前导0, 传入是闭区间
        if(left < right && s[left] == '0'){
            return false;
        }

        // 使得数字有效
        int val = 0;
        while(left <= right){
            val = val * 10 + s[left++] - '0';
        }
        if(0 <= val && val <= 255){
            return true;
        }
        return false;
    }
};
```

#### 3.子集问题

##### 	lc78. 子集

​		方法有很多，比如位运算、递归和回溯

```C++
class Solution1 {
public:
    vector<vector<int>> res = {{}};
    vector<int> temp;
    vector<vector<int>> subsets(vector<int>& nums) {
        int n = nums.size();
        backtracking(nums, n,  0);
        return res;
}

private:
    void backtracking(vector<int>&nums, int&n, int startIndex)
    {
        if(startIndex==n)
        {
            return;
        }   
        for(int i = startIndex; i<n; i++)
        {
            temp.push_back(nums[i]);
            res.push_back(temp);    
            backtracking(nums, n, i+1);
            temp.pop_back();
        }
    }
    
};
// 位运算，一个集合的子集一共有2^n个，其中n表示位数。其实从[0, n-1]的二进制为就表示所有的子集可能
class Solution2 {
public:
    vector<vector<int>> subsets(vector<int>& nums) {
        int n = nums.size();
        vector<vector<int>> res;
        vector<int> temp;
        for(int mask=0; mask<(1<<n); mask++)
        {
            temp.clear();
            for (int i =0; i<n; i++ )
            {
                if(mask & (1<<i))
                temp.push_back(nums[i]);
            }
            res.push_back(temp);
        }
        return res;

}      
};

class Solution {
public:
    vector<int> t;
    vector<vector<int>> ans;

    void dfs(int curr, int n, vector<int>&nums)
    {
        if(curr == n)
        {
            ans.push_back(t);
            return;
        }
        t.push_back(nums[curr]);
        dfs(curr+1, n, nums);  // 考虑当前位置的
        t.pop_back();

        dfs(curr + 1, n, nums);  // 不考虑当前位置的
    }

    vector<vector<int>> subsets(vector<int>& nums) {
        dfs(0, nums.size(), nums);
        return ans;
    }
};
```

##### lc90. 子集2

```C++
// 注意位运算和约束越界问题
class Solution1 {
public:
    vector<vector<int>> res = {{}};
    vector<int> temp;
    // 回溯
    vector<vector<int>> subsetsWithDup(vector<int>& nums) {
        sort(nums.begin(), nums.end());
        int n = nums.size();
        backtracing(nums, n, 0);
        return res;
    }
private:
    void backtracing(vector<int>&nums, int&n, int startIndex)
    {
            if(startIndex == n)
            {
                return;
            }
            for (int i = startIndex; i<n; i++)
            {   
                temp.push_back(nums[i]);
                res.push_back(temp);
                backtracing(nums, n, i+1);
                // 回溯判断是否枚举了重复的元素,如果弹出的元素和下一次插入的元素一样，则该分支没有必要进行枚举了
                while(i+1<n && temp.back()==nums[i+1]) ++i;
                temp.pop_back();
            }
    }
};

class Solution {
public:
    vector<vector<int>> res = {};
    vector<int> temp;
    // 位运算的方法
    vector<vector<int>> subsetsWithDup(vector<int>& nums) {
        sort(nums.begin(), nums.end());
        int n = nums.size();
        for(int mask = 0; mask<(1<<n); mask++)
        {   
            // 重复的组合应该是在mask上
            bool flag = true;
            temp.clear();
            // 内部插入数字
            for(int i=0; i<n; i++)
            {   
        
                if(mask & (1<<i))
                {   // (mask>>(i-1) & 1)==0 低位在当前没有取，但是在上一轮中一定取了
                    if(i>0 && ((mask>>(i-1) & 1)==0) && nums[i]==nums[i-1])
                    {
                        flag = false;
                        break;
                    }
                    temp.push_back(nums[i]);
                }
            }
            if(flag)
            res.push_back(temp);
        }
        return res;
    }
};
```

#### 4.递增子序列问题

##### 	lc491. 递增子序列问题

​		方法1：再次转化为排序数列求子集问题

```C++
class Solution {
public:
    vector<vector<int>> res;
    vector<int> temp;
    vector<pair<int, int>> t_mp;
    vector<vector<int>> findSubsequences(vector<int>& nums) {
        int n = nums.size();
        vector<pair<int, int>> ump;
        for(int i =0; i<n; i++)
        {
            ump.push_back({i, nums[i]});
        }
        // 按值排序
        sort(ump.begin(), ump.end(), [](const pair<int, int>& a, const pair<int, int>& b){return a.second<b.second;});
        backtracking(ump, n, 0);
        return res;

    }
private:
    // 重复元素没有去成功，归根结底就是元素不是有序的，但排序会破坏元素的前后关系，因此，可以借助map
    void backtracking(vector<pair<int, int>>& ump, int&n, int startIndex)
    {
        if(startIndex == n)
        {
            return;
        }

        for(int i = startIndex; i<n; i++)
        {
            if(temp.size()==0)
            {
                temp.push_back(ump[i].second);
                t_mp.push_back(ump[i]);

            } 
            else if(t_mp.back().first<ump[i].first)
            {
                temp.push_back(ump[i].second);
                t_mp.push_back(ump[i]);
                res.push_back(temp);
            }
            else continue; // 跳过索引小的
            backtracking(ump, n, i+1);
            while(i+1<n && ump[i+1].second==temp.back()) ++i; 
            temp.pop_back();
            t_mp.pop_back();
        }
    }
};
```

##### 模拟所有栈的输出可能

```C++
#include <bits/stdc++.h>
using namespace std;

// 模拟所有出栈的可能
class Solution{
public:
void solve(){
    string str;
    getline(cin, str);
    int n = str.size();
    vector<string> ans;
    string seq; // 保存出栈结果
    stack<char> stk;
    GetAllsequence(str, 0, stk, seq, ans);
    for(int i=0; i<ans.size(); ++i){
        cout << ans[i] << endl;
    }
}

private:
    // 回溯 + 递归， 从当前位置考虑入栈和出栈的可能
    void GetAllsequence(const string& str, int i, stack<char>& stk, string& seq, vector<string>& ans){
        if(i == str.size()){ // 回收结果的地方，i = str.size()的时候只能出栈
            if(!stk.empty()){
                seq.push_back(stk.top());
                stk.pop();
                GetAllsequence(str, i, stk, seq, ans);  // 多层递归
                stk.push(seq.back());
                seq.pop_back();
            }else{
                ans.push_back(seq);
            }
        }else{
            // 对于一个输入元素可以入栈、也可以出栈
            // case1: 入栈
            stk.push(str[i]);
            GetAllsequence(str, i + 1, stk, seq, ans);  // 向i+1递归
            stk.pop();  //回溯

            // case2: 出栈
            if(!stk.empty()){
                seq.push_back(stk.top());
                stk.pop();
                GetAllsequence(str, i, stk, seq, ans);
                stk.push(seq.back());
                seq.pop_back();
            }
        }
    }
};


int main(){
    Solution sp;
    sp.solve();
}
```

##### LRU算法

```C++
#include <bits/stdc++.h>

using namespace std;
struct Page{
    Page(int k, int v) : key(k), value(v) {}
    int key;
    int value;
};

class LRU{
public:
    LRU(int n, int l) : N(n), L(l) {}
public:
    int get(int key){
        if(umap.find(key) != umap.end()){
            auto iter = umap[key];
            Page* ptr = *iter;
            m_list.erase(iter);
            m_list.push_front(ptr);
            umap[key] = m_list.begin();
            return ptr->value;
        }
        return -1;
    }

    void set(int k, int v){
        if(m_list.size() < N){
            if(umap.find(k) != umap.end()){
                auto iter = umap[k];
                Page* ptr = *iter;
                (*iter)->value = v;
                m_list.erase(iter);
                m_list.push_front(ptr);
                umap[k] = m_list.begin();
            }else{
                Page* ptr = new Page(k, v);
                m_list.push_front(ptr);
                umap[k] = m_list.begin();
            }
        }else{
            // 失效的
            auto o_ptr = m_list.back();
            umap.erase(o_ptr->key);
            m_list.pop_back();
            delete o_ptr;
            Page* ptr = new Page(k, v);
            m_list.push_front(ptr);
            umap[k] = m_list.begin();
        }
    }
private:
    int N;
    int L;
    list<Page*> m_list;
    unordered_map<int, list<Page*>::iterator> umap;
};

class Solution{
public:
    void solve(){
        int N, L;
        cin >> N >> L;
        LRU lru(N, L);
        for(int i=0; i<L; ++i){
            char ch;
            cin >> ch;
            if(ch == 's'){
                int k, v;
                cin >> k >> v;
                lru.set(k, v);
            }else if(ch == 'g'){
                int k;
                cin >> k;
                cout << lru.get(k) << endl;
            }
        }
    }
};


int main(){
    Solution sp;
    sp.solve();
}
```



# 贪心算法

1.明晰什么是贪心？

​	贪心的本质是选择每一阶段的局部最优，从而实现全局最优。

2.难点：如何确定局部最优可以得到全局最优，一般是通过数学归纳法和反证法。

3.使用贪心算法结题一般分为四步“

​	1）将问题分解为若干子问题

​	2）找出适合的贪心策略

​	3）求解每一个子问题的最优解

​	4）将局部最优解堆叠成全局最优

##### lc455. 分发饼干

题目：

![image-20230713215033116](I:\U盘内容\Primer\数据结构与算法\代码随想录\pic\image-20230713215033116.png)

<font color="red">以最小的代价满足孩子的胃口 </font>

```C++
class Solution {
public:
    int findContentChildren(vector<int>& g, vector<int>& s) {
        sort(g.begin(), g.end()); 
        sort(s.begin(), s.end());
        int count = 0;
        for(vector<int>::iterator iter1 = g.begin(), iter2 = s.begin(); iter1 != g.end() && iter2 != s.end();){
            if(*iter1 <= *iter2){
                ++count;
                ++iter1;
                ++iter2;
            }else if(*iter1 > *iter2){
                ++iter2;
            }
        }
        return count;
    }
};
```

##### lc376 摆动序列

​	是否可以优化数组？答案是可以的？<font color="red">核心就是删除单调区间中的值</font>

```C++
class Solution {
public:
    int wiggleMaxLength(vector<int>& nums) {
        if(nums.size() < 2){return nums.size();}
        int size = nums.size();

        // 摆动序列的最长子序列
        vector<int> path;
        path.push_back(nums[0]);
        int sign = 0;
        for(int i=1; i<nums.size(); i++){
            if(path.back() == nums[i]){
                continue;
            }else if(path.size() == 1){
                path.push_back(nums[i]);
                sign = (path[0] < nums[i])? 1:-1;
            }else if((sign * (nums[i] - path.back())) < 0){
                path.push_back(nums[i]);
                sign *= -1;
            }else{
                path.pop_back();
                path.push_back(nums[i]);
            }
        }
        return path.size();
    }
};

// 利用辅助内存，O(1)
class Solution {
public:
    int wiggleMaxLength(vector<int>& nums) {
        if(nums.size() < 2){return nums.size();}
        int size = nums.size();

        // 摆动序列的最长子序列
        int back = nums[0];
        int count = 1;
        int sign = 0;
        for(int i=1; i<nums.size(); i++){
            if(back == nums[i]){
                continue;
            }else if(count == 1){
                ++count;
                sign = (back < nums[i])? 1:-1;
                back = nums[i];
            }else if((sign * (nums[i] - back)) < 0){
                ++count;
                sign *= -1;
                back = nums[i];
            }else{
                back = nums[i];
            }
        }
        return count;
    }
};
```

##### lc53 最大子序和

```C++
class Solution {
public:
    int maxSubArray(vector<int>& nums) {
        int max_sum = nums[0];
        int sum = nums[0];
        for(int i=1; i<nums.size(); i++){
            if(sum <= 0){  // 只要前缀[nums[0],...nums[i]]的最大连续子串和小于0就忽略； sum + nums[i] < nums[i]; if sum <= 0;
                sum = nums[i];
            }else{
                sum += nums[i];
            }
            max_sum = max(max_sum, sum);
        }
        return max_sum;
    }
};

// 动态规划思想
class Solution {
public:
    int maxSubArray(vector<int>& nums) {
        vector<int> dp(nums.size(), 0);  // 以num[i]结尾的最大连续子串和
        dp[0] = nums[0];
        int max_sum = nums[0];
        for(int i=1; i<nums.size(); i++){
            if(dp[i-1] <= 0){
                dp[i] = nums[i];
            }else{
                dp[i] = dp[i-1] + nums[i];
            }
            max_sum = (max_sum >= dp[i])? max_sum : dp[i];
        }
        return max_sum;
    }
};
```

##### lc122 买卖股票II

```C++
// 思路1：动态规划问题，关键是明确dp数组的含义
class Solution {
public:
    int maxProfit(vector<int>& prices) {
        // 定义dp数组，其中dp[i][0]表示第i天不持有的最大利润，dp[i][1]表示第i天持有股票的最大利润
        vector<vector<int>> dp(prices.size(), vector<int>(2, 0));
        dp[0][1] = - prices[0];
        for(int i=1; i<prices.size(); ++i){
            dp[i][0] = max(dp[i-1][0], dp[i-1][1] + prices[i]);
            dp[i][1] = max(dp[i-1][0] - prices[i], dp[i-1][1]); 
        }
        return dp[prices.size()-1][0];
    }
};
// 实际上, dp[i][_]只与dp[i-1][_]有关，单纯的求解可以不定义数组。但是为了求解的完整性，还是建议定义

// 贪心更为明了，但是应用场景受限
class Solution {
public:
    int maxProfit(vector<int>& prices) {
        // 既然是买卖，我就贪就玩了
        int sum = 0;
        for(int i=1; i<prices.size(); ++i){
            if(prices[i-1] < prices[i]){
                sum += (prices[i] - prices[i-1]); // 只吃正的
            }
        }
        return sum;
    }
};
```

##### lc55 跳跃游戏

// 思想，在能跳到的最远区间内寻找能够跳到最远的地方

```C++
class Solution {
public:
    bool canJump(vector<int>& nums) {
        int max_idx = nums[0];  // 初始时，可以跳到的最远索引
        for(int i = 0; i <= max_idx && max_idx < nums.size(); ++i){
            if(max_idx < (i + nums[i])){
                max_idx = i + nums[i];
            }
        }

        return max_idx >= nums.size() - 1;
    }
};
```

##### lc45 跳跃游戏II

```C++
class Solution {
public:
    int jump(vector<int>& nums) {
        if(nums.size() == 1){return 0;}  // 不需要跳

        // curr_max表示当前步可以跳过最远的地方, max_idx为下一步可跳到最远的地方
        int max_idx = nums[0], curr_max = nums[0];
        int curr_idx = 0, count = 0;
        while(curr_max < nums.size() - 1){ // 说明还需要继续跳
            for(int i=curr_idx; i<=curr_max; i++){
                if(max_idx < (i + nums[i])){
                    max_idx = i + nums[i];
                    curr_idx = i;
                }
            }
            curr_max = max_idx;
            ++count;
        }
        return ++count;
    }
};
```

##### lc 134加油站

```C++
class Solution1 {
public:
    int canCompleteCircuit(vector<int>& gas, vector<int>& cost) {
        // 暴力破解,模拟从每一个点出发
        for(int i=0; i<gas.size(); i++){
            int rest = gas[i] - cost[i];
            int index = (i + 1) % cost.size(); 
            while(rest >= 0 && index != i){
                rest += gas[i] - cost[i];
                index = (index + 1) % cost.size();
            }
            if(index == i){
                return index;
            }
        }

        return -1;
    }
};

class Solution {
public:
    int canCompleteCircuit(vector<int>& gas, vector<int>& cost) {
        int curSum = 0; // 从0开始，记录跑一圈剩余的油量
        int min = INT_MAX;  // 记录从0开始，到达i+1时剩余的油量
        for(int i = 0; i < gas.size(); i++){
            int rest = gas[i] - cost[i];
            curSum += rest;
            if(curSum < min){
                min = curSum;  // 从index=0出发，剩余油量最少的时候
            }
        }

        if(curSum < 0){return -1;} // sum(cost[i]) > sum(gas[i]);---->隐含一个意思，sum(cost[i]) <= sum(gas[i]) 一定可以跑一圈
        if(min >= 0){return 0;}  // 到达每一个站的油量都大于0，从0可行
        for(int i=gas.size()-1; i>=0; i--){ //在min最后开始加油，
            int rest = gas[i] - cost[i]; 
            min += rest;
            if(min >= 0){
                return i;
            }
        }
        return -1;
    }
};

class Solution {
public:
    int canCompleteCircuit(vector<int>& gas, vector<int>& cost) {
        int totalSum = 0;
        int currSum = 0;
        int start = 0;
        for(int i=0; i<gas.size(); i++){
            totalSum += gas[i] - cost[i];
            currSum += gas[i] - cost[i];
            if(currSum < 0){
                start = i + 1;
                currSum = 0;
            }
        }
            
        if(totalSum < 0){return -1;}
        return start;
    }
};
```

##### lc 135分发糖果

```C++
class Solution {
public:
    int candy(vector<int>& ratings) {
        vector<int> nums(ratings.size(), 1);
        
        // 要比较相邻孩子评分的大小，先比较一遍，比如：先比较孩子i和其左孩子之间的大小，评分大的+1
        for(int i=1; i<nums.size(); i++){
            if(ratings[i] > ratings[i-1]){
                nums[i] = 1 + nums[i-1];
            }
        }
	   
        // 然后比较其右孩子的大小；为什么是倒序，要利用先前排好右孩子评分的
        for(int i=ratings.size()-2; i>=0; --i){
            if(ratings[i] > ratings[i+1]){
                nums[i] = max(nums[i], 1 + nums[i+1]);
            }
        }

        int sum = accumulate(nums.begin(), nums.end(), 0);
        return sum;
    }
};
```

##### lc 452 用最少的数量的箭引爆气球

```C++
// 思想:如果从左往右，射出去的箭应该从右边界最小的地方的射出去，这是局部最优，能够尽可能的引爆更多的气球。如果大于该边界那么，还是要有箭引爆前面的，未必最优；也可以倒序归来
class Solution {
public:
    int findMinArrowShots(vector<vector<int>>& points) {
        if(points.size() == 1){return 1;}
        // 倒序，从右往左，首先要排序，没有问题吧，左侧从小到大
        vecsort(points);
        int count = 0;
        int idx = points.size() - 1;
        while(idx >= 0){
            int nidx = idx - 1;
            while(nidx >= 0 && points[nidx][1] >= points[idx][0]){
                --nidx;
            }
            ++count;
            idx = nidx;
        }
        return count;
    }

private:
    void vecsort(vector<vector<int>>& points){
        sort(points.begin(), points.end(), [](vector<int>& lhs, vector<int>& rhs){return lhs[0] <= rhs[0];});
    }
};
```

##### lc56 合并区间

```C++
class Solution {
public:
    vector<vector<int>> merge(vector<vector<int>>& intervals) {
        if(intervals.size() < 2){return intervals;}
        // 排序
        sort(intervals.begin(), intervals.end(), cmp);
        vector<vector<int>> res; vector<int> path;
        int idx = 0;
        while(idx < intervals.size()){
            path.clear();
            path.push_back(intervals[idx][0]); // left idx
            int end = intervals[idx][1];
            int nidx = idx + 1;
            while(nidx < intervals.size() && end >= intervals[nidx][0]){
                end = max(end, intervals[nidx][1]); // 右边界要是融合的最大边界
                ++nidx;
            }
            path.push_back(end);
            res.push_back(path);
            idx = nidx;
        }
        return res;
    }

private:
    // sort 函数要求比较函数为静态的或者是非成员函数，而不接受非静态成员函数。
    static bool cmp(const vector<int>& lhs, const vector<int>& rhs){
        if(lhs[0] == rhs[0]){
            return lhs[1] < rhs[1];
        }else{
            return lhs[0] < rhs[0];
        }
    }
};
```

##### lc738 单调递增的数字

```C++
// 贪心思想，从高位往低位，找到第一个不满足单调不减的，然后回退
class Solution {
public:
    int monotoneIncreasingDigits(int n) {
        if(n < 10) {return n;}
        // 寻找第一位不满足广义递增的
        // int 转换成string
        string nums = to_string(n);  // 转换成字符串，方便遍历
        int m_idx = -1;
        for(int i=1; i<nums.size(); i++){
            if(nums[i] < nums[i-1]){ // 找到首次出现不满足的，在index=i-1处需要减1
                m_idx = i - 1;   
                while(m_idx > 0 && nums[m_idx] == nums[m_idx - 1]){  // 回退重复的,因为可能出现nums[i-1]=nums[i-2]的情况，需要回退相同的最高位，在这里-1
                    --m_idx;
                }
                break;
            }
        }
        if(m_idx == -1){return n;} // 说明严格增
        // i - 1之前保持，i - 1位减1, i - 2 位及以后变为9
        int sum = 0;
        for(int i=0; i<nums.size(); i++){
            if(i < m_idx){
                sum = sum * 10 + nums[i] - '0';
            }else if(i == m_idx){
                sum = sum * 10 + nums[i] - '0' - 1; // 首位为0和中间为0的表达式一样
            }else if(i > m_idx){
                sum = sum * 10 + 9;
            }
        }
        return sum; 
    }
};
```

# 动态规划算法

#### 01 普通DP

<font color="red">动态规划最重要的是明白dp数组的定义，以及递推表达式的推导</font>

​	条件：如果一个问题可以分解为很多个子问题，则可以考虑DP；每一个状态均可以由上一个状态或之前的状态推出。

​	DP五部曲：

​	1.明确DP数组含义；最主要是下标

​	2.确定初始值

​	3.确定递推公式

​	4.确定遍历顺序

​	5.打印DP数组

##### lc509 fib

```C++
class Solution {
public:
    int fib(int n) {
        if(n < 2){return n;}
        vector<int> dp(n+1, 0); // dp[i]表示F[n]的值
        dp[1] = 1;
        for(int i = 2; i <= n; i++){
            dp[i] = dp[i - 1] + dp[i - 2];
        }
        return dp[n];
    }
};
```

##### lc70爬楼梯

```C++
// dp[i]表示跳到i阶楼梯的方法数量
class Solution {
public:
    int climbStairs(int n) {
        if(n < 3){return n;}
        // dp[i] = dp[i-1] + dp[i-2];
        vector<int> dp(n+1, 0);
        dp[1] = 1; dp[2] = 2;
        for(int i=3; i<=n; i++){
            dp[i] = dp[i-1] + dp[i-2];
        }
        return dp[n];
    }
};
```

##### lc746花最小花费爬楼梯

```C++
class Solution {
public:
    int minCostClimbingStairs(vector<int>& cost) {
        // 定义dp[n+1], dp[n]表示跳到第n阶台阶所需的最小开销
        vector<int> dp(cost.size() + 1, 0);
        for(int i=2; i<=cost.size(); i++){
            dp[i] = min(dp[i-1] + cost[i-1], dp[i-2] + cost[i-2]);
        }
        return dp[cost.size()];
    }
};
// 第二种，dp[i]定义为从第i阶跳的最小花费
dp[0] = cost[0];
dp[1] = cost[1];
dp[i] = min(dp[i-1], dp[i-2]) + cost[i]; // i >= 2;
```

##### lc62不同路径(一)

```C++
class Solution1 {
public:
    int uniquePaths(int m, int n) {
        // 一共要走m+n-2步, 其中m-1步为left---> C_{m+n-2}^{m-1} = C_{m+n-2}^{n-1}
        // 定义dp[m+1][n+1]; 走到dp[i][j]有多少条路径;
        vector<vector<int>> dp(m, vector<int>(n, 1)); // 初始条件为1
        for(int r=1; r<m; ++r){
            for(int c=1; c<n; ++c){
                dp[r][c] = dp[r-1][c] + dp[r][c-1];
            }
        }
        return dp[m-1][n-1];
    }
};

// 数学方法
class Solution {
public:
    int uniquePaths(int m, int n) {
        // 一共要走m+n-2步, 其中m-1步为left---> C_{m+n-2}^{m-1} = C_{m+n-2}^{n-1}
        // 定义dp[m+1][n+1]; 走到dp[i][j]有多少条路径;
        return C_m_n(m+n-2, min(m-1, n-1));
    }

private:
    int C_m_n(int m, int n){
        long long numerator = 1;
        int denominator = n;
        int count = n;
        while(count){
            numerator *= m--;
            --count;
            while(n && numerator % n == 0){
                numerator /= n--;
            }
        }
        return numerator;
    }
};
```

##### lc63不同路径(二)

```c++
class Solution {
public:
    int uniquePathsWithObstacles(vector<vector<int>>& obstacleGrid) {
        // 定义dp数组, 使用二维和一维都可以，这里用一维试试
        vector<int> dp(obstacleGrid[0].size(), 0);
        for(int i=0; i<obstacleGrid[0].size(); ++i){  // 初始化步骤
            if(obstacleGrid[0][i] || (i > 0 && dp[i-1]==0)){
                dp[i] = 0;
            }else{
                dp[i] = 1;
            }
        }
        for(int i=1; i<obstacleGrid.size(); ++i){
            for(int j=0; j<obstacleGrid[0].size(); ++j){
                if(j==0 && obstacleGrid[i][j] == 0){
                    continue; // 保持
                }
                if(obstacleGrid[i][j]){
                    dp[j] = 0;
                }else{
                    dp[j] += dp[j-1];
                }
            }
        }
        return dp[obstacleGrid[0].size()-1];
    }
};
```

##### lc343 整数拆分

```C++
class Solution {
public:
    int integerBreak(int n) {
        // 定义dp数组，dp[n]表示拆分成k个数的最大值(k>=2)
        vector<int> dp(n+1, 0); // 
        dp[1] = 1, dp[2] = 1; // 初始条件; 2 = (1 + 1); 3 = (1 + 2);
        // 推导递推公式：dp[i] = max{dp[i], (i-j)* j, j * dp[i-j]}; 
        for(int i=3; i<=n; ++i){
            for(int j=1; j<i; j++){
                dp[i] = max(dp[i], max(dp[j] * (i - j), j * (i - j)));
            }
        }
        return dp[n];
    }
};
```

##### lc96 不同的二叉搜索树

```C++
class Solution {
public:
    int numTrees(int n) {
        // dp[i]表示i个节点组成的二叉搜索时的种树;这里只的是结构
        int dp[20] = {0};
        dp[0] = 1, dp[1] = 1;
        for(int i=2; i<=n; ++i){
            for(int j=0; j<i; ++j){
                dp[i] += dp[j]*dp[i-j-1]; // 左子树,左子树种类的组合数相乘
            }
        }
        return dp[n];
    }
};
```

LC801 	[使序列递增的最小交换次数](https://leetcode.cn/problems/minimum-swaps-to-make-sequences-increasing/)

```c++
class Solution {
public:
    int minSwap(vector<int>& nums1, vector<int>& nums2) {
        // 定义dp[i][0] 表示第i个位置不换，dp[i][1]表示第i个位置换的时候最少次数
        vector<vector<int>> dp(nums1.size(), vector<int>(2, INT_MAX));
        dp[0][0] = 0, dp[0][1] = 1;
        for(int i=1; i<nums1.size(); ++i){
            if(nums1[i] > nums1[i-1] && nums2[i] > nums2[i-1]){
                // 要么不交换 dp[i][0] = dp[i-1][0]; 要么两者都交换 dp[i][1] = 1 + dp[i-1]
                dp[i][0] = dp[i-1][0];
                dp[i][1] = dp[i-1][1] + 1;
            }
            // 第二步是为什么// 考虑dp[i]时, 我们的基础是假设dp[i-1][0], dp[i-1][1]已经计算出交换和不交换下的最少次数
            if(nums1[i] > nums2[i-1] && nums2[i] > nums1[i-1]){
                dp[i][0] = min(dp[i][0], dp[i-1][1]);   // 不交换
                dp[i][1] = min(dp[i][1], dp[i-1][0] + 1); // 交换
            }
        }
        return min(dp[nums1.size()-1][0], dp[nums1.size()-1][1]);
    }
};
```



LC790 多米诺铺地板

<img src="I:\U盘内容\Primer\数据结构与算法\代码随想录\pic\image-20230825103033392.png" alt="image-20230825103033392" style="zoom:67%;" />

```c++
class Solution {
public:
    int numTilings(int n) {
        /* 定义f[i][j]为无需考虑前 i - 1列（含义为前i-1列已铺满）， 当前第i列状态为j时的方案数
        其中j的取值范围为[0, 4)*/
        vector<vector<int>> dp(n + 1, vector<int>(4, 0));
        int mod = (1e9 + 7);
        dp[1][0] = dp[1][1] = 1;
        for(int i=2; i<=n; ++i){
            dp[i][0] = dp[i-1][1];
            int cur = 0;
            for(int j=0; j<4; ++j){
                cur = (cur + dp[i-1][j]) % mod;
            }
            dp[i][1] = cur;
            dp[i][2] = (dp[i-1][0] + dp[i-1][3]) % mod;
            dp[i][3] = (dp[i-1][0] + dp[i-1][2]) % mod;
        }
        return dp[n][1];
    }
};
```



#### 02 0-1背包问题

1.思维导图

![image-20230719213927577](I:\U盘内容\Primer\数据结构与算法\代码随想录\pic\image-20230719213927577.png)

tips:0-1背包只有两种情况，物品i放和不放两种，从中选择利益最大者即可。

##### lc416 分割等和子集

```C++
// 二维dp数组
class Solution {
public:
    bool canPartition(vector<int>& nums) {
        // 装东西，要装满
        int sum = Sum(nums);
        if(sum % 2 != 0){return false;}
        int bagWeight = sum / 2;
        vector<vector<int>> dp(nums.size(), vector<int>(bagWeight + 1, 0));
        // 初始化
        for(int i=bagWeight; i>=nums[0]; --i){
            dp[0][i] = nums[0];
        }
        // 遍历
        for(int i=1; i<nums.size(); ++i){
            for(int j=1; j<=bagWeight; ++j){
                if(j < nums[i]){
                    dp[i][j] = dp[i-1][j];
                }else{
                    dp[i][j] = max(dp[i-1][j], dp[i-1][j-nums[i]] + nums[i]);
                }

            }
        }
        return dp[nums.size()-1][bagWeight] == bagWeight;

    }
    
    // 一维方法，节省内存空间
    bool canPartition(vector<int>& nums) {
        // 装东西，要装满
        int sum = Sum(nums);
        if(sum % 2 != 0){return false;}
        int bagWeight = sum / 2;
        vector<int> dp(bagWeight + 1, 0);
        // 初始化
        for(int i=bagWeight; i>=nums[0]; --i){
            dp[i] = nums[0];
        }
        // 遍历
        for(int i=1; i<nums.size(); ++i){
            for(int j=bagWeight; j>=nums[i]; --j){
                 dp[j] = max(dp[j], dp[j-nums[i]] + nums[i]);
            }

        }
        return dp[bagWeight] == bagWeight;

    }

private:
    int Sum(vector<int>& nums){
        int ret = 0;
        for(auto& elem:nums){
            ret += elem;
        }
        return ret;
    }
};
```

##### lc494 目标和

```C++
class Solution {
public:
    int findTargetSumWays(vector<int>& nums, int target) {
        // 分成两堆，一堆是sum; 一堆是sum+target
        // 两个关键公式： sum1 + sum2 = total; sum1 - sum2 = target; --->sum2 = (total-target) / 2;
        int total = accumulate(nums.begin(), nums.end(), 0);
        if(total < abs(target)){return 0;} // 排除无解的情况
        if((total - target) % 2 == 1){return 0;}
        int weights = (total - target) / 2; // 目标容量
        vector<int> dp(weights+1, 0); // dp[j]为装满容量为j的背包的组合数
        dp[0] = 1;
        for(int i=0; i<nums.size(); ++i){
            for(int j=weights; j>=nums[i]; --j){
                dp[j] += dp[j-nums[i]]; // 放和不放的区别
            }
        }
        return dp[weights];
    }
    
    
    // 回溯也可以
    int findTargetSumWays(vector<int>& nums, int target) {
        // 元素只有两种状态，取和不取；是不是也可以回溯
        int sum = accumulate(nums.begin(), nums.end(), 0);
        if(abs(target) > sum || (sum + target) % 2 == 1){return 0;}
        int S = (sum + target) / 2; // S为nums数据的排列子集和
        int count = 0;
        backtracking(nums, 0, S, count);
        return count;

    }

private:
    void backtracking(vector<int>& nums, int start_idx, int target, int&count){
        if(target == 0){
            ++count;
        }
        if(target < 0){
            return;  // 不能在等于0的地方回溯，因为元素可以为0
        }

        for(int idx=start_idx; idx<nums.size() && target>=0; ++idx){
            target -= nums[idx];
            backtracking(nums, idx + 1, target, count);
            target += nums[idx];
        }
    }
};
```

##### lc474 一和零

```C++
// 注意初始条件，dp[x][0]和dp[0][x]都初始化为0，因为题目说了1<= m, n; 不会出现单1或单0的情况
class Solution {
public:
    int findMaxForm(vector<string>& strs, int m, int n) {
        // 可以上升到三维dp数组，这里利用二维回滚数据
        vector<vector<int>> dp(m+1, vector<int>(n+1, 0)); // 其中dp[i][j]表示i个0，j个1包含的最大子集数
        for(int i=0; i<strs.size(); ++i){
            pair<int, int> nums = count(strs[i]);
            for(int j=m; j>=nums.first; --j){
                for(int k=n; k>=nums.second; --k){
                    dp[j][k] = max(dp[j][k], 1 + dp[j-nums.first][k-nums.second]);
                }
            }
        }
        return dp[m][n];
    }
private:
    pair<int, int> count(const string& str){
        int m=0, n=0;
        for(auto&elem:str){
            if(elem == '0'){
                ++m;
            }else{
                ++n;
            }
        }
        return {m, n};
    }
};
```

#### 03 完全背包问题

​	1.完全背包和0-1背包的区别在于，完全背包物品i的数量是无限的，可以重复取；在一维dp数组中，0-1背包是逆序遍历，而在完全背包中内侧遍历顺序却是从小打到的。

```C++
// 先遍历物品，再遍历背包
for(int i=0; i < weight.size(); ++i){
    for(int j=weight[i]; j <= bagWeight; ++j){
        dp[j] = max(dp[j], dp[j-weight[i]] + value[i]);
    }
}
```

##### lc518 零钱兑换II

```C++
class Solution {
public:
    int change1(int amount, vector<int>& coins) {
        if(amount == 0) return 1;
        // 先回溯试一下;会超时
        int count = 0;
        sort(coins.begin(), coins.end());
        backtracking(coins, 0, amount, count);
        return count;
        
    }

    int change(int amount, vector<int>& coins) {
        // 定义dp数组; dp[j]表示装满背包容量为j的种数
        vector<int> dp(amount+1, 0);
        dp[0] = 1;
        for(int i = 0; i < coins.size(); ++i){
            for(int j = 1; j <= amount; ++j){
                if(j >= coins[i]){
                    dp[j] += dp[j-coins[i]];
                }
            }
        }
        return dp[amount];  
    }

private:
    void backtracking(vector<int>& coins, int start_idx, int amount, int& count){
        if(amount == 0){
            ++count;
            return;
        }
        if(amount < 0) return;

        for(int i=start_idx; i < coins.size() && amount >= coins[i]; ++i){
            amount -= coins[i];
            backtracking(coins, i, amount, count);
            amount += coins[i];
        }
    }
};
```

<font color="red">本题的难点在于遍历顺序，在求装满背包有几种方案的时候，认清遍历顺序很重要。</font>

- 如果求组合数，就是外层for循环遍历物品、内层for循环遍历背包
- 如果求排列数，就是外层for循环遍历背包、内存for循环遍历物品

##### lc377 组合总和IV

```C++
class Solution {
public:
    int combinationSum4(vector<int>& nums, int target) {
        vector<int> dp(target+1, 0);
        dp[0] = 1;
        for(int i=1; i<=target; ++i){
            for(int j=0; j<nums.size(); ++j){
                // dp[i] < INT_MAX - dp[i - nums[j]] 似乎并没有很好的说服力，舍弃结果？
                if(i >= nums[j] && dp[i] < INT_MAX - dp[i - nums[j]]){
                    dp[i] += dp[i - nums[j]];
                }
            }
        }
        return dp[target];
    }
};
```

##### lc322 零钱兑换II

```C++
// 组合和排列都可以，因此不强调顺序关系
class Solution {
public:
    int coinChange(vector<int>& coins, int amount) {
        // 假设dp数组：dp[j] 表示凑成总金额j所需的最少硬币个数
        vector<int> dp(amount + 1, INT_MAX);
        dp[0] = 0;
        for(int i=0; i<coins.size(); ++i){
            for(int j=coins[i]; j<=amount; j++){
                if(dp[j] > dp[j-coins[i]]){  // 避免溢出问题
                    dp[j] = 1 + dp[j-coins[i]];
                }
            }
        }
        return (dp[amount] == INT_MAX) ? -1:dp[amount];
    }
};
```

##### lc278 完全平方数

```C++
class Solution {
public:
    int numSquares(int n) {
        // Q1: 一个整数1<=n一定可以写成完全平方数的和嘛？ 一定可以，最差全为1
        vector<int> dp(n+1, INT_MAX); // 定义dp[i]表示整数i写成完全平方数和的最少个数
        dp[0] = 0;
        // int max_num = sqrt(n);
        for(int i=1; i<=n; ++i){ // 可以避免一次开方
            for(int j=i*i; j<=n; ++j){
                dp[j] = min(dp[j], 1 + dp[j - i*i]);
            }
        }
        return dp[n];
    }

};
```

##### lc139 单词拆分

```C++
// 这里借用排列的思想方便做题
class Solution {
public:
    bool wordBreak(string s, vector<string>& wordDict) {
        vector<int> dp(s.size() + 1, 0); // dp[i]表示从index=0开始的i个字符是否可以由wordDict拼接而成
        dp[0] = true;
        for(int i=1; i<=s.size(); ++i){
            for(int j=0; j<wordDict.size(); ++j){
                if(i >= wordDict[j].size() && dp[i] == false){
                    dp[i] = (dp[i - wordDict[j].size()]) && IsOk(s, wordDict[j], i-1);
                }
            }
        }
        return dp[s.size()];
    }

private:
    bool IsOk(const string& lhs, const string& rhs, int lidx){
        int rsz = rhs.size()-1;    
        while(rsz >= 0){
            if(lhs[lidx--] != rhs[rsz--]){
                return false;
            }
        }
        return true;
    }
};
// 回溯也是可以的
```

##### lc121 买卖股票的最佳时机

```C++
// 1. 维护一个递增数组
class Solution {
public:
    int maxProfit(vector<int>& prices) {
        vector<int> upvec(2, 0);
        int Min = INT_MAX; // 记录最小的元素
        int profit = 0;
        for(int i=0; i<prices.size(); ++i){
            if(Min > prices[i]){ // 重置数组
                upvec[0] = upvec[1] = prices[i];
                Min = prices[i];
                continue;
            }
            if(upvec[1] < prices[i]){ // 更新利润最大值
                profit = max(profit, prices[i] - upvec[0]);
                upvec[1] = prices[i]; // 替换最大值
            }
        }
        return profit;
    }
    
    int maxProfit(vector<int>& prices) {
        // 定义动态数组dp[prices.size()][2]; dp[i][0]:第i+1天不持有股票的最大利润； dp[i][1]表示持有股票的最大利润
        // vector<vector<int>> dp(prices.size(), vector<int>(2, 0));
        // dp[0][0] = 0, dp[0][1] = -prices[0];
        // for(int i=1; i<prices.size(); ++i){
        //     dp[i][0] = max(dp[i-1][0], dp[i-1][1] + prices[i]);
        //     dp[i][1] = max(dp[i-1][1], -prices[i]);
        // }
        // return dp[prices.size()-1][0];
        // 优化内存
        int dp[2][2];
        dp[0][0] = 0, dp[0][1] = -prices[0];
        for(int i=1; i<prices.size(); ++i){
            int next = i % 2, prev = (i - 1) % 2;
            dp[next][0] = max(dp[prev][0], dp[prev][1] + prices[i]);
            dp[next][1] = max(dp[prev][1], -prices[i]);
        }
        return dp[(prices.size()-1) % 2][0];
        
    }
    
    // 哈希也可以的；贪心更6
       int maxProfit(vector<int>& prices) {
        int low = prices[0];
        int result = 0;
        for(int i=1; i<prices.size(); ++i){
            low = min(low, prices[i]);
            result = max(result, prices[i] - low);
        }
        return result;
    }
};
```

##### lc122 买卖股票的最佳时机II

```C++
// 可以贪心，可以dp
class Solution {
public:
    int maxProfit(vector<int>& prices) {
        vector<vector<int>> dp(prices.size(), vector<int>(2, 0));
        dp[0][1] = -prices[0];
        for(int i=1; i<prices.size(); ++i){
            dp[i][0] = max(dp[i-1][0], dp[i-1][1] + prices[i]);
            dp[i][1] = max(dp[i-1][1], dp[i-1][0] - prices[i]);
        }
        return dp[prices.size()-1][0];
    }
};
```

##### lc123 买卖股票的最佳时机

```C++
// 动态DP最重要的一点就是DP公式的推导
class Solution {
public:
    int maxProfit(vector<int>& prices) {
        int dp[4] = {0};
        dp[0] = -prices[0]; // 持有第一股
        dp[2] = -prices[0]; // 持有第二股
        int maxValue = 0;
        for(int i=1; i<prices.size(); ++i){
            dp[3] = max(dp[3], dp[2] + prices[i]);
            dp[2] = max(dp[2], dp[1] - prices[i]);
            dp[1] = max(dp[1], dp[0] + prices[i]);
            dp[0] = max(dp[0], -prices[i]); 
            maxValue = max(maxValue, max(dp[1], dp[3]));
        }
        return maxValue;
    }
};
```

##### lc188 买卖股票的最佳施加IV

```C++
// 从买卖一次，到2次，到n次;都可以用动态dp解出来，股票问题就是定义dp[i][0]:第i天不持有股票；dp[i][1]持有股票之类的
class Solution {
public:
    int maxProfit(int k, vector<int>& prices){
        if(k==0 || prices.empty()){return 0;}
        vector<int> dp(2*k, 0);
        dp.reserve(2*k);

        // 初始化
        for(int i=0; i < 2 * k; i += 2){
            dp[i] = -prices[0];
        }

        // 遍历
        int maxValue = 0;
        for(int i=1; i<prices.size(); ++i){
            for(int j=2*k-1; j>0; --j){
                if(j % 2 != 0){
                    dp[j] = max(dp[j], dp[j-1] + prices[i]);
                    maxValue = max(maxValue, dp[j]);
                }else{
                    dp[j] = max(dp[j], dp[j-1] - prices[i]);
                }
            }
            dp[0] = max(dp[0], -prices[i]);   
        }
        return maxValue;
    }
};
```

##### lc309 最佳买卖股票时间（含冷冻期)

```C++
class Solution {
public:
    int maxProfit(vector<int>& prices) {
        if(prices.size() < 2){return 0;}
        vector<vector<int>> dp(prices.size(), vector<int>(4, 0));
        dp[0][0] = -prices[0];  // 持有股票状态
        dp[0][1] = 0; // 今天是非冷冻期且不持有股票转态（前二天卖出）
        dp[0][2] = 0; // 今天卖出股票
        dp[0][3] = 0; // 今天是冷冻期，持续一天
        for(int i=1; i<prices.size(); ++i){
            dp[i][2] = dp[i-1][0] + prices[i];
            dp[i][0] = max(dp[i-1][0], max(dp[i-1][1], dp[i-1][3]) - prices[i]);

            dp[i][1] = max(dp[i-1][1], dp[i-1][3]);
            
            dp[i][3] = dp[i-1][2];
        }

        return max(dp[prices.size()-1][1], max(dp[prices.size()-1][2], dp[prices.size()-1][3]));
    }
};
```

###### lc714 买卖股票的最佳时机（含手续费)

```C++
class Solution {
public:
    int maxProfit(vector<int>& prices, int fee) {
        int dp[2] = {0}; // dp[0]:不持有; dp[1]:持有的最大利润
        dp[1] = -prices[0];
        for(int i=1; i<prices.size(); ++i){
            int tmp = dp[1];
            dp[1] = max(dp[1], dp[0] - prices[i]);
            dp[0] = max(dp[0], dp[1] + prices[i] - fee);
        }
        return dp[0];
    }
};
```



##### lc300 最大递增子序列

```c++
// 以nums[i]结尾的最大递增子序列长度
class Solution {
public:
    int lengthOfLIS(vector<int>& nums) {
        if(nums.size() < 2){return nums.size();}
        vector<int> dp(nums.size(), 1); // dp[i]定义为以nums[i]结尾的最大递增子序列的长度
        int maxLen = 1;
        for(int i=1; i<nums.size(); ++i){
            for(int j=0; j<i; ++j){
                if(nums[i] > nums[j]){
                    dp[i] = max(dp[i], 1 + dp[j]);
                }
            }
            maxLen = max(maxLen, dp[i]);
        }
        return maxLen;
    }
};
```



lc674 最长连续递增子序列

```C++
class Solution {
public:
    int findLengthOfLCIS(vector<int>& nums) {
        if(nums.size() < 2){return nums.size();}
        int maxLen = 1;
        int dp = 1;
        for(int i=1; i<nums.size(); ++i){
            if(nums[i] > nums[i-1]){
                ++dp;
            }else{
                maxLen = max(maxLen, dp);
                dp = 1;
            }
        }
        return max(maxLen, dp);
    }
};
```



##### lc718 最长重复子数组

```C++
// 关键是二维dp数组，也可以是一维dp
class Solution {
public:
    int findLength(vector<int>& nums1, vector<int>& nums2) {
        if(nums1.empty() || nums2.empty()){return 0;}
        // 定义dp[i][j]为以nums1[i-1]和nums2[j-1]结尾的重复子数组场地
        vector<vector<int>> dp(nums1.size() + 1, vector<int>(nums2.size() + 1, 0));
        int maxLen = 0;
        for(int i=1; i<=nums1.size(); ++i){
            for(int j=1; j<=nums2.size(); ++j){
                if(nums1[i-1]==nums2[j-1]){
                    dp[i][j] = 1 + dp[i-1][j-1];
                    maxLen = max(maxLen, dp[i][j]);
                }
            }
        }
        return maxLen;
    }
};
// 一维dp
class Solution {
public:
    int findLength(vector<int>& nums1, vector<int>& nums2) {
        if(nums1.empty() || nums2.empty()){return 0;}
        // 定义dp[i][j]为以nums1[i-1]和nums2[j-1]结尾的重复子数组场地
        int sz;
        vector<int>* minNums, *maxNums;
        if(nums1.size() <= nums2.size()){
            sz = nums1.size();
            minNums = &nums1;
            maxNums = &nums2;
        }else{
            sz = nums2.size();
            minNums = &nums2;
            maxNums = &nums1;
        }
        vector<int> dp(sz + 1, 0);
        int maxLen = 0;
        for(int i=1; i<=maxNums->size(); ++i){
            for(int j=minNums->size(); j>=1; --j){
                if(nums1[i-1]==nums2[j-1]){
                    dp[j] = 1 + dp[j-1];
                    maxLen = max(maxLen, dp[j]);
                }else{
                    dp[j] = 0;
                }
            }
        }
        return maxLen;
    }
};
```



##### lc1143.最长公共子序列

```C++
class Solution {
public:
    int longestCommonSubsequence(string text1, string text2) {
        if(text1.empty()||text2.empty()){return 0;}
        // 定义dp[i][j]为text1[0..i]和text2[0...j]的最长公共子序列
        vector<vector<int>> dp(text1.size() + 1, vector<int>(text2.size() + 1, 0));
        for(int i=1; i<=text1.size(); ++i){
            for(int j=1; j<=text2.size(); ++j){
                if(text1[i-1] == text2[j-1]){
                    dp[i][j] = 1 + dp[i-1][j-1];
                }else{
                    dp[i][j] = max(dp[i-1][j], dp[i][j-1]);
                }
            }
        }
        return dp[text1.size()][text2.size()];
    }
};
```



##### 1c1035.不相交的线

```C++
// 不相交就说明了是公共子串问题，求最长公共子串长度
class Solution {
public:
    int maxUncrossedLines(vector<int>& text1, vector<int>& text2) {
        if(text1.empty()||text2.empty()){return 0;}
        // 定义dp[i][j]为text1[0..i]和text2[0...j]的最长公共子序列
        vector<vector<int>> dp(text1.size() + 1, vector<int>(text2.size() + 1, 0));
        for(int i=1; i<=text1.size(); ++i){
            for(int j=1; j<=text2.size(); ++j){
                if(text1[i-1] == text2[j-1]){
                    dp[i][j] = 1 + dp[i-1][j-1];
                }else{
                    dp[i][j] = max(dp[i-1][j], dp[i][j-1]);
                }
            }
        }
        return dp[text1.size()][text2.size()];
    }
};
```



##### lc53最大子数组和

```C++
class Solution {
public:
    int maxSubArray1(vector<int>& nums) {
        // 贪心
        if(nums.empty()) return 0;
        int maxConsisSum = nums[0];
        int sum = nums[0];
        for(int i=1; i<nums.size(); ++i){
            if(sum < 0){
                sum = nums[i];
            }else{
                sum += nums[i];
            }
            maxConsisSum = max(maxConsisSum, sum);
        }
        return maxConsisSum;
    }

   	int maxSubArray(vector<int>& nums) {
        // 贪心
        if(nums.empty()) return 0;
        vector<int> dp(nums.size(), 0); // 定义dp[i]为以nums[i]结尾的最大子数组和
        dp[0] = nums[0];
        int maxSum = dp[0];
        for(int i=1; i<nums.size(); ++i){
            if(dp[i-1] >= 0){
                dp[i] = dp[i-1] + nums[i];
            }else{
                dp[i] = nums[i];
            }
            if(maxSum < dp[i]) maxSum = dp[i];
        }
        return maxSum;
    }
};
```

##### lc392 判断子序列

```C++
class Solution {
public:
    bool isSubsequence1(string s, string t) {
        if(s.size() > t.size()) return false;
        if(s.empty()) return true;

        vector<vector<int>> dp(t.size() + 1, vector<int>(s.size() + 1, 0));
        for(int i=1; i<=t.size(); ++i){
            for(int j=1; j<=s.size(); ++j){
                if(t[i-1] == s[j-1]){
                    dp[i][j] = 1 + dp[i-1][j-1];
                }else{
                    dp[i][j] = max(dp[i-1][j], dp[i][j-1]);
                }
            }
        }
        return dp[t.size()][s.size()] == s.size();
    }


    bool isSubsequence(string s, string t) {
        if(s.size() > t.size()) return false;
        if(s.empty()) return true;
        int sidx = 0, tidx = 0;
        while(sidx < s.size() && tidx < t.size()){
            if(s[sidx] == t[tidx]) ++sidx, ++tidx;
            else{++tidx;}
        }
        return sidx == s.size();
    }
};
// 进阶：如果有大量输入的 S，称作 S1, S2, ... , Sk 其中 k >= 10亿，你需要依次检查它们是否为 T 的子序列。在这种情况下，你会怎样改变代码？ ---> 回溯求子序列集合？+ 哈希？
// 处理大量数据的方式
class Solution {
public:
	bool isSubsequence(string s, string t) {
		t.insert(t.begin(), ' ');
		int len1 = s.size(), len2 = t.size();
		// dp[i][j] 表示字符串 t 中索引 i 处的字符之后，下一个字母 j 出现的位置。
		vector<vector<int> > dp(len2 , vector<int>(26, 0));

		for (char c = 'a'; c <= 'z'; c++) {
			int nextPos = -1; //表示接下来再不会出现该字符；下一跳为没有了，到了字符尾

			for (int i = len2 - 1; i>= 0; i--) {  //为了获得下一个字符的位置，要从后往前
				dp[i][c - 'a'] = nextPos;
				if (t[i] == c)
					nextPos = i;
			}
		}

		int index = 0;
		for (char c : s) {
			index = dp[index][c - 'a'];
			if (index == -1)
				return false;
		}
		return true;

	}
};
```



##### lc115 不同的子序列

```C++
class Solution {
public:

    int numDistinct(string s, string t) {
        if(s.size() < t.size()) return 0;
        // 定义dp[i][j]表示s[0...j-1]出现t[0...i-1]中次数
        vector<vector<uint64_t>> dp(s.size() + 1, vector<uint64_t>(t.size() + 1, 0));
        for(int i = 0; i<s.size(); ++i){dp[i][0] = 1;}
        for(int i = 1; i<t.size(); ++i){dp[0][i] = 0;}
        for(int i=1; i<=s.size(); ++i){
            for(int j=1; j<=t.size(); ++j){
                if(s[i-1]==t[j-1]){
                    dp[i][j] = dp[i-1][j-1] + dp[i-1][j]; // 相等时，可以不用s[i-1],也可以用
                }else{
                    dp[i][j] = dp[i-1][j];
                }
            }
        }
        return dp[s.size()][t.size()];
    }
};
```

##### lc583 两个字符串的删除操作

```C++
class Solution {
public:
    int minDistance(string word1, string word2) {
        return word1.size() + word2.size() - 2 * maxCommonLength(word1, word2);
    }

private:
    int maxCommonLength(const string& word1, const string& word2){
        if(word1.empty() || word2.empty()) return 0;
        // 定义dp[i][j]为s[0...i]和t[0...j]中的最长公共子序列长度
        vector<vector<int>> dp(word1.size() + 1, vector<int>(word2.size() + 1, 0));
        for(int i=1; i<=word1.size(); ++i){
            for(int j=1; j<=word2.size(); ++j){
                if(word1[i-1]==word2[j-1]){
                    dp[i][j] = 1 + dp[i-1][j-1];
                }else{
                    dp[i][j] = max(dp[i][j-1], dp[i-1][j]);
                }
            }
        }
        return dp[word1.size()][word2.size()];
    }
};
```

##### lc72 编辑距离

```C++
class Solution {
public:
    int minDistance(string word1, string word2) {
        if(word1.empty()){return word2.size();}
        if(word2.empty()){return word1.size();}

        // 都不为空; dp[i][j]表示word1[0...i-1]转换为word2[0...j-1]所需的最少步骤
        vector<vector<int>> dp(word1.size() + 1, vector<int>(word2.size() + 1, 501));
        for(int i=0; i<word2.size(); ++i){dp[0][i] = i;}
        for(int i=1; i<word1.size(); ++i){dp[i][0] = i;}

        for(int i=1; i<=word1.size(); ++i){
            for(int j=1; j<=word2.size(); ++j){
                if(word1[i-1] == word2[j-1]){
                    dp[i][j] = dp[i-1][j-1];
                }else{
                    // 处理不相等的情况
                    dp[i][j] = min(dp[i][j], dp[i-1][j-1] + 1); // 修改
                    dp[i][j] = min(dp[i][j], dp[i-1][j] + 1); // 删除最后一个元素word1[i];
                    dp[i][j] = min(dp[i][j], dp[i][j-1] + 1); // 模拟增加一个元素
                }
            }
        }
        return dp[word1.size()][word2.size()];
    }
};
```

##### lc647回文子串

```C++
class Solution {
public:
    int countSubstrings1(string s) {
        if(s.empty()) return 0;
        vector<int> dp(s.size(), 0); // dp[i]表示nums[0...i]区间内的回文数
        dp[0] = 1;
        for(int i=1; i<s.size(); ++i){
            dp[i] = dp[i-1]; // 不包含s[i]的回文串数
            for(int j=0; j<=i; j++){
                dp[i] += isReverse(s, j, i);
            }
        }
        return dp[s.size() - 1];
    }

    int countSubstrings2(string s) {
        if(s.empty()) return 0;
        // 定义二维dp数组 dp[i][j]表示区间[i...j]是不是回文串。i<=j
        vector<vector<bool>> dp(s.size(), vector<bool>(s.size(), false));
        int result = 0;
        for(int i=s.size()-1; i>=0; --i){
            for(int j=i; j<s.size(); ++j){
                if(s[i] != s[j]){
                    dp[i][j] = false;
                }else{
                    if(i == j) dp[i][j] = true;
                    else if(i + 1 == j) dp[i][j] = true;
                    else dp[i][j] = dp[i+1][j-1];
                }
                result += dp[i][j];
            }
        }
        return result;
    }

    // 双指针法，寻找对称中心，两边辐射
    int countSubstrings(string s) {
        if(s.empty()) return 0;
        int result = 0;
        for(int i=0; i<s.size(); ++i){
            result += extend(s, i, i, s.size()); // 一个中心点
            result += extend(s, i, i+1, s.size());
        }
        return result;
    }

private:
    int extend(const string& s, int left, int right, int n){
        int res = 0;
        while(left>=0 && right<n && s[left]==s[right]){
            --left, ++right, ++res;
        }
        return res;
    }

    bool isReverse(const string& str, int left, int right){
        while(left < right){
            if(str[left++] != str[right--]){
                return false;
            }
        }
        return true;
    }
};
```

##### lc516 最长回文子序列

```C++
class Solution {
public:
    int longestPalindromeSubseq(string s) {
        if(s.size() < 2){return s.size();}

        // 定义dp数组, dp[i][j]表示[i...j]区间内的最长回文子序列
        vector<vector<int>> dp(s.size(), vector<int>(s.size(), 0));
        for(int i=s.size()-1; i>=0; --i){
            for(int j=i; j<s.size(); ++j){
                if(s[i] != s[j]){
                    dp[i][j] = max(dp[i+1][j], dp[i][j-1]); // 不相等,说明[i...j]至少两元素
                }else if(s[i] == s[j]){
                    if(i == j) dp[i][j] = 1;           // 一个中心点
                    else if(i + 1 == j) dp[i][j] = 2; // 二个中心点
                    else dp[i][j] = dp[i+1][j-1] + 2;
                }
            }
        }
        return dp[0][s.size()-1];
    }
};
```

##### LC 730.统计不同回文子序列

​	给你一个字符串 `s` ，返回 `s` 中不同的非空回文子序列个数 。由于答案可能很大，请返回对 `109 + 7` **取余** 的结果。

字符串的子序列可以经由字符串删除 0 个或多个字符获得。

如果一个序列与它反转后的序列一致，那么它是回文序列。

如果存在某个 `i` , 满足 `ai != bi` ，则两个序列 `a1, a2, ...` 和 `b1, b2, ...` 不同。

![image-20231004090313346](I:\U盘内容\Primer\数据结构与算法\代码随想录\pic\image-20231004090313346.png)

```C++
class Solution {
public:
    const int mod = 1e9 + 7;
    int countPalindromicSubsequences(string s) {
        // 统计不同回文子序列的
        int n = s.size();
        // 定义dp数组, dp(x, i, j)表示s[i...j]闭区间内，以x为首尾的回文子序列数量
        vector<vector<vector<int>>> dp(4, vector<vector<int>>(n, vector<int>(n, 0)));
        // 初始化
        for(int i=0; i<n; ++i){
            dp[s[i] - 'a'][i][i] = 1;
        }

        for(int len = 2; len <= n; ++len){ // 遍历所有可能的长度
            for(int i=0, j = len - 1; j < n; ++i, ++j){
                for(char c = 'a', k = 0; c <= 'd'; ++c, ++k){
                    if(s[i] == c && s[j] == c){
                        dp[k][i][j] = (2LL + dp[0][i+1][j-1] + dp[1][i+1][j-1] + dp[2][i+1][j-1] + dp[3][i+1][j-1]) % mod;
                    }else if(s[i] == c){
                        dp[k][i][j] = dp[k][i][j-1];
                    }else if(s[j] == c){
                        dp[k][i][j] = dp[k][i+1][j];
                    }else{
                        dp[k][i][j] = dp[k][i+1][j-1];
                    }
                }
            }
        }
        int res = 0;
        for(int i=0; i<4; ++i){
            res = (res + dp[i][0][n-1]) % mod;
        }
        return res;
    }
};
```

​	

# 综合类

##### lc 51数组中的逆序对

​	// 在归并的过程计算逆序对的数量；
$$
时间复杂度: o(nlogn); \ 空间复杂度o(n)
$$

```C++
class Solution {
public:
    int reversePairs(vector<int>& nums) {
        if(nums.size() < 2){return 0;}
        vector<int> arr(nums.size(), 0);
        
        int num = mergeSort(nums, 0, nums.size()-1, arr);
        return num;
    }
private:
    int mergeSort(vector<int>&nums, int left, int right, vector<int>& arr){
        /*
            nums: source arr;
            nums[left...right] to sort;
            arr: tempoary arr
            return: the number of reverse pairs
        */
        if(left == right){
            return 0;
        }
        int mid = left + (right - left) / 2;
        int leftPairs = mergeSort(nums, left, mid, arr);
        int rightPairs = mergeSort(nums, mid + 1, right, arr);
        if(nums[mid] <= nums[mid+1]){return leftPairs + rightPairs;} // 优化步骤
        int mergerPairs = merge(nums, left, mid, right, arr);
        return leftPairs + rightPairs + mergerPairs;
    }

    int merge(vector<int>& nums, int left, int mid, int right, vector<int>& arr){
        // 从源数组拷贝元素
        for(int idx=left; idx<=right; ++idx){
            arr[idx] = nums[idx];
        }
        int lidx = left, ridx = mid + 1;
        int count = 0;
        for(int idx=left; idx<=right; ++idx){
            if(lidx > mid){
                nums[idx] = arr[ridx++];
            }else if(ridx > right){
                nums[idx] = arr[lidx++];
            }else if(arr[lidx]<=arr[ridx]){
                nums[idx] = arr[lidx++];
            }else{
                nums[idx] = arr[ridx++];
                count += mid - lidx + 1;
            }
        }
        return count;
    }
};
```

##### lc912 排序数组

​	主要用来锻炼下快排

```C++
class Solution {
public:
    vector<int> sortArray(vector<int>& nums) {
        qSort(nums, 0, nums.size()-1);
        return nums;
    }

private:
    void qSort(vector<int>& nums, int left, int right){
        if(left >= right) return;
        // 闭区间; 随机中轴
        int pivot = left + rand() % (right - left + 1);
        swap(nums[left], nums[pivot]);
        int lidx = left, ridx = right;
        int pivotNum = nums[left];
        while(lidx < ridx){
            while(lidx < ridx && nums[ridx] >= pivotNum){
                --ridx;
            }
            nums[lidx] = nums[ridx];
            while(lidx < ridx && nums[lidx] <= pivotNum){
                ++lidx;
            }
            nums[ridx] = nums[lidx];
        }
        nums[lidx] = pivotNum;

        // 去重, [left, lidx-1], [ridx + 1, right]
        while(lidx > left && nums[lidx] == nums[lidx-1]) --lidx;
        while(ridx < right && nums[ridx] == nums[ridx+1]) ++ridx; 
        qSort(nums, left, lidx - 1);
        qSort(nums, ridx + 1, right);
    }
};
```





# 笔试编程题

### 1.小红书提前批

```C++
// t1:求n个不相等元素构成的数组，其最大公约数为K,求数组的最小和； 1<= n, k <= 1e5;
// 完全是类型溢出导致；
// 原答案：
int main() {
	int n, k; // int类型太小了
	cin >> n >> k;
	long long sum = ((n) * (n + 1) / 2) * k; // 导致溢出 int * int 
	cout << sum << endl;
	return 0;
}
// 输入n, k
100000 100000
2087268864
// 修改后
int main() {
    long long n, k;
    cin >> n >> k;
    long long sum = ((n) * (n + 1) / 2) * k;
    cout << sum << endl;
    return 0;
}
```



```C++
// t2: 假设一个区间[0, n]； 设置m个精华区间; [l_i, r_i） 表示包含 r_i - l_i 个精华帖子。 且各个精华区间不会出现重复的精华帖子
// 取一个长度为k的; 求覆盖的最大精华帖子数量
/*
	自己的思路：
	1.维护一个状态dp数组[0, n]; 
	2.然后遍历每一个区间，将区间的状态设置为1；
	2.然后利用滑动窗口，进行模拟入队出队，计算窗口内的值，一直取最大值；
*/
#include <iostream>
#include <vector>
#include <algorithm>
#include <numeric>
#include <queue>
using namespace std;

int main() {
    int n, m, k;
    cin >> n >> m >> k;
    vector<int> dp(n + 1, 0);
    for (int i = 0; i < m; ++i) {
        int lidx, ridx;
        cin >> lidx >> ridx;
        while (lidx < ridx) {
            dp[lidx++] = 1;
        }
    }
    // 数组准备好，滑动窗口
    queue<int> q;
    if (k >= n) { return accumulate(dp.begin(), dp.end(), 0); }
    int max_sum = 0;
    for (int i = 0; i < k; ++i) {
        q.push(dp[i]);
        max_sum += dp[i];
    }
    int tmp_sum = max_sum;
    for (int i = k; i < n; ++i) {
        tmp_sum = (tmp_sum - q.front() + dp[i]);
        max_sum = max(max_sum, tmp_sum);
        q.pop();
        q.push(dp[i]);
    }
    return max_sum;
}
// 缺点：空间复杂度超了，因为输入区间特别大，上亿了；因此不行
void solve(int n, int m, int k){
    /*
        int n: 区间长度[0, n];
        int m: 精华区间数量
        int k: 滑动窗口数量
    */
   vector<w> nums(m);  // 精华区间集合
   for(int i=0; i<m; ++i){
       cin >> nums[i].x >> nums[i].y;
   }
   // 精华区间有序； 
   sort(nums.begin(), nums.end(), [](const w& lhs, const w& rhs){return lhs.x <= rhs.x;});
   ll cur = nums[0].y - nums[0].x, left = 0, right = 1, ans = cur;
   while(right < m){
       if(nums[right].y - nums[left].x > k){
           while(left < right && nums[right].y - nums[left].x > k){
               cur -= nums[left].y - nums[left].x; // 这里似乎可以优化， 二分？
               ++left;
           }
       }else{
           cur += nums[right].y - nums[right].x;
           ans = max(ans, cur);
           ++right;
       }
   }
   cout << ans << endl;

}
```



```c++
// t3: 题目在数组中可以修改一个数字，将其改成x; 求修改后最大的连续子数组和
// 关键是dp数组的意思，只允许修改一个；dp[i][0]表示子数组没有修改，且以nums[i]结尾是最大和；dp[i][1]表示以nums[i]结尾，且可修改一次的最大和
#include <iostream>
#include <vector>
using namespace std;

int max_consisten_arr(int n, int x) {
    vector<int> nums(n, 0);
    for (int i = 0; i < n; ++i) {
        cin >> nums[i];
    }
    // dp[i][0]表示以nums[i]结尾且不修改时的最大连续数组和; dp[i][1]表示以nums[i]结尾且修改的条件下最大连续数组和
    vector<vector<long long>> dp(n, vector<long long>(2, 0));  // 定义成 long long 怕溢出
    dp[0][0] = nums[0]; // 表示不修改
    dp[0][1] = x; // 表示
    int _max = max(dp[0][0], dp[0][1]); 
    for(int i=1; i<n; ++i){
        dp[i][0] = max(dp[i-1][0] + nums[i], nums[i]); // 没有修改，表示连续子数组一个都没有修改
        dp[i][1] = max(dp[i-1][1] + nums[i], max(dp[i-1][0] + x, x)); // 两种情况，修改尾巴，或者中间已有修改
        _max = max(_max, max(dp[i][0], dp[i][1]));
    }
    return _max;
    // 如果还超内存，可以考虑一维数组；因为只跟前后有关
}

int main() {
    int t;
    cin >> t;
    for (int i = 0; i < t; ++i) {
        int n, x;
        cin >> n >> x;
        int _max = max_consisten_arr(n, x);
        cout << _max << endl;
    }
}
```

### 2.亿联网络

```C++
// 在n个数字中，每隔k个数字删除一个，求最后一个被删除数字下标
int findLastIndex(int n, int k) {
    std::vector<int> arr(n, 0);  // 复制原始数组
    for(int i=0; i<n; i++){
        arr[i] = i;
    }

    int step = k;
    int index = 0;

    while (arr.size() > 1) {
        int len = arr.size();
        int removeIndex = (index + step) % len;
        arr.erase(arr.begin() + removeIndex);
        index = removeIndex % arr.size();  // 索引要更新
    }
    return arr[0];
}
```



### 3.诺瓦星云

##### 	1.求最长无重复子串； 类似于求最长无重复子串的长度

```C++
class Solution {
public:
    int lengthOfLongestSubstring(string s) {
        unordered_set<char> uset;
        int idx = 0;
        int max_len = 0;
        for(int i=0; i<s.size(); ++i){
            if(uset.count(s[i])){
                // 有重复的
                max_len = max(max_len, i - idx);
                while(idx < i && s[idx] != s[i]){
                    uset.erase(s[idx]);
                    ++idx;
                }
                ++idx;
            }else
                uset.insert(s[i]);
        }
        return max_len > (s.size() - idx) ? max_len : s.size() - idx;
    }
};
```

### 烽火通信

​	magic 航行

<img src="I:\U盘内容\Primer\数据结构与算法\代码随想录\pic\image-20230914214109735.png" alt="image-20230914214109735" style="zoom:50%;" />

```C++
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;

class Solution{
public:
    void solve(){
        cin >> sx >> sy >> ex >> ey >> n;
        string str(n, ' ');
        for(int i=0; i<n; ++i){
            char ch;
            cin >> str[i];
            dy[i+1] = dy[i];  // 从下标1开始
            dx[i+1] = dx[i];
            // 前缀和, 第i+1天风的偏移量
            if(str[i] == 'U') dy[i+1]++;
            if(str[i] == 'D') dy[i+1]--;
            if(str[i] == 'L') dx[i+1]--;
            if(str[i] == 'R') dx[i+1]++;
        }

        // 二分天数
        ll head = 0, tail = 1e18, ans = -1, mid;
        while(head <= tail){
            mid = head + (tail - head) / 2;
            if(_solve(mid)){
                ans = mid;
                tail = mid - 1;
            }else{
                head = mid + 1;
            }
        }
        cout << ans << endl;
    }

private:
    int sx, sy, ex, ey, n;
    int dx[100001] = {0}, dy[100001] = {0};

private:
    bool _solve(ll mid){
        ll a = mid / n;
        ll b = mid % n;

        ll x = a * dx[n] + dx[b] + sx;
        ll y = a * dy[n] + dy[b] + sy;
        ll res = abs(x - ex) + abs(y - ey); // 所需天数
        return res <= mid;
    }
};


int main(){
    Solution sp;
    sp.solve();
}
```



# 笔试的常规知识题

1. IaaS、PaaS和SaaS的功能：
   - IaaS（基础设施即服务）：提供基础的计算资源，如虚拟机、存储和网络
     - 用户可以按需使用这些资源，根据自己的需求进行配置和管理
     - 用户负责OS、中间件、应用程序的安装和关联
   - PaaS（平台即服务）：在IaaS的基础上，进一步提供应用程序开发和部署的平台
     - 提供了开发、测试、部署和管理应用程序所需的工具、库和环境
     - 用户可以专注于应用程序的开发而无须担心底层基础设施的管理
   - SaaS（软件即服务）：提供完整的应用程序作为服务，用户可以通过互联网直接访问并使用这些应用程序
     - 用户无需关系底层的硬件、OS、中间件和数据库等，只需使用提供的应用功能
     - 典型的SaaS包括邮件服务、在线办公套件、客户关系管理等

# 剑指offer

### 字符串类型

##### 剑指offer 05.替换空格

```C++
class Solution {
public:
    string replaceSpace(string s) {
        // return replace(s);
        replace1(s);
        return s;
    }
private:
    string replace(const string& s){
        string ret;
        for(auto &elem:s){
            if(elem == ' '){
                ret += "%20";
            }else{
                ret.append(1, elem);
            }
        }
        return ret;
    }

    void replace1(string &s){
        string str("%20");
        auto beg = s.begin();
        while(beg != s.end()){
            if(*beg == ' '){
                beg = s.erase(beg);
                beg = s.insert(beg, str.begin(), str.end());
                beg += 3;
                continue;
            }
            ++beg;
        }
    }
};
```

##### 剑指offer 58II 左旋转字符串

```C++
// 这类题，可以实现原地装换；反转3次；
class Solution {
public:
    string reverseLeftWords(string s, int n) {
        reverse(s, 0, s.size()-1);  // 1.整体翻转
        reverse(s, 0, s.size()-n-1); // 2. 前面size-n个字节翻转
        reverse(s, s.size()-n, s.size()-1); //3. 后面n个字节翻转
        return s;
    }
private:
    // 闭区间
    void reverse(string& s, int lidx, int ridx){
        while(lidx < ridx){
            swap(s[lidx++], s[ridx--]);
        }
    }
};
```

##### 剑指offer 20. 表示数值的字符串

```C++
// 屎山代码，就是要把各种情况都考虑清楚
class Solution {
public:
    bool isNumber(string s) {
        // 去除两端空格
        int lidx = 0, ridx = s.size()-1;
        while(lidx < s.size() && s[lidx] == ' ') ++lidx;
        while(ridx >=lidx && s[ridx] == ' ') --ridx;
        if(lidx > ridx){return false;}
        // 跳过首位+或者-
        if(s[lidx] == '+' || s[lidx] == '-') ++lidx;
        bool dflag = false; // 避免多个小数点
        if(lidx > ridx)
            return false;
        else if(s[lidx] == '.')
        {
            dflag = true;
            ++lidx;
        }
            
        
        if(lidx > ridx) return false;  
        else if(!isdigit(s[lidx]))
            return false;
        
        // 判断里面的数值
        bool eflag = false;
        for(int idx = lidx; idx <= ridx; ++idx){
            // 判断是字母但不是e
            if(isalpha(s[idx]) && tolower(s[idx]) != 'e')
                return false;
            // 空格也不行
            if(s[idx] == ' ')return false;

            if(tolower(s[idx]) == 'e'){
                if(eflag || idx == ridx){
                    return false;
                }else{
                    eflag =true;
                }
            } 
                    
            
            if(s[idx] == '.' && (!isdigit(s[idx-1]) || eflag || dflag)){
                return false;
            }else if(s[idx] == '.'){
                dflag = true;
            }


            if((s[idx] == '+' || s[idx] == '-') && (tolower(s[idx-1]) != 'e' || idx == ridx))
                return false;
        }
        return true;

    }

};
```

##### 剑指offer 67 字符串转换成整数

```C++
class Solution {
public:
    int strToInt(string str) {
        int lidx = 0;
        // 跳过前导空格
        while(str[lidx] == ' ') ++lidx;
        if(lidx >= str.size()) return 0;
        // 上述说明还有字符; 判断首位是否是字母
        if(isalpha(str[lidx])) return 0;
        // 判断是否是符号位
        int flag = 1;
        if(str[lidx] == '+' || str[lidx] == '-'){
            flag = (str[lidx] == '+' ? 1 : -1);
            ++lidx;
        }
        if(lidx >= str.size()) return 0;
        // 剩余部分区间有效
        int num = 0;
        for(int idx = lidx; idx < str.size(); ++idx){
            // s[idx] 不是数字的情况下;返回结果
            if(!isdigit(str[idx])){
                return num;
            }
            // 说明是数字
            int temp = str[idx] - '0';
            if(num > (INT_MAX - temp)/10) return INT_MAX; // 关键是溢出处理
            if(num < (INT_MIN + temp)/10) return INT_MIN;
            num = num * 10 + temp * flag;
        }
        return num;
    }
};
```

### 链表类型

##### 	06 从尾到头打印链表

```C++
// 递归，时间复杂度o(n); 空间复杂度: o(n) 
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(NULL) {}
 * };
 */
class Solution {
public:
    vector<int> reversePrint(ListNode* head) {
        // 递归
        vector<int> res;
        reverse(head, res);
        return res;
    }
private:
    void reverse(ListNode* curr, vector<int>& res){
        if(curr == NULL) return;
        reverse(curr->next, res);
        res.push_back(curr->val);
    }
};
```

##### 	24 反转链表

```C++
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(NULL) {}
 * };
 */
class Solution {
public:
    ListNode* reverseList(ListNode* head) {
        // 辅助头节点
        ListNode* pre = NULL;
        ListNode* curr = head;
        while(curr){
            ListNode* temp = curr;
            curr = curr->next;
            temp->next = pre;
            pre = temp;
        }
        return pre;
    }
    // 原地算法
    ListNode* reverseList(ListNode* head) {
        if(!head || head->next == NULL) return head;

        ListNode* tail = reverseList(head->next);
        head->next->next = head;
        head->next = NULL;
        return tail;
    }
};
```

##### 35 复杂链表的复制

```C++

/*
// Definition for a Node.
class Node {
public:
    int val;
    Node* next;
    Node* random;
    
    Node(int _val) {
        val = _val;
        next = NULL;
        random = NULL;
    }
};
*/
// 从走你的路；时间复杂度太高了。达到了O(n^2)
class Solution {
public:
    Node* copyRandomList(Node* head) {
        if(head == NULL) return NULL;
        Node* new_head = new Node(head->val);
        if(head->random == head){new_head->random=new_head;}
        Node* n_curr = new_head, *s_curr = head;
        while(s_curr->next){
            s_curr = s_curr->next;
            Node* tmp = new Node(s_curr->val);
            if(s_curr->random == s_curr){
                tmp->random = tmp;
            }else if(s_curr->random == NULL){
                tmp->random = NULL;
            }
            n_curr->next = tmp;
            n_curr = n_curr->next;
        }
        n_curr->next = NULL;

        // 随机连接值的判断
        n_curr = new_head, s_curr = head;
        while(s_curr){
            if(s_curr->random != s_curr && s_curr->random != NULL){
                Node* s_tmp = head;
                Node* d_tmp = new_head;
                while(s_tmp != s_curr->random){
                    s_tmp = s_tmp->next;
                    d_tmp = d_tmp->next;
                }
                n_curr->random = d_tmp;
            }
            n_curr = n_curr->next;
            s_curr = s_curr->next;
        }
        return new_head;
    }
};
// 利用哈希表记录源节点地址和拷贝节点地址之间的映射关系，实现random指向拷贝的O(1)
class Solution {
public:
    unordered_map<Node*, Node*> cachedNode;

    Node* copyRandomList(Node* head) {
        if (head == nullptr) {
            return nullptr;
        }
        if (!cachedNode.count(head)) {
            Node* headNew = new Node(head->val);
            cachedNode[head] = headNew; // 记录节点的创建关系;实现O(1)跳转
            headNew->next = copyRandomList(head->next);
            headNew->random = copyRandomList(head->random);
        }
        return cachedNode[head];
    }
};
// 等价方法
class Solution {
public:
    Node* copyRandomList(Node* head) {
        if(head == NULL) return NULL;
        unordered_map<Node*, Node*> listMap;
        Node* n_head = new Node(head->val);
        listMap[head] = n_head;
        Node* n_curr = n_head, *s_curr = head;
        while(s_curr->next){
            s_curr = s_curr->next;
            Node* tmp = new Node(s_curr->val);
            n_curr->next = tmp;
            n_curr = n_curr->next;
            listMap[s_curr] = tmp;
        }
        // 随机链
        n_curr = n_head, s_curr = head;
        while(s_curr){
            if(s_curr->random){
                n_curr->random = listMap[s_curr->random];
            }
            s_curr = s_curr->next;
            n_curr = n_curr->next;
        }

        return n_head;
    }
};
```

#### 双指针类型

##### 	删除链表结点

```C++
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(NULL) {}
 * };
 */
class Solution {
public:
    ListNode* deleteNode1(ListNode* head, int val) {
        if(head == NULL){return head;}
        if(head->val == val){return head->next;}  // 删除的不是头节点
        head->next = deleteNode(head->next, val); // 递归
        return head; 
    }
    ListNode* deleteNode(ListNode* head, int val){
        // 双指针
        ListNode* dummy = new ListNode(-1);
        ListNode* prev = dummy;
        prev->next = head;
        while(head){
            if(head->val == val){
                prev->next = head->next;
                break;
            }
            prev = head;
            head = head->next;
        }
        return dummy->next;
    }
};
```

##### 	22 输出第k个节点

```C++
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(NULL) {}
 * };
 */
class Solution {
public:
    ListNode* getKthFromEnd1(ListNode* head, int k) {
        if(head == NULL){return head;}
        getKthFromEnd(head->next, k); // 递归的方式
        ++count;
        if(count == k){
            retNode = head;
        }
        return retNode;
    }
    // 双指针
    ListNode* getKthFromEnd(ListNode* head, int k){
        if(head == NULL) return NULL;
        ListNode* slow = head, *fast = head;
        while(k-- && fast){
            fast = fast->next;
        }
        if(k > 0){return NULL;}

        while(fast){
            slow = slow->next;
            fast = fast->next;
        }
        return slow;
    }
private:
    int count = 0;
    ListNode* retNode = NULL;
};
```

##### 25 合并两个排序的链表

```C++
class Solution {
public:
    ListNode* mergeTwoLists1(ListNode* l1, ListNode* l2) {
        if(l1 == NULL){return l2;}
        if(l2 == NULL){return l1;}
        if(l1->val <= l2->val){
            l1->next = mergeTwoLists(l1->next, l2);
            return l1;
        }else{
            l2->next = mergeTwoLists(l1, l2->next);
            return l2;
        }
    }

    ListNode* mergeTwoLists(ListNode* l1, ListNode* l2) {
        if(l1 == NULL){return l2;}
        if(l2 == NULL){return l1;}

        ListNode* p1 = l1, *p2 = l2, *dummy = new ListNode(-1);
        ListNode* curr = dummy;
        while(p1 && p2){
            if(p1->val <= p2->val){
                curr->next = p1;
                curr = curr->next;
                p1 = p1->next;
            }else{
                curr->next = p2;
                curr = curr->next;
                p2 = p2->next;
            }
        }
        if(!p1){
            curr->next = p2;
        }
        if(!p2){
            curr->next = p1;
        }
        return dummy->next;
    }
};
```

##### 52 两个链表的第一个公共结点

```C++
 // 或者哈希
class Solution {
public:
    ListNode *getIntersectionNode1(ListNode *headA, ListNode *headB) {
        unordered_set<ListNode*> upath;
        ListNode* curr = headA;
        while(curr){
            upath.insert(curr);
            curr = curr->next;
        }
        // 我试试
        curr = headB;
        while(curr){
            if(upath.count(curr)){
                return curr;
            }
            curr = curr->next;
        }
        return NULL;
    }
    // 方法2, 相遇总是在同一点，重走你的路
    ListNode *getIntersectionNode(ListNode *headA, ListNode *headB){
        if(!headA || !headB) {return NULL;}
        ListNode* currA = headA, *currB = headB;
        while(currA != currB){
            currA = currA->next;
            currB = currB->next;
            if(!currA && !currB){return NULL;}
            else if(!currA){currA = headB;}
            else if(!currB){currB = headA;}
        }
        return currA;
    }
};
```

##### 调整数组顺序使奇数位于偶数前面

```C++
class Solution {
public:
    vector<int> exchange1(vector<int>& nums) {
        // 基本有序？ 快排思想？
        int slow = 0, fast = 0;
        while(fast < nums.size()){
            // 寻找第一个偶数的地方
            while(slow < nums.size() && nums[slow] % 2 == 1)
                ++slow;
            
            fast = slow + 1;
            // 寻找第一个奇数的地方
            while(fast < nums.size() && nums[fast] % 2 == 0)
                ++fast;
            if(fast < nums.size())
                swap(nums[slow], nums[fast]);
        }
        return nums;
    }

    vector<int> exchange(vector<int>& nums){
        int lidx = 0, ridx = nums.size()-1;
        while(lidx < ridx){
            // 左侧寻找第一个为偶数的
            while(lidx < ridx  && nums[lidx] % 2 == 1)
                ++lidx;
            // 右侧寻找第一个为奇数的
            while(ridx > lidx &&nums[ridx] % 2 == 0)
                --ridx;
            
            swap(nums[lidx], nums[ridx]);
        }
        return nums;
    }
};
```

##### 57 和为s的两个数字之和

```C++
class Solution {
public:
    // 哈希
    vector<int> twoSum1(vector<int>& nums, int target) {
        unordered_set<int> rest;
        for(int i=0; i<nums.size(); ++i){
            if(rest.count(nums[i])){
                return {nums[i], target - nums[i]};
            }else{
                rest.insert(target - nums[i]); // 期望后面出现的数字
            }
        }
        return {};
    }
    vector<int> twoSum(vector<int>& nums, int target){
        // 题目说了是有序的
        int lidx = 0, ridx = nums.size()-1;
        while(lidx < ridx){
            if(nums[lidx] + nums[ridx] == target)
                return {nums[lidx], nums[ridx]};
            else if(nums[lidx] + nums[ridx] < target)
                ++lidx;
            else --ridx;
        }
        return;
    }
};
```

##### 58 翻转单词顺序

```C++
class Solution {
public:
    string reverseWords(string s) {
        reverse(s, 0, s.size() - 1);
        string ret;
        for(int idx = 0; idx < s.size(); ++idx){
            if(s[idx] == ' ') continue;
            int _lidx = idx;
            while(idx < s.size() && s[idx] != ' ')
                ++idx;
            reverse(s, _lidx, idx - 1);
            ret += s.substr(_lidx, idx - _lidx) + " ";
        }
        if(!ret.empty() && ret[ret.size()-1] == ' '){
            return ret.substr(0, ret.size()-1);
        }
        return ret;
    }
private:
    void reverse(string& str, int lidx, int ridx){
        while(lidx < ridx){
            swap(str[lidx++], str[ridx--]);
        }
    }
};
```

### 栈与队列

##### 09用两个栈实现队列

```C++
class CQueue {
public:
    CQueue() {

    }
    
    void appendTail(int value) {
        stk1.push(value);
    }
    
    int deleteHead() {
        if(stk2.empty()){
            pourInto();
        }
        if(stk2.empty()) return -1;
        int tmp = stk2.top();
        stk2.pop();
        return tmp;
    }
private:
    void pourInto(){
        while(!stk1.empty()){
            stk2.push(stk1.top());
            stk1.pop();
        }
    }
private:
    stack<int> stk1; // 进
    stack<int> stk2; // 出
};
```

##### 30 包含min函数的栈

​	<font color="red">同理可以演变出最大栈, 甚至是滑动窗口大小类型</font>

```C++
class MinStack {
public:
    /** initialize your data structure here. */
    MinStack() {

    }
    
    void push(int x) {
        m_stk.push(x);
        if(m_min.empty() || m_min.top() >= x){
            m_min.push(x);
        }
    }
    
    void pop() {
        if(!m_stk.empty()){
            if(m_stk.top() == m_min.top())
                m_min.pop();
            m_stk.pop();
        }
    }
    
    int top() {
        return m_stk.top();
    }
    
    int min() {
        return m_min.top();
    }
private:
    stack<int> m_stk, m_min;
};
```

##### 59 滑动窗口最大值

​	<font color="blue">维护双端优先队列思想</font>

```C++
class Solution {
public:
    vector<int> maxSlidingWindow(vector<int>& nums, int k) {
        vector<int> res;
        deque<int> slideWind; // 首元素存放窗口内可能出现的最大，递减队列
        for(int i=0; i<k; ++i){
            if(slideWind.empty()){
                slideWind.push_back(nums[i]);
                continue;
            }

            while(!slideWind.empty() && slideWind.back() < nums[i])
                slideWind.pop_back();
            slideWind.push_back(nums[i]);
        }
        res.push_back(slideWind.front());
        for(int i=k; i<nums.size(); ++i){
            if(nums[i-k] == slideWind.front()){
                slideWind.pop_front();
            }
            while(!slideWind.empty() && slideWind.back() < nums[i])
                slideWind.pop_back();
            slideWind.push_back(nums[i]);
            res.push_back(slideWind.front());
        }
        return res;
    }
};
```

##### 剑指 Offer 59 - II. 队列的最大值

```C++
class MaxQueue {
public:
    MaxQueue() {
    }
    
    int max_value() {
        if(m_que.empty())
            return -1;
        return m_min.front();
    }
    
    void push_back(int value) {
        while(!m_min.empty() && m_min.back() < value){
            m_min.pop_back();
        }
        m_que.push_back(value);
        m_min.push_back(value);
    }
    
    int pop_front() {
        if(m_que.empty())
            return -1;
        int ans = m_que.front();
        if(m_min.front() == ans){
            m_min.pop_front();
        }   
        m_que.pop_front();
        return ans;
    }
private:
    list<int> m_que;
    list<int> m_min;
};

```



### // 模拟类型

##### 剑指 Offer 29. 顺时针打印矩阵

```C++
class Solution {
public:
    vector<int> spiralOrder(vector<vector<int>>& matrix) {
        vector <int> res;
        if(matrix.empty()) return res;
        int rl = 0, rh = matrix.size()-1; //记录待打印的矩阵上下边缘
        int cl = 0, ch = matrix[0].size()-1; //记录待打印的矩阵左右边缘
        while(1){
            for(int i=cl; i<=ch; i++) res.push_back(matrix[rl][i]);//从左往右
            if(++rl > rh) break; //若超出边界，退出
            for(int i=rl; i<=rh; i++) res.push_back(matrix[i][ch]);//从上往下
            if(--ch < cl) break;
            for(int i=ch; i>=cl; i--) res.push_back(matrix[rh][i]);//从右往左
            if(--rh < rl) break;
            for(int i=rh; i>=rl; i--) res.push_back(matrix[i][cl]);//从下往上
            if(++cl > ch) break;
        }
        return res;
    }
};
```

##### 剑指 Offer 31. 栈的压入、弹出序列

```C++
// 模拟一遍栈，反正一直压入，直到等于第一个弹出的
class Solution {
public:
    bool validateStackSequences(vector<int>& pushed, vector<int>& popped) {
        int idx = 0;
        for(auto & elem : pushed){
            if(elem != popped[idx]){
                pstk.push(elem);
                continue;
            }
            ++idx;
            while(!pstk.empty() && popped[idx] == pstk.top()){
                ++idx;
                pstk.pop();
            }
        }
        return pstk.empty();
    }

private:
    stack<int> pstk;
};
```



### 查找算法

##### 剑指 Offer 03. 数组中重复的数字

```C++
class Solution {
public:
    // 哈希
    int findRepeatNumber(vector<int>& nums) {
        int state[100000] = {0};
        for(auto & elem : nums){
            if(state[elem])
                return elem;
            else 
                state[elem] = 1;
        }
        return -1;
    }
};
```

##### 剑指 Offer 53 - I. 在排序数组中查找数字 I

```C++
class Solution {
public:
    int search(vector<int>& nums, int target) {
        int LIndex = minIndex(nums, target, 0, nums.size()-1);
        int RIndex = maxIndex(nums, target, LIndex + 1, nums.size()-1);
        if(LIndex == RIndex){return 0;}
        return RIndex - LIndex - 1;
    }
private:
    int minIndex(const vector<int>& nums, int target, int left, int right){
        // 闭区间，有序[nums[left]... nums[right]]
        while(left <= right){
            int mid = left + (right - left) / 2;
            if(nums[mid] >= target){
                right = mid - 1;
            }else{
                left = mid + 1;
            }
        }
        return right;
    }

    int maxIndex(const vector<int>& nums, int target, int left, int right){
        // 闭区间，有序[nums[left]... nums[right]]
        while(left <= right){
            int mid = left + (right - left) / 2;
            if(nums[mid] <= target){
                left = mid + 1;
            }else{
                right = mid - 1;
            }
        }
        return left;
    }
};
```

##### 剑指 Offer 53 - II. 0～n-1中缺失的数字

```C++
class Solution {
public:
    int missingNumber(vector<int>& nums) {
        if(nums.back() != nums.size())
            return nums.size();
        int lidx = 0, ridx = nums.size() - 1;
        while(lidx <= ridx){
            int midx = lidx + ((ridx - lidx) >> 1);
            if(nums[midx] == midx)
                lidx = midx + 1;
            else
                ridx = midx - 1;
        }
        return ridx + 1;
    }
};
```

##### 04 二维数组中查找数字

​	可以先二维搜索哪些行和列将target夹住了。

```C++
class Solution {
public:
    /**
     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可
     *
     * 
     * @param target int整型 
     * @param array int整型vector<vector<>> 
     * @return bool布尔型
     */
    bool Find(int target, vector<vector<int> >& array) {
        // write code here
        if(array.empty() || array[0].empty())
            return false;
        int rows = array.size();
        int cols = array[0].size();
        for(int i=0; i<rows; ++i){
            if(bs(array[i], target, 0, cols - 1))
                return true;
        }
        return false;         
    }

private:
    bool bs(vector<int>& nums, int target, int cleft, int cright){
        while(cleft <= cright){
            int mid = cleft + ((cright - cleft) >> 1);
            if(nums[mid] == target)
                return true;
            else if(nums[mid] > target)
                cright = mid - 1;
            else
                cleft = mid + 1;
        }
        return false;
    }
};
// 方法2可以采取从左下角开始搜索的方式 O(log(n+m))
```

##### 05 旋转数组的最小数字

<img src="I:\U盘内容\Primer\数据结构与算法\代码随想录\pic\image-20230802214031363.png" alt="image-20230802214031363" style="zoom:50%;" />

```C++
class Solution {
public:
    /**
     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可
     *
     * 这个最小值出现在nums[idx] > nums[idx+1]条件发生; nums[idx+1]为最小值
     * @param nums int整型vector 
     * @return int整型
     */
    int minNumberInRotateArray(vector<int>& nums) {
        // write code here
        if(nums.size() == 1)
            return nums[0];
        int left = 0, right = nums.size() - 1;  // 闭区间
        while(left < right){
            int mid = left + ((right - left) >> 1);
            if(nums[mid] > nums[mid + 1])
                return nums[mid + 1];
            else if(nums[mid] > nums[right]){
                left = mid + 1;
            }else if(nums[mid] == nums[right]){
                --right;
            }else{
                right = mid;
            }
        }
        return nums[left];
    }
private:
    int min(int a, int b){
        return a > b ? b : a;
    }
};
```

##### 06 第一个只出现一次的字符

```C++
class Solution {
public:
    /**
     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可
     *
     * 
     * @param str string字符串 
     * @return int整型
     */
    int FirstNotRepeatingChar(string str) {
        // write code here
        int state[58] = {0}; // 包括大小写问题
        for(auto &elem:str){
            ++state[elem - 'A'];
        }
        for(int i=0; i<str.size(); ++i){
            if(state[str[i] - 'A'] == 1){
                return i;
            }
        }
        return -1;
    }
};
```

### 搜索与回溯算法

##### 26 树的子结构

```C++
// 通过递归方式判断，比较简单。分多种情况
/*
struct TreeNode {
	int val;
	struct TreeNode *left;
	struct TreeNode *right;
	TreeNode(int x) :
			val(x), left(NULL), right(NULL) {
	}
};*/
class Solution {
public:
    bool HasSubtree(TreeNode* pRoot1, TreeNode* pRoot2) {
		if(pRoot1==NULL || pRoot2==NULL)
			return false;
		if(pRoot1->val == pRoot2->val && pRoot2->left==NULL && pRoot2->right==NULL)
			return true;
		if(pRoot1->val == pRoot2->val && pRoot2->left==NULL && pRoot2->right != NULL && HasSubtree(pRoot1->right, pRoot2->right))
			return true;
		else if(pRoot1->val == pRoot2->val && pRoot2->left!=NULL && pRoot2->right == NULL && HasSubtree(pRoot1->left, pRoot2->left))
			return true;	
		else if(pRoot1->val == pRoot2->val && HasSubtree(pRoot1->left, pRoot2->left) && HasSubtree(pRoot1->right, pRoot2->right))
			return true;
		return HasSubtree(pRoot1->left, pRoot2) || HasSubtree(pRoot1->right, pRoot2);
    }
};
```

##### 27.二叉树的镜像

```C++
// 采用后序遍历，左右中
class Solution {
public:
    TreeNode* mirrorTree(TreeNode* root) {
        if(!root){
            return root;
        }
        mirrorTree(root->left);
        mirrorTree(root->right);
        swap(root->left, root->right);
        return root;
    }
};
```

##### 28.二叉树的对称判断

```C++
class Solution {
public:
    /**
     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可
     *
     * 
     * @param pRoot TreeNode类 
     * @return bool布尔型
     */
    bool isSymmetrical(TreeNode* pRoot) {
        if(!pRoot){
            return true;
        }
        return helper(pRoot->left, pRoot->right);
    }

private:
    bool helper(TreeNode* lhs, TreeNode* rhs){
        if(!lhs && !rhs){  // 边界条件考虑清楚
            return true;
        }else if(!lhs || !rhs){
            return false;
        }

        if(lhs->val == rhs->val){
            return helper(lhs->left, rhs->right) && helper(lhs->right, rhs->left);
        }else{
            return false;
        }

    }
};
```

##### 12矩阵中的路径

```C++
class Solution {
public:
    /**
     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可
     *
     * 
     * @param matrix char字符型vector<vector<>> 
     * @param word string字符串 
     * @return bool布尔型
     */
    bool hasPath(vector<vector<char> >& matrix, string word) {
        if(matrix.size() * matrix[0].size() < word.size()){
            return false;
        }
        // write code here
        int m = matrix.size();
        int n = matrix[0].size();
        vector<vector<bool>> state(m, vector<bool>(n, false));
        string path;
        for(int ridx = 0; ridx < matrix.size(); ++ridx){
            for(int cidx = 0; cidx < matrix[0].size(); ++cidx){
                if(matrix[ridx][cidx] == word[0] && helper(matrix, state, path, word, ridx, cidx)) // 寻找合适的起始位置
                    return true;
            }
        }
        return false;
    }
private:
    bool helper(vector<vector<char> >& matrix, vector<vector<bool> >& state, string& path, string& word, int ridx, int cidx){
        if(path.size() == word.size()){
            return path == word;
        }
        // 判断边界、判断该位置是否已被选，如果被选了，说明不通
        if(ridx < 0 || ridx >= matrix.size() || cidx < 0 || cidx >= matrix[0].size() || state[ridx][cidx]){
            return false;
        }
        state[ridx][cidx] = true;
        // path.append(1, matrix[ridx][cidx]);
        path.push_back(matrix[ridx][cidx]);
        // dfs
        bool lret = helper(matrix, state, path, word, ridx - 1, cidx);
        bool rret = helper(matrix, state, path, word, ridx + 1, cidx);
        bool uret = helper(matrix, state, path, word, ridx, cidx - 1);
        bool dret = helper(matrix, state, path, word, ridx, cidx + 1);
        state[ridx][cidx] = false;
        path.pop_back();
        return lret || rret || uret || dret;
    }
};
```

##### 13 机器人的运动范围

```C++
class Solution {
public:
    int movingCount(int threshold, int rows, int cols) {
        if(threshold == 0)
            return 1;
        vector<vector<bool>> state(rows, vector<bool>(cols, false));
        int count = 0;
        helper(threshold, state, count, 0, 0);
        return count;
    }
private:
    void helper(int& threshold, vector<vector<bool>>& state, int& count, int ridx, int cidx){
        if(ridx < 0 || ridx >= state.size() || cidx < 0 || cidx >= state[0].size() || state[ridx][cidx]){
            return;
        }
        if(Islegal(threshold, ridx, cidx)){
            ++count;
            state[ridx][cidx] = true;
            helper(threshold, state, count, ridx - 1, cidx);
            helper(threshold, state, count, ridx + 1, cidx);
            helper(threshold, state, count, ridx, cidx + 1);
            helper(threshold, state, count, ridx, cidx - 1);
        }else{
            state[ridx][cidx] = true;
        }
    }

    bool Islegal(int& threshold, int ridx, int cidx){
        int sum = 0;
        while(ridx){
            sum += (ridx % 10);
            ridx /= 10;
        }
        while(cidx){
            sum += (cidx % 10);
            cidx /= 10;
        }
        return sum <= threshold;
    }
};
```

##### 34 二叉树中和为某一值的路径

```C++
// 前序搜索，可以看作是回溯的方法
/**
 * struct TreeNode {
 *	int val;
 *	struct TreeNode *left;
 *	struct TreeNode *right;
 *	TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 * };
 */
class Solution {
public:
    /**
     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可
     *
     * 
     * @param root TreeNode类 
     * @param target int整型 
     * @return int整型vector<vector<>>
     */
    vector<vector<int> > FindPath(TreeNode* root, int target) {
        vector<vector<int>> ans;
        vector<int> path;
        if(!root) return ans;
        int sum = root->val;
        path.push_back(root->val);
        dfs(root, ans, path, target, sum);
        return ans;
    }

private:
    void dfs(TreeNode* root, vector<vector<int>>& ans, vector<int>& path, int& target, int& sum){
        if(!root->left && !root->right){
            if(sum == target){
                ans.push_back(path);
            }
            return;
        }

        if(root->left){
            sum += root->left->val;
            path.push_back(root->left->val);
            dfs(root->left, ans, path, target, sum);
            sum -= root->left->val;
            path.pop_back();
        }
        if(root->right){
            sum += root->right->val;
            path.push_back(root->right->val);
            dfs(root->right, ans, path, target, sum);
            sum -= root->right->val;
            path.pop_back();
        }
    }
};
```

##### 36 二叉搜索树与双向链表

```C++
class Solution {
public:
	TreeNode* head = NULL;
	TreeNode* pre = NULL;
    TreeNode* Convert(TreeNode* pRootOfTree) {
		if(pRootOfTree == NULL)
			return pRootOfTree;
		Convert(pRootOfTree->left);
		if(pre == NULL){
			head = pRootOfTree;
			pre = pRootOfTree;
		}else{
			pre->right = pRootOfTree;
			pRootOfTree->left = pre;
			pre = pRootOfTree;
		}
		Convert(pRootOfTree->right);
		return head;
    }
};
```

##### 54 二叉搜索树的第k个节点

```C++
// 中序遍历
class Solution {
public:
    /**
     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可
     *
     * 
     * @param proot TreeNode类 
     * @param k int整型 
     * @return int整型
     */
    int ret = -1, cnt = 0;
    int KthNode(TreeNode* proot, int k) {
        // write code here
        if(!proot){return -1;}
        KthNode(proot->left, k);
        ++cnt;
        if(cnt == k){
            ret = proot->val;
        }
        KthNode(proot->right, k);
        return ret;
    }
};
```

##### 55 树的深度

```C++
// 后序遍历
class Solution {
public:
    int TreeDepth(TreeNode* pRoot) {
		// 后序遍历
		if(!pRoot){return 0;}
		int left = TreeDepth(pRoot->left);
		int right = TreeDepth(pRoot->right);
		return max(left, right) + 1;
    }
};

```

##### 64求1+2+3+...+n

​	题目的主要信息：

- 计算1+2+3+...+*n*
- 不能使用乘除法、for、while、if、else、switch、case等关键字及条件判断语句（A?B:C）

```C++
// 1.直接公式法； 不符合题意
class Solution {
public:
    int Sum_Solution(int n) {
        n && (n += Sum_Solution(n-1)); // 短路效应
        return n;
    }
};

// 利用静态变量和构造函数
class A{
    public:
    A(){++N;sum+=N;}
    static void Reset(){N=0;sum=0;}
    static int N;
    static int sum;
};
int A::N=0;
int A::sum=0;
class Solution {
public:
    int Sum_Solution(int n) {
       A::Reset();
       A *a=new A[n];
        delete []a;//防止内存泄漏
        a=nullptr;//防止悬空指针
       return A::sum;
    }
};
```

##### 68二叉搜索树最近公共祖先

```C++
// 也可以推广到一半的二叉树公共祖先求解
class Solution {
public:
    /**
     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可
     *
     * 
     * @param root TreeNode类 
     * @param p int整型 
     * @param q int整型 
     * @return int整型
     */
    int lowestCommonAncestor(TreeNode* root, int p, int q) {
        // 中序遍历
        if(root->val == p)
            return p;
        if(root->val == q)
            return q;
        if((root->val < p && root->val > q) ||  (root->val > p && root->val < q)) // 不同侧
            return root->val;
        // 同侧
        if(root->val < p)
            return lowestCommonAncestor(root->right, p, q);
        else
            return lowestCommonAncestor(root->left, p, q);
    }
};
```

##### 68 二叉数的公共祖先

```C++
// 递归
class Solution {
public:
    /**
     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可
     *
     * 
     * @param root TreeNode类 
     * @param o1 int整型 
     * @param o2 int整型 
     * @return int整型
     */
    int lowestCommonAncestor(TreeNode* root, int o1, int o2) {
        IsInclude(root, o1, o2);
        return ret;
    }

private:
    int ret = -1;
    bool IsInclude(TreeNode* root, int o1, int o2){
        // 后序遍历
        if(!root){
            return false; // 叶子结点返回false
        }
        if(root->val == o1 || root->val == o2){
            ret = root->val; // 同侧情况下，一定是根节点先访问
            return true;
        }
        int lret = IsInclude(root->left, o1, o2);
        int rret = IsInclude(root->right, o1, o2);
        if(lret && rret){
            ret = root->val; // 解决不同侧情况
        }
        return lret || rret;
    }
};
// 简洁写法
TreeNode* IsInclude(TreeNode* root, int o1, int o2){
    if(!root) return nullptr;
    if(root->val == o1 || root->val == o2)
        return root;
    TreeNode* left = IsInclude(root->left, o1, o2);
    TreeNode* right = IsInclude(root->right, o1, o2);
    if(!left) return right;
    if(!right) return left;
    return root;
}
// 也可以转化成路径思想
```

##### 37 序列化二叉树

```C++
class Solution {
  public:
    char* Serialize(TreeNode* root) {
        if (root == NULL)
            return "#";
        string res;
        SerializeFunction(root, res); // 前序遍历的字符数组
        char* charRes = new char[res.size() + 1];
        strcpy(charRes, res.c_str());
        return charRes;
    }
    TreeNode* Deserialize(char* str) {
        if (str == "#")
            return NULL;
        TreeNode* res = DeserializeFunction(&str);
        return res;
    }


  private:
    void SerializeFunction(TreeNode* root, string& str) {
        if (root == NULL) {
            str += '#';
            return;
        }
        // 根节点
        string temp = to_string(root->val);
        str += temp + '!'; // '!'分割元素
        // 左子树
        SerializeFunction(root->left, str); // 中序遍历
        SerializeFunction(root->right, str);
    }

    TreeNode* DeserializeFunction(char** str) {
        if (**str == '#') { // 到达叶子结点
            (*str)++;
            return NULL;
        }
        // 数字转换
        int val = 0;
        while (**str != '!' &&** str != '\0') {
            val = val * 10 + ((**str) - '0');
            (*str)++;
        }
        TreeNode* root = new TreeNode(val);
        if (**str == '\0')
            return root;
        else
            (*str)++;
        // 反序列化与序列化一致，都是前序
        root->left = DeserializeFunction(str);
        root->right = DeserializeFunction(str);
        return root;
    }
};
```

##### 38字符的排列：注意去重

```C++
class Solution {
public:
    /**
     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可
     *
     * 
     * @param str string字符串 
     * @return string字符串vector
     */
    vector<string> Permutation(string str) {
        vector<string> res;
        string path;
        vector<bool> state(str.size(), false);
        sort(str.begin(), str.end());
        backTracking(str, res, state, path);
        return res;
    }

private:
    void backTracking(string&str, vector<string>& res, vector<bool>& state,  string& path){
        if(path.size() == str.size()){
            res.push_back(path);
            return;
        }

        for(int idx = 0; idx < str.size(); ++idx){
            if(state[idx]==false){
                path += str[idx];
                state[idx] = true;
                backTracking(str, res, state, path);
                state[idx] = false;
                while(idx + 1 < str.size() && str[idx+1] == path.back()) // 去重
                    ++idx;
                path.pop_back();
            }
        }
    }
};
```

### 分治算法

##### 16数值的整数次方

```C++
class Solution {
public:
    double Power(double base, int exponent) {
        if(base == 0 || exponent == 0)
            return exponent == 0;
        int flag = 1;
        if(exponent < 0){
            flag = -1;
            exponent = -exponent;
        }
        double sum = 1.;
        for(int i=0; i<exponent; ++i){
            sum *= base;
        }
        return (flag == -1) ? 1/sum : sum;

    }
};
// 方法2：快速幂法，将幂exponent分解成二进制，累乘
```

##### 33 BST的后序遍历序列

​	判断一个数组是不是一个BST的后序遍历结果

```C++
class Solution {
public:
    bool VerifySquenceOfBST(vector<int> sequence) {
        if(sequence.empty()) return false; // 细节
        return IsBST(sequence, 0, sequence.size() - 1);
    }
private:
    bool IsBST(vector<int>& sequence, int lidx, int ridx){
        if(lidx >= ridx){
            return true; // 一个结点的数可以认为是BST; 条件的>=的选择
        }
        int rootVal = sequence[ridx];
        int rSubIdx = ridx; // 左右子树分界线; 右子树的索引初始为根节点; 为什么要是根节点
        for(int idx = lidx; idx < ridx; ++idx){
            if(sequence[rSubIdx] < sequence[idx]){
                rSubIdx = idx;
                break;  // 注意后序遍历的特点；寻找到第一个大于medium的值
            }
        }
        // 左子树全部小于rootVal
        for(int idx = lidx; idx < rSubIdx; ++idx){
            if(sequence[idx] >= rootVal)
                return false;
        }
        for(int idx = rSubIdx; idx < ridx; ++idx){
            if(sequence[idx] <= rootVal)
                return false;
        }
        return IsBST(sequence, lidx, rSubIdx - 1) && IsBST(sequence, rSubIdx, ridx - 1);
    }
};
```

##### 17打印1到最大n位数的整数

```C++
#include <cmath>
class Solution {
public:
    /**
     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可
     *
     * 
     * @param n int整型 最大位数
     * @return int整型vector
     */
    vector<int> printNumbers(int n) {
        int maxValue = pow(10, n);  // 选择cmath库函数，也可以自己
        vector<int> ans;
        for(int i=1; i < maxValue; ++i){
            ans.emplace_back(i);
        }
        return ans;
    }
};
```

##### 51 计算数组逆序对

​	在归并的过程中计算逆序对的数量

```C++
class Solution {
public:
    /**
     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可
     *
     * 
     * @param nums int整型vector 
     * @return int整型
     */
    using ll = long long;
    int InversePairs(vector<int>& nums) {
        ll count = 0;
        vector<int> aux(nums.size(), 0);
        mSort(nums, aux, count, 0, nums.size()-1);
        return count % 1000000007;
    }

private:
    void mSort(vector<int>& nums, vector<int>& aux, ll& count, int left, int right){
        if(left == right){
            return;
        }
        int mid = left + (right - left) / 2;
        mSort(nums, aux, count, left, mid);
        mSort(nums, aux, count, mid + 1, right);
        merge(nums, aux, count, left, mid, right);

    }

    void merge(vector<int>& nums, vector<int>& aux, ll& count, int lidx, int mid, int ridx){
        for(int idx = lidx; idx <= ridx; ++idx){
            aux[idx] = nums[idx];
        }

        int left = lidx, right = mid + 1, idx = lidx;
        while(idx <= ridx){
            if(left > mid){
                nums[idx++] = aux[right++];
            }else if(right > ridx){
                nums[idx++] = aux[left++];
            }else if(aux[left] <= aux[right]){
                nums[idx++] = aux[left++];
            }else{
                count += (mid - left + 1);
                nums[idx++] = aux[right++];
            }
        }
    }
};
```

### 排序

##### 45把数组排序成最小的数字

```C++
class Solution {
public:
    /**
     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可
     *
     * 
     * @param numbers int整型vector 
     * @return string字符串
     */
    string PrintMinNumber(vector<int>& numbers) {
        if(numbers.empty())return "";
        vector<string> str;
        for(int i=0; i<numbers.size(); ++i){
            // if(numbers[i] != 0)  // 如果需要去除前导的话加上
            str.push_back(to_string(numbers[i]));
        }
        // 逐位比较; 小数字在前; 子集问题考虑，前拼接和后拼接大小关系
        sort(str.begin(), str.end(), comp); 
        string res;
        for(int i = 0; i<str.size(); ++i){
            res += str[i];
        }
        return res;

    }
private:
    static bool comp(const string& lhs, const string& rhs){
        int lidx = 0, ridx = 0;
        while(lidx < lhs.size() && ridx < rhs.size()){
            if(lhs[lidx] < rhs[lidx]){
                return true;
            }else if(lhs[lidx] == rhs[ridx]){
                ++lidx, ++ridx;
            }else{
                return false;
            }
        }
        // 子集关系情况下的考虑
        if(lidx == lhs.size()){
            string tmp = rhs.substr(ridx, rhs.size() - ridx);
            tmp += lhs;
            return rhs < tmp;
        }else{
            string tmp = lhs.substr(lidx, lhs.size() - lidx);
            tmp += rhs;
            return lhs > tmp;
        }
    }
    // 之前的判断函数复杂化了
    static bool comp2(string& lhs, string& rhs){
        return lhs + rhs < rhs + lhs;
    }
};

```

##### 61 扑克牌中的数字

```C++
class Solution {
public:
    /**
     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可
     *
     * 
     * @param numbers int整型vector 
     * @return bool布尔型
     */
    bool IsContinuous(vector<int>& numbers) {
        // write code here
        sort(numbers.begin(), numbers.end());
        int zero_count = 0;
        int idx = 0;
        while(numbers[idx] == 0){
            ++idx;
            ++zero_count;
        } 
        if(zero_count == 4)
            return true;
        bool flagA = false;
        for(int i = idx + 1; i < numbers.size(); ++i){
            if(numbers[i] == numbers[i-1]){
                return false;
            }else if((numbers[i] - numbers[i-1]) == 1){
                continue;
            }else if(zero_count < (numbers[i] - numbers[i-1] - 1)){
                return false;
            }else{
                zero_count -= (numbers[i] - numbers[i-1] - 1);
            }
        }
        return true;   
    }
};
```

##### 40最小的k个数

```C++
#include <vector>
class Solution {
public:
    /**
     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可
     *
     * 
     * @param input int整型vector 
     * @param k int整型 
     * @return int整型vector
     */
    vector<int> GetLeastNumbers_Solution(vector<int>& input, int k) {
        if(k == 0){return {};}
        for(int i=0; i<input.size(); ++i){
            if(pq.size() < k){
                 pq.push(input[i]);
                 continue;
            }else if(pq.size() ==k && pq.top() > input[i]){
                pq.pop();
                pq.push(input[i]);
            }
        }

        // 取出k个数字
        vector<int> res;
        while(k--){
            res.push_back(pq.top());
            pq.pop();
        }
        return res;
    }
	// 也可以使用快排算法，每快排一次，可以统计一次少于pivot的值
    vector<int> GetLeastNumbers_Solution(vector<int>& input, int k){
        vector<int> ret;
        if(k == 0 || k > input.size())
            return ret;
        int l = 0, r = input.size();
        while(l < r){
            int p = partition(input, l ,r);
            if(p + 1 == k)
                return vector<int>(input.begin(), input.begin() + k);
            else if( p + 1 < k){
                l = p + 1;
            }else{
                r = p;
            }
        }
        return ret;
    }
    
private:
    priority_queue<int> pq;
    int partition(vector<int>& input, int l, int r){
        // 传入左闭右开
        int pivot = input[r-1]; 
        int i = l;
        for(int j=l; j<r-1; ++j){
            if(input[j] < pivot){
                swap(input[i++], input[j]);
            }
        }
        swap(input[i], input[r-1]);
        return i; // 小于pivot的值
    }
};
```

##### 	41数据流中的中位数

​		暴力解法

```C++
class Solution {
public:
    void Insert(int num) {
        if(vec.empty() || num >= vec.back()){
            vec.push_back(num);
        }else{
            vec.push_back(num);
            sort(vec.begin(), vec.end());
        }
        
        
    }

    double GetMedian() { 
        if(vec.size() % 2 == 0)
            return (double)(vec[vec.size() / 2] + vec[vec.size() / 2 -1]) / 2;
        return vec[vec.size() / 2];
    }
private:
    vector<int> vec;
};
```

```C++
// 维护两个堆； 在有序数组中求中位数,可以将数组分为 len1:[0, mid), mid, len2:[mid + 1, right) 三部分
/* mid可以随意放入左数组或右数组(假设放在右边)
两个数组的长度差值不超过1;--->需要平衡
case1: len1 = len2;--->左出最大 + 右出最小 / 2
case2: len1 > len2; --->左出最大
case3: len1 < len2; ---->右出
// case2 和 3 可以让len2 >= len1; 合并在
*/
class Solution {
public:
    #define SCD static_cast<double>
    priority_queue<int> min_q; // 大顶推
    priority_queue<int, vector<int>, greater<int>> max_q; // 小顶堆

    void Insert(int num)
    {

        min_q.push(num); // 试图加入到大顶推

        // 平衡一个两个堆
        max_q.push(min_q.top()); 
        min_q.pop();

        if (min_q.size() < max_q.size()){
            min_q.push(max_q.top());
            max_q.pop();
        }
    }
    
    double GetMedian()
    { 
        return min_q.size() > max_q.size() ? SCD(min_q.top()) : SCD(min_q.top() + max_q.top()) / 2;
    }

};
```

### 动态规划题目

##### 10-II 青蛙跳台阶问题

```C++
class Solution {
public:
    /**
     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可
     *
     * 
     * @param number int整型 
     * @return int整型
     */
    // 公式dp[n] = dp[n-1] + dp[n-2]
    int jumpFloor(int number) {
        if(number < 2)
            return 1;
        int dp0 = 1, dp1 = 1, dp = -1;
        for(int i=2; i<=number; ++i){
            dp = dp0 + dp1;
            dp0 = dp1;
            dp1 = dp;
        }
        return dp;
    }
};
```

<font color="blue">// 扩展：一次最多跳n个台阶 </font>:关键是知道递推公式：dp[n] = dp[n-1] + dp[n-2] + ... + dp[0]; dp[0] = dp[1] = 1;

```C++
int jumpFloorII(int number) {
    // write code here
    if(number < 2)
    return 1;
    vector<int> dp(number + 1, 0);
    dp[0] = dp[1] = 1;
    for(int i=2; i<=number; ++i){
    for(int j=0; j<i; ++j){
    dp[i] += dp[j];
    }
    }
    return dp[number];
}
```

##### 63 股票最大利润

```C++
// DP和贪心都可以
class Solution {
public:
    /**
     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可
     *
     * 
     * @param prices int整型vector 
     * @return int整型
     */
    // DP
    int maxProfit1(vector<int>& prices) {
        if(prices.empty())
            return 0;
        int dp[2]; // dp[0]: 表示持有股票; dp[1]表示不持有股票
        dp[0] = -prices[0];
        for(int i=1; i<prices.size(); ++i){
            dp[1] = max(dp[1], dp[0] + prices[i]); // 先算不持有股票，脏数据问题
            dp[0] = max(dp[0], -prices[i]); // 因为只能买一次
        }
        return dp[1];
    }

    // 贪心
    int maxProfit(vector<int>& prices){
        if(prices.empty())
            return 0;
        int Min = prices[0];
        int profit = 0;
        for(int i=1; i<prices.size(); ++i){
            if(prices[i] < Min){
                Min = prices[i];
                continue;
            }
            if(prices[i] - Min > profit){
                profit = prices[i] - Min;
            }
        }
        return profit;
    }
};
```

##### 42 连续子数组的最大和

```C++
class Solution {
public:
    /** 时间复杂度O(n); 空间复杂度O(1)
     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可
     *
     * 
     * @param array int整型vector 
     * @return int整型
     */
    // 求的是最大和，而不是最大长度
    int FindGreatestSumOfSubArray1(vector<int>& array) {
        if(array.empty())
            return 0;
        int dp0 = array[0];  // DP思想; 定义dp[i]： 以nums[i]结尾的最大连续和
        int maxDp = array[0];
        for(int i=1; i<array.size(); ++i){
            dp0 = max(array[i], dp0 + array[i]); // 基于array[i] 可以选择要dp[i-1]， 也可以选择不要dp[i-1]
            if(dp0 > maxDp)
                maxDp = dp0;
        }
        return maxDp;
    }
    // 贪心
    int FindGreatestSumOfSubArray(vector<int>& array){
        if(array.empty())
            return 0;
        int maxDp = array[0];
        int Sum = array[0];
        for(int i=1; i<array.size(); ++i){
            if(Sum < 0){
                Sum = array[i];
            }else{
                Sum += array[i];
            }
            if(Sum > maxDp){
                maxDp = Sum;
            }
        }
        return maxDp;
    }
};
```

// 变种求最大连续子数组和的长度

```C++
class Solution {
public:
    /**
     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可
     *
     * 
     * @param array int整型vector 
     * @return int整型vector
     */
    vector<int> FindGreatestSumOfSubArray1(vector<int>& array) {
        vector<int> dp(array.size(), 0);
        vector<int> state(array.size(), 0);
        dp[0] = array[0];
        int idx = 0; // 记录索引最大的地方
        for(int i=1; i<array.size(); ++i){
            if(dp[i - 1] + array[i] >= array[i]){
                state[i] = 1;
                dp[i] = dp[i-1] + array[i];
            }else{
                dp[i] = array[i];
            }
            if(dp[i] >= dp[idx]){
                idx = i;
            }
        }

        int ridx = idx;
        while(state[ridx]) // 根据选取的状态判断起始位置
            --ridx;
        return vector<int>(array.begin() + ridx, array.begin() + idx + 1);
    }

    vector<int> FindGreatestSumOfSubArray(vector<int>& array) {
        vector<int> res;
        vector<int> dp(array.size(), 0); //记录到下标i为止的最大连续子数组和
        dp[0] = array[0];
        int maxsum = dp[0];
        int left = 0, right = 0; //滑动区间
        int resl = 0, resr = 0; //记录最长的区间
        for(int i = 1; i < array.size(); i++){
            right++;
            dp[i] = max(dp[i - 1] + array[i], array[i]); //状态转移：连续子数组和最大值
            if(dp[i - 1] + array[i] < array[i]) //区间新起点
                left = right;
            if(dp[i] > maxsum || dp[i] == maxsum && (right - left + 1) > (resr - resl + 1)){ //更新最大值
                maxsum = dp[i];
                resl = left;
                resr = right;
            }
        }
        for(int i = resl; i <= resr; i++) //取数组
            res.push_back(array[i]);
        return res;
    }
};
```



##### 47 礼物的最大值

```C++
class Solution {
public:
    /**
     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可
     *
     * 
     * @param grid int整型vector<vector<>> 
     * @return int整型
     */
    int maxValue1(vector<vector<int>>& grid) {
        if(grid.empty() || grid[0].empty())
            return 0;
        vector<vector<int>> dp(grid.size() + 1, vector<int>(grid[0].size() + 1, 0));
        // 初始化 dp[x][0] = 0; dp[0][x] = 0;
        for(int i=1; i<=grid.size(); ++i){
            for(int j=1; j<=grid[0].size(); ++j){
                dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + grid[i-1][j-1];
            }
        }
        return dp[grid.size()][grid[0].size()];
    }

    // 贪心 ; 有问题；贪不了，除非深度优先
    int maxValue(vector<vector<int>>& grid){
        if(grid.empty() || grid[0].empty())
            return 0;
        int value = grid[0][0];
        int i = 0, j = 0;
        int r = grid.size(), c = grid[0].size();
        while(true){
            if(i + j + 2 == r + c)
                return value;
            if(i < r - 1 && j < c - 1){
                if(grid[i][j+1] >= grid[i+1][j]){
                    ++j;
                }else{
                    ++i;
                }
            }else if(i == r-1){
                ++j;
            }else{
                ++i;
            }
            value += grid[i][j];
        }
        return value;
    }

};
```

##### 46 把数字翻译成字符串

```C++
// 思路类似于青蛙跳台阶，只不过需要考虑跳每一步是否合理。
class Solution {
public:
    /**
     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可
     *
     * 解码
     * @param nums string字符串 数字串
     * @return int整型
     */
    int solve(string nums) {
        vector<int> dp(nums.size() + 1, 0); // 长度为i的
        if(nums.empty() || nums[0] == '0')
            return 0;
        dp[0] = dp[1] = 1;
        for(int i=2; i<=nums.size(); ++i){
            if(nums[i-1] == '0' && nums[i-2] == '0')
                return 0;
            if(nums[i-1] != '0'){
                dp[i] += dp[i-1];
            }
            if(TwoValid(nums, i - 2, i - 1)){
                dp[i] += dp[i-2];
            }
        }
        return dp[nums.size()];
    }

private:
    bool TwoValid(const string& nums, int lidx, int ridx){
        if(nums[lidx] < '1' || nums[lidx] > '2')
            return false;
        int val = 10 * (nums[lidx] - '0') + nums[ridx] - '0';
        return val <= 26;
    }
};
```

##### 48最长不含重复字符的子串

```C++
class Solution {
public:
    /**
     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可
     *
     * 
     * @param s string字符串 
     * @return int整型
     */
    // 双指针
    int lengthOfLongestSubstring1(string s) {
        if(s.empty()){return 0;}
        unordered_set<char> uset;
        int idx = 0;
        uset.insert(s[0]);
        int max_len = 1;
        for(int i=1; i<s.size(); ++i){
            if(uset.count(s[i])){
                if(max_len < uset.size())
                    max_len = uset.size();
                while(s[idx] != s[i]){
                    uset.erase(s[idx++]);
                }
                uset.erase(s[idx++]);
            }
            uset.insert(s[i]);
        }
        return max_len > uset.size() ? max_len : uset.size();
    }

    int lengthOfLongestSubstring(string s){

        // 以nums[i]结尾的最长不重复的字符串
        if(s.empty())
            return 0;
        int max_len = 1;
        int dp = 1;
        unordered_map<char, int> uset;
        uset.insert({s[0], 0});
        for(int i=1; i<s.size(); ++i){
            if(uset.count(s[i]) == 0){
                uset.insert({s[i], i});
                ++dp;
            }else{
                dp = min(i - uset[s[i]], dp + 1); // 为什么是这个？ 考虑内部元素重复; 
                uset[s[i]] = i;
            }

            if(dp > max_len){
                max_len = dp;
            }      
        }
        return  max_len;
    }
};
```

##### 49 丑树

```C++
class Solution {
public:
    /**
     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可
     * 丑树形式: $2^x * 3^y * 5^z$
     * 
     * @param index int整型 
     * @return int整型
     */
    int GetUglyNumber_Solution(int index) {
        // 定义dp数组
        if(index <= 6)
            return index;
        int i2 = 0, i3 = 0, i5 = 0;
        vector<int> res(index, 0);
        res[0] = 1;
        for(int i=1; i < index; ++i){
            res[i] = min(res[i2] * 2, min(res[i3] * 3, res[i5] * 5));
            if(res[i] == res[i2] * 2)
                ++i2;
            if(res[i] == res[i3] * 3)
                ++i3;
            if(res[i] == res[i5] * 5)
                ++i5;
        }
        return res[index - 1];
    }
};
```

##### 剑指offer 60. n个骰子的点数

假设有n个骰子，投出x点的概率为p(n, x) bound：x>=n;
$$
p(n, x) = \sum_{i=1}^{6}p(n-1, x-i) * 1/6  \\ x >= n
$$
可以采用dp

```C++
class Solution {
public:
    vector<double> dicesProbability(int n) {
        vector<double> ans(6, 1./6);
        if(n == 1) return ans;
        for(int i=2; i<=n; i++){
            vector<double> tmp(5*i + 1, 0.);
            for(int j=0; j<ans.size(); ++j){
                for(int k = 0; k<6 && j+k<(5*i+1); ++k){
                    tmp[j+k] += ans[j] / 6.;
                }
            }
            swap(ans, tmp);
        }
        return ans;
    }
};
```

### 位运算

##### 	15二进制中1的个数

​		将最低位的1置为0的方法： n & (n - 1);   判断某一位是否为1； n & (1 << i); 

```C++
class Solution {
public:
    /**
     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可
     *
     * 
     * @param n int整型 
     * @return int整型
     */
    int NumberOf11(int n) {
        if(n == 0) return 0;
        int count = 0;
        for(int i=0; i<32; ++i){
            if(n & (1 << i))
                ++count;
        }
        return count;
    }

    int NumberOf1(int n) {
        if(n == 0) return 0;
        int count = 0;
        while(n){
            ++count;
            n &= (n-1);
        }
        return count;
    }
};
```

##### 65 不用加减乘除做加法

// 需要考虑到进位，因此需要递归+， 直到进位数为0；公式：

// 加法在二进制位中可以拆分为 (A ^ B) + (A & B) << 1;

```C++
class Solution {
  public:
    int Add1(int num1, int num2) {
        //num2可以表示为进位，
        //循环的意义：循环将进位加到num1值上；
        while (num2 != 0) {//进位为0时，跳出循环
            int sum = num1 ^ num2;//非进位求和
            int temp = (unsigned int)(num1 & num2) << 1; //计算出进位；
            num1 = sum;//非进位和
            //可以将6、8行写成num1^=num2;
            num2 = temp;//进位；
        }
        return num1;
    }
    int Add(int num1, int num2){
        // 加法在二进制位中可以拆分为 (A ^ B) + (A & B) << 1;
        if(num2 == 0)
            return num1;
        return Add(num1 ^ num2, (num1 & num2) << 1); 
    }
};
```

##### 56.数组中数字出现的次数I

核心公式: a ^ b = b ^ a;  a ^ b ^ a = b; --->偶数个相同的数异或为0; 设num1 != num2 ---> num1 ^ num2 != 0; 存在至少一个为1; 若数组中只有一个元素出现次数为奇数---> 奇数 = num[0] ^ num[1] ^ ... ^ num[n-1];

​	现在数组中有两个不同的元素出现的次数为单数

```C++
using namespace std;
class Solution {
public:
    /**
     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可
     *
     * 方法：哈希; 位运算
     * @param nums int整型vector 
     * @return int整型vector
     */
    // 时间复杂度 O(n); 空间复杂度 O(n);
    vector<int> FindNumsAppearOnce1(vector<int>& nums) {
        unordered_map<int, int> m;
        for(int i=0; i<nums.size(); ++i){
            m[nums[i]]++;
        }
        vector<int> ans;
        for(auto & pair : m){
            if(pair.second == 1)
                ans.push_back(pair.first);
        }
        sort(ans.begin(), ans.end());
        return ans;
    }

    vector<int> FindNumsAppearOnce(vector<int>& nums){
        int ret = nums[0]; // 所有元素的异或结果; 最终得到 num1 ^ num2; num1 不等于num2
        for(int i=1; i<nums.size(); ++i){
            ret ^= nums[i];
        }
       // 对异或结果的分析； 是0的位表示：两个都有； 1：一个数存在，一个数不存在； 分成两拨; 按照某一位
       int idx;
       for(idx=0; idx<32; ++idx){
        if(ret & (idx << idx))
            break;
       }
       int num1 = ret, num2 = ret;
       for(int i=0; i<nums.size(); ++i){
        if(nums[i] & (1 << idx))
            num1 ^= nums[i];
        else
            num2 ^= nums[i];
       }
       if(num1 < num2)
        return {num1, num2};
        return {num2, num1};
    }
};
```

##### 56 的变体 题目: 在一个数组 nums 中除一个数字只出现一次之外，其他数字都出现了三次。请找出那个只出现一次的数字。

![image-20230813084701500](C:\Users\admin\AppData\Roaming\Typora\typora-user-images\image-20230813084701500.png)

```C++
class Solution {
public:
    int singleNumber1(vector<int>& nums) {
        unordered_map<int, int> m;
        for(auto &elem : nums)
            ++m[elem];
        for(auto &pair : m){
            if(pair.second == 1)
                return pair.first;
        }
        return -1;
    }

    // 统计位数
    int singleNumber(vector<int>& nums){
        int ret = 0;
        for(int i=0; i<32; ++i){
            int cnt = 0;
            for(auto &elem : nums){
                if(elem & (1 << i)){
                    ++cnt;
                }
            }
            if(cnt % 3){
                ret += (1 << i);
            }
        }
        return ret;
    }
};
```

##### 51 数组中出现次数超过一半的数字

​	很容易想到的是哈希、排序；最后一个是同归于尽的思想，多数抵消少数原则，多数胜利

```C++
class Solution {
  public:
    /**
     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可
     *
     *
     * @param numbers int整型vector
     * @return int整型
     */
    int MoreThanHalfNum_Solution1(vector<int>& numbers) {
        // write code here
        int len = numbers.size() / 2 + 1;
        sort(numbers.begin(), numbers.end());
        for (int i = 0; i < numbers.size(); ++i) {
            int cnt = 1;
            while (i < numbers.size() && numbers[i] == numbers[i + 1]) {
                ++cnt;
                ++i;
            }
            if (cnt >= len) {
                return numbers[i];
            }
        }
        return -1;
    }

    int MoreThanHalfNum_Solution(vector<int>& numbers) {
        int candidate = numbers[0];
        int count = 1;
        for (int i = 1; i < numbers.size(); i++) {
            if (numbers[i] == candidate) { // 想通
                count++;
            } else {
                count--;
            }
            if (count == 0) {
                candidate = numbers[i + 1];
                count++;
            }
        }
        return candidate;
    }
};
```

### 数学

##### 66 构建乘积数组

```C++
class Solution {
public:
    vector<int> constructArr1(vector<int>& a) {
        if(a.size() == 0)
            return {};
        // 解法1： 暴力模拟
        vector<int> b(a.size(), 1);
        for(int i=0; i<a.size(); ++i){
            for(int j=0; j<a.size(); ++j){
                if(j == i){
                    continue;
                }
                b[i] *= a[j];
            }
        }
        return b;
    }

    vector<int> constructArr2(vector<int>& a){
        int mulDot = 1;
        vector<int> b(a.size(), 0);
        for(auto &elem : a){
            mulDot *= elem;
        } 
        // 计算b的值
        for(int i=0; i<a.size(); ++i){
            b[i] = mulDot / a[i];
        }
        return b;
    }

    vector<int> constructArr(vector<int>& a){
        if(a.size() == 0){
            return {};
        }
        // 将乘积拆成两部分
        vector<int> b(a.size(), 1);
        int tmp = 1;
        for(int i=a.size() - 1; i>=0; --i){
            b[i] *= tmp;
            tmp *= a[i];
        }
        
        tmp = 1;
        for(int i=0; i<a.size(); ++i){
            b[i] *= tmp;
            tmp *= a[i];
        }
        return b;
    }
};
```

##### 14.剪绳子问题

​	一根长为n的绳子剪成m段，求乘积最大值。

```C++
class Solution {
public:
    int cuttingRope1(int n) {
        // 尽可能的等长; 
        int maxMul = 0;
        for(int num = 2; num <= n; ++num){
            int len = n / num;
            int mod = n % num;
            int val = power(len, num - mod) * power(len + 1, mod);
            if(val > maxMul){
                maxMul = val;
            }
        }
        return maxMul;
    }
    // 动态规划的思想
    int cuttingRope(int n){
        // dp[i]定义为长度为i拆分成至少两个数乘积的最大值
        vector<int> dp(n + 1, 0); 
        // 初始化
        dp[2] = 1, dp[1] = 1;  // dp[1]在这里没有意义，只是为了初始化
        for(int i=3; i<=n; ++i){
            for(int j=1; j<i; ++j){ // 分割成长度为 i-j 和 j两部分，这两部分可以选择继续切分或者切分
                dp[i] = MAX(dp[i], (i - j) * j, dp[i-j]*j, dp[i-j]*dp[j]); // 2段， 3段及以上， 4段及以上
            }
        }
        return dp[n];
    }
private:
    int MAX(int val1, int val2, int val3, int val4){
        return max(max(val1, val2), max(val3, val4));
    }
    int power(int n, int k){
        // 实现的是整数的
        if(k == 0){
            return 1;
        }else if(k == 1){
            return n;
        }else if(k % 2 == 0){
            return power(n, k/2) * power(n, k/2);
        }else{
            return power(n, k/2) * power(n, k/2 + 1);
        }
    }
};
```

##### 5和为s的连续正整数序列

```C++
class Solution {
public:
    vector<vector<int>> findContinuousSequence(int target) {
        vector<vector<int>> ans;
        if(target < 3){
            return ans;
        }

        // target >= 3;
        int n = target / 2 + 1;
        //滑动窗口思想
        int l = 1, r = 2, sum = 1;
        for(;r<=n; ++r){
            sum += r;
            while(sum > target){
                sum -= l;
                l++;
            }

            if(sum == target){
                put(ans, l, r);
            }
        }
        return ans;
    }
private:
    void put(vector<vector<int>>& ans, int l, int r){
        // 闭区间 [l, l+1, ..., r]
        vector<int> path;
        while(l <= r){
            path.push_back(l++);
        }
        ans.push_back(path);
    }

};
```

##### 62.圆圈中最后剩下的数字

<font color="red">频率出现的非常频繁</font>0,1,···,n-1这n个数字排成一个圆圈，从数字0开始，每次从这个圆圈里删除第m个数字（删除后从下一个数字开始计数）。求出这个圆圈里剩下的最后一个数字。

例如，0、1、2、3、4这5个数字组成一个圆圈，从数字0开始每次删除第3个数字，则删除的前4个数字依次是2、0、4、1，因此最后剩下的数字是3。

```C++
class Solution {
public:
    int lastRemaining1(int n, int m) {
        // 1.暴力模拟法---> 超出时间限制
        vector<int> nums(n, 0);
        for(int i=1; i<n; ++i){
            nums[i] = i;
        }
        int idx = 0;
        while(nums.size() > 1){
            idx = (idx + m - 1) % nums.size(); // 索引是相对的
            nums.erase(nums.begin() + idx); // 删除完后，后面的元素会补上来
        }
        return nums[0];
    }
    // 总结一下推导公式：(此轮过后的num下标 + m) % 上轮元素个数 = 上轮num的下标
    int lastRemaining(int n, int m){
        // 约瑟夫环-->倒推
        int ans = 0; // 最后一轮所在的索引位置
        for(int i = 2; i<=n; ++i){
            ans = (ans + m) % i;
        }
        return ans;
    }
};
```

##### 43.1~n中整数1出现的次数

```C++
class Solution {
public:
    // 1. 暴力模拟--->超时间
    int countDigitOne1(int n) {
        int total = 0;
        for(int i=1; i<=n; ++i){
            total += countOne(i);
        }
        return total;
    }
private:
    int countOne(int n){
        int count = 0;
        while(n){
            int mod = n % 10;
            if(mod == 1){
                ++count;
            }
            n /= 10;
        }
        return count;
    }
};

// 应该选择类比于二进制中的方法，但实际上是在十进制下，将数组分为三部分： 高位 、 当前位和地位；
讨论当前位不同取值时，不同位数的统计方法。  
```

<img src="I:\U盘内容\Primer\数据结构与算法\代码随想录\pic\image-20230815094022734.png" alt="image-20230815094022734" style="zoom:50%;" />

<img src="I:\U盘内容\Primer\数据结构与算法\代码随想录\pic\image-20230815094113395.png" alt="image-20230815094113395" style="zoom:50%;" />

<img src="I:\U盘内容\Primer\数据结构与算法\代码随想录\pic\image-20230815094140179.png" alt="image-20230815094140179" style="zoom:50%;" />

// 最终的代码实现， 要动手自己推一下三种情况下的

```C++
class Solution {
public:
    int countDigitOne(int n) {
        // 返回结果初始化为0
        int res = 0;
        // 先对最低位进行初始化
        int cur = n % 10, high = n / 10, low = 0;
        long digital = 1;
        while(high != 0 || cur != 0){
            if(cur == 0){
                res += int(high * digital);
            }else if(cur == 1){
                res += int(high * digital + low + 1);
            }else{
                res += int((high+1) * digital);
            }
            low = int(low + digital*cur);
            cur = high % 10;
            high = high / 10;
            digital *= 10;
        }
        return res;
    }
};
```

##### 44.数字序列中的某一位

减去每一轮的个数，再从确定的一轮开始数(n/m)个数为number， number的第(n % m)位

```C++
class Solution {
    public int findNthDigit(int n) {
        // 0-9: 10 * 1  = (10 -0) * 1
        // 10 -99: 90 * 2 = (100 -10) * 2
        // 100 -999: 900 * 3 = (1000 - 100) * 3
        // ... : (10^n - 10^n-1) * n
        
        int m = 1;
        long p = 1, lastP = 0, k;
        while (n - (k = p * 10 - lastP) * m > 0) {
            n -= k * m++;
            lastP = p = p * 10;
        }
        return String.valueOf(lastP + n / m).charAt(n % m) - '0';  // 类似于二维数组中的位置
    }
}

// C++写法
class Solution {
public:
    int findNthDigit(int n) {
        int a = 9, b = 1;
        long c = 1, tmp = a * b * c;
        // a = 9, b = 2, c = 10 9x2x10
        // a = 9, b = 3, c = 100 9x3x100
        while(n - tmp > 0){
            n -= tmp;
            b++;
            c *= 10;
            tmp = a * b * c;
        }
        int num = c + (n-1)/b;
        string str = to_string(num);//下标0
        return str[(n-1)%b] - '0';
    }
};
```

# Hot100

##### 	LC146 LRU缓存

​		可以改进的地方是使用自己实现的链表，而不是利用系统自带的list

```C++
class LRUCache {
public:
    LRUCache(int capacity) : m_capactity(capacity){
    }
    
    int get(int key) {
        if(m_itermap.find(key) == m_itermap.end()){
            return -1;
        }else{
            auto& iter = m_itermap[key]; 
            m_list.splice(m_list.begin(), m_list, iter);  // 访问后放到链表头部
            return m_itermap[key]->first;
        }
    }
    
    void put(int key, int value) {
        if(m_itermap.find(key) != m_itermap.end()){
            m_itermap[key]->first = value;
            m_list.splice(m_list.begin(), m_list, m_itermap[key]);
        }else if(m_list.size() < m_capactity){
            m_list.push_front({value, key});
            m_itermap[key] = m_list.begin();
        }else{
            auto& pairs = m_list.back();
            m_itermap.erase(pairs.second);
            m_list.pop_back();
            m_list.push_front({value, key});
            m_itermap[key] = m_list.begin();
        }
    }

private:
    int m_capactity; // 页面数量
    list<pair<int, int>> m_list; // 维护(value, key)的链表(实际上就是物理页面的地址或数据); 为什么还要保存key, 因为尾部删除的时候要找到key，更新m_itermap
    unordered_map<int, list<pair<int, int>>::iterator> m_itermap;  // O(1)访问
};
```

##### LC148 链表的排序

​	利用归并排序，从数组引申到链表

```C++
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode() : val(0), next(nullptr) {}
 *     ListNode(int x) : val(x), next(nullptr) {}
 *     ListNode(int x, ListNode *next) : val(x), next(next) {}
 * };
 */
 // 链表的归并排序
class Solution {
public:
    ListNode* sortList(ListNode* head) {
        return mergeSort(head);
    }

private:
    ListNode* mergeSort(ListNode* head){
        if(!head || !head->next){
            return head;
        }
        ListNode* mid = findMid(head);
        ListNode* l1 = head;
        ListNode* l2 = mid->next;
        mid->next = nullptr;
        l1 = mergeSort(l1); // mid放在l1中了
        l2 = mergeSort(l2);
        return merge(l1, l2);
    }

    ListNode* findMid(ListNode* head){
        ListNode* slow = head, *fast = head;
        while(fast->next && fast->next->next){
            slow = slow->next;
            fast = fast->next->next;
        }
        return slow;
    }

    ListNode* merge(ListNode* l1, ListNode* l2){
        if(!l1 || !l2){
            return l1 == nullptr ? l2 : l1;
        }
        // 合并两个有序链表
        ListNode* dummy = new ListNode(-1);
        ListNode* curr = dummy;
        while(l1 || l2){
            if(!l1){
                curr->next = l2;
                break;
            }else if(!l2){
                curr->next = l1;
                break;
            }else if(l1->val <= l2->val){
                curr->next = l1;
                l1 = l1->next;
                curr = curr->next;
            }else{
                curr->next = l2;
                l2 = l2->next;
                curr = curr->next;
            }
        }
        ListNode* tmp = dummy->next;
        delete dummy;
        return tmp;
    }
};
```

##### 32 最长有效括号

​	使用栈模拟哪些括号是匹配的，匹配的位置用flag=0表示，不匹配的位置用1标志。最后统计最长连续数字0的长度

```C++
class Solution {
public:
    int longestValidParentheses(string s) {
        stack<int> st;
        vector<bool> mark(s.size(), false);
        int left = 0, len = 0, ans = 0;
        for(int i = 0; i < s.size(); i++) {
            if(s[i] == '(') st.push(i); // 存放下标
            else {
                // 多余的右括号是不需要的，标记
                if(st.empty()) mark[i] = true;
                else st.pop();
            }
        }
        // 未匹配的左括号是不需要的，标记
        while(!st.empty()) {
            mark[st.top()] = true;
            st.pop();
        }
        // 寻找标记与标记之间的最大长度
        for(int i = 0; i < s.length(); i++) {
            if(mark[i]) {
                len = 0;
                continue;
            }
            len++;
            ans = max(ans, len);
        }
        return ans;
    }
};
```

##### LC49.字母异位词分组

```C++
class Solution {
public:
    // 哈希方式，实际上也是暴力模拟
    vector<vector<string>> groupAnagrams(vector<string>& strs) {
        if(strs.size() < 2){
            return {strs};
        }
        for(int i=0; i<strs.size(); ++i){
            isNewPattern(strs[i]);
        }
        return ans;
    }

private:
    vector<vector<string>> ans;
    unordered_map<string, int> umap;
    void isNewPattern(string& str){
        string tmp = str;
        sort(tmp.begin(), tmp.end());
        if(umap.find(tmp) != umap.end()){
            ans[umap[tmp]].push_back(str);
        }else{
            vector<string> stmp;
            stmp.push_back(str);
            ans.push_back(stmp);
            umap[tmp] = ans.size() - 1;
        }
    }
};
```

##### 	LC10.正则表达式匹配

```C++
class Solution {
public:
    bool isMatch(string s, string p) {
        s=" "+s;//防止该案例：""\n"c*"
        p=" "+p;
        int m=s.size(),n=p.size();
        bool dp[m+1][n+1];
        memset(dp,false,(m+1)*(n+1));
        dp[0][0]=true;
        for(int i=1;i<=m;i++){
            for(int j=1;j<=n;j++){
                if(s[i-1]==p[j-1] || p[j-1]=='.'){
                    dp[i][j]=dp[i-1][j-1]; // S[i-1]与p[i-1]相等	
                }
                else if(p[j-1]=='*'){ // 关键是为*的时候判断准则
                    if(s[i-1]!=p[j-2] && p[j-2]!='.')  // s[i-1]不等于p[j-2]
                        dp[i][j]=dp[i][j-2];
                    else{ 
                        // dp[i][j-1] 表示s[i-1] p[j-2]相匹配, 那么p[j-1]
                        // dp[i-1][j]表示*多次使用
                        // dp[i][j-2] 表示抛弃_*两个字符，回退
                        dp[i][j]=dp[i][j-1] || dp[i][j-2] || dp[i-1][j];
                    }
                }
            }
        }
        return dp[m][n];
    }
};
```

##### LC79单词搜索

​	采用dfs方式，同时采用了状态标记位，重复搜索的位置不在dfs

```C++
class Solution {
public:
    bool exist(vector<vector<char>>& board, string word) {
        vector<vector<bool>> state(board.size(), vector<bool>(board[0].size()));  // 记录访问位
        for(int i=0; i<board.size(); ++i){
            for(int j=0; j<board[0].size(); ++j){
                if(board[i][j] == word[0] && backtracking(board, word, state, i, j, 0)){
                    return true;
                }
            }
        }
        return false;

    }

private:
    bool backtracking(vector<vector<char>>& board, string& word, vector<vector<bool>>& state, int ridx, int cidx, int tidx){
        // 1. 搜索成功的标志
        if(tidx == word.size()){
            return true;
        }
        // 2. 数据越界的情况; 3.搜过了就不要搜索了
        if(ridx < 0 || ridx >= board.size() || cidx < 0 || cidx >= board[0].size() || state[ridx][cidx]){
            return false;
        }

        if(board[ridx][cidx] == word[tidx]){
            ++tidx;
            state[ridx][cidx] = true;
            bool lret = backtracking(board, word, state, ridx, cidx - 1, tidx);
            bool rret = backtracking(board, word, state, ridx, cidx + 1, tidx);
            bool uret = backtracking(board, word, state, ridx - 1, cidx, tidx);
            bool dret = backtracking(board, word, state, ridx + 1, cidx, tidx);
            --tidx;
            state[ridx][cidx] = false;
            return lret || rret || uret ||dret;
        }else{
            return false;
        }
    }
};
```

##### LC76. 最小覆盖子串

// 滑动窗口思想，先全部包围，然后移除一个，在扩展, 在缩小

```C++
class Solution {
public:
    string minWindow(string s, string t) {
		// 哈希思想
        int need[123] = {0}; // A:65 a:97 z:122;
        for(auto& elem:t){
            ++need[elem];
        }

        int needCnt = t.size(); // 总的个数
        int len = INT_MAX, start = 0;
        for(int i=0, j=0; i<s.size() && j < s.size();){
            // 右端点: j - 1遍历到包含所有元素为止--->needCnt = 0;
            while(j < s.size() && needCnt > 0){
                if(need[s[j]] > 0){
                    --needCnt;
                }
                need[s[j]]--;
                ++j;
            }

            // 左端点 : i 遍历到包含的元素为止--->need[s[i]] == 0;
            while(i < s.size() && need[s[i]] < 0){
                need[s[i]]++;
                i++;
            }
            // 前提是找到一个
            if(needCnt == 0 && j - i < len){
                len = j - i;
                start = i;
            }

            // i++ 考虑下一个合法序列
            need[s[i]]++;
            needCnt++;
            i++;
        }
        return len == INT_MAX ? "" : s.substr(start, len);
    }

};
```

##### LC84.柱状图最大的矩形

```C++
class Solution {
public:
    int largestRectangleArea(vector<int>& heights) {
        // 以height[i]为基准，向左右做单调栈， 也就是找到左侧和右侧第一个小于height[i]
        int res = 0;
        heights.insert(heights.begin(), 0);
        heights.push_back(0);
        stack<int>stk;
        stk.push(0); // 存在的是index, 确保边界问题
        for(int i=1; i<heights.size(); ++i){
            if(heights[i] > heights[stk.top()]){
                stk.push(i);
            }else if(heights[i] == heights[stk.top()]){
                stk.push(i);
            }else{ // height[i]表示的栈口元素的右侧元素
                while(!stk.empty() && heights[i] < heights[stk.top()]){
                    int mid = stk.top(); 
                    stk.pop();
                    if(!stk.empty()){
                        int left = stk.top(); // height[mid]左侧的索引，其值小于height[mid]
                        int right = i;
                        int h = heights[mid];
                        if(res < (right - left - 1) * h){
                            res = (right - left - 1) * h;
                        }
                    }
                }
                stk.push(i);
            }
        }
        return res;
    }
};
```

##### LC 85最大矩形

```C++
// 考虑将最大矩形求解问题转换成最大柱状图面积求解，其思想是从顶部开始累计前缀和， 断了的地方要置0（也就是不连续1出现的位置)，每累计一行，就求一次最大柱状图面积。最大柱状图面积采用的思想是：以index的柱状图为高，往两边辐射--->左右两侧第一个小于mid的索引i, j--->width = j - i -1; 高为h[index]--->这样就可以求出柱状图面积
class Solution {
public:
    int maximalRectangle(vector<vector<char>>& matrix) {
        // 暴力模拟
        int m = matrix.size(), n = matrix[0].size();
        vector<int> bar(n, 0);
        int max_bar = 0; // 记录最大柱状图的面积
        for(int i=0; i<m; ++i){
            add_bar(matrix[i], bar);
            int barArea = calMaxBarArea(bar);
            if(barArea > max_bar){
                max_bar = barArea;
            }
        }
        return max_bar;
    }


private:
    int calMaxBarArea(vector<int> bar){
        bar.insert(bar.begin(), 0);
        bar.push_back(0);
        stack<int> barIndex;
        barIndex.push(0);
        int maxArea = 0;
        for(int i=1; i<bar.size(); ++i){
            if(barIndex.empty() || bar[i] >= bar[barIndex.top()]){
                barIndex.push(i);
            }else{ // bar[i] <bar[barIndex.top()]
                while(!barIndex.empty() && bar[barIndex.top()] > bar[i]){
                    int mid = barIndex.top(); // 以index = mid为起点，往左边两边扩散
                    barIndex.pop();
                    if(!barIndex.empty()){
                        int left = barIndex.top();
                        int area = (i - left - 1) * bar[mid];
                        if(area > maxArea){
                            maxArea = area;
                        }
                    }
                }
                barIndex.push(i); // 要在插回去
            }
        }
        return maxArea;
    }

    void add_bar(vector<char>& row_bar, vector<int>& bar){
        for(int j=0; j<row_bar.size(); ++j){
            if(row_bar[j] == '0'){ //不连续的要置0， 因为已经考虑了之前的。
                bar[j] = 0;
            }else{
                ++bar[j];
            }
        }
    }
};
```





# 谷歌大佬leetcode刷题技巧

## Array

##### 1.两数之和

```C++
class Solution {
public:
    // 通过hash来决策; 空间换时间， S : O(n), T: O(n)
    vector<int> twoSum1(vector<int>& nums, int target) {
        unordered_map<int, int> restVal; // 记录希望找到的剩余值
        for(int i=0; i<nums.size(); ++i){
            if(restVal.find(nums[i]) != restVal.end()){
                return {i, restVal[nums[i]]};
            }
            restVal[target - nums[i]] = i; // key = 剩余值, value = target - nums[i]的索引
        }
        return {};
    }

    // 通过暴力方式模拟查找
    vector<int> twoSum(vector<int>& nums, int target){
        for(int i = 0; i<nums.size(); ++i){
            for(int j = i + 1; j<nums.size(); ++j){
                if(nums[i] + nums[j] == target){
                    return {i, j};
                }
            }
        }
        return {};
    }
};
```

##### Median of Two Sorted Arrays

给定两个大小分别为 m 和 n 的正序（从小到大）数组 nums1 和 nums2。请你找出并返回这两个正序数组的 中位数 。

算法的时间复杂度应该为 O(log (m+n))

```C++
class Solution1 {
public:
    double findMedianSortedArrays(vector<int>& nums1, vector<int>& nums2) {
        // 类似于在有序数组中寻找第k大的数
        int n = nums1.size() + nums2.size();
        if(n % 2 == 0){
            int left = find(nums1, 0, nums2, 0, n / 2);
            int right = find(nums1, 0, nums2, 0, n / 2 + 1);
            return (left + right) / 2.0 ;
        }else{
            return find(nums1, 0, nums2, 0, n / 2 + 1);
        }
    }

    int find(vector<int>& nums1, int i, vector<int>& nums2, int j, int k){
        if(nums1.size() - i > nums2.size() - j){ // 使得nums1的长度恒小于等于nums2
            return find(nums2, j, nums1, i, k); 
        }

        if(nums1.size() == i) return nums2[j + k - 1]; // k - 1相对于j的偏移量

        if(k == 1) return min(nums1[i], nums2[j]);

        int idx1 = min((int)nums1.size(), i + k / 2); // 越界问题
        int idx2 = j + k / 2;

        if(nums1[idx1 - 1] < nums2[idx2 - 1]){
            return find(nums1, idx1, nums2, j, k - (idx1 - i));
        }else{
            return find(nums1, i, nums2, idx2, k - (idx2 - j));
        }

    }
};

class Solution {
public:
    // 转化为寻找第k个数<---在两个有序数组中寻找第k大的数
    double findMedianSortedArrays(vector<int>& nums1, vector<int>& nums2) {
        int m = nums1.size(), n = nums2.size();
        if((m + n) % 2 != 0){
            return (double)findKthVal(nums1, nums2, 0, nums1.size(), 0, nums2.size(), (m + n) / 2 + 1);
        }else{
            return (findKthVal(nums1, nums2, 0, nums1.size(), 0, nums2.size(), (m + n) / 2) + \
                   findKthVal(nums1, nums2, 0, nums1.size(), 0, nums2.size(), (m + n) / 2 + 1)) / 2.;
        }
    }

private:
    int findKthVal(vector<int>& nums1, vector<int>& nums2, int l1, int r1, int l2, int r2, int k){
        
        if(r1 - l1 < r2 - l2){
            return findKthVal(nums2, nums1, l2, r2, l1, r1, k);
        }

        if(l2 == r2){  // 其中一个数组没有长度了
            return nums1[l1 + k - 1];
        }

        if(k==1){
            return min(nums1[l1], nums2[l2]);
        }

        int idx1 = l1 + k / 2;
        int idx2 = min(r2, l2 + k / 2);

        if(nums1[idx1 - 1] > nums2[idx2 - 1]){
            return findKthVal(nums1, nums2, l1, r1, idx2, r2, k - (idx2 - l2));
        }
        return findKthVal(nums1, nums2, idx1, r1, l2, r2, k - (idx1 - l1));

    }
};
```

#####   11盛水最多的容器           

```C++
class Solution {
public:
    int maxArea1(vector<int>& height) {
        // 暴力模拟; T： O（n^2）
        int maxS = 0;
        for(int i=0; i<height.size(); ++i){
            for(int j = i+1; j<height.size(); ++j){
                if(min(height[i], height[j]) * (j - i) > maxS){
                    maxS = min(height[i], height[j]) * (j - i);
                }
            }
        }
        return maxS;
    }
	// 最短板效应
    // 尽可能保留高的值；双指针; w一定，就要使得high=min(height[left], height[right])近可能大
    int maxArea(vector<int>& height){
        int left = 0, right = height.size() - 1, maxS = 0;
        while(left < right){
            int tmpS = min(height[left], height[right]) * (right - left);
            if(height[left] > height[right]){
                --right;
            }else{
                ++left;
            }

            if(tmpS > maxS){
                maxS = tmpS;
            }
        }
        return maxS;
    }

};
```

#####    ![image-20230828140539111](I:\U盘内容\Primer\数据结构与算法\代码随想录\pic\image-20230828140539111.png)                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  

##### 15三数之和

```C++
class Solution {
public:
    vector<vector<int>> threeSum(vector<int>& nums) {
        vector<vector<int>> ans;
        sort(nums.begin(), nums.end()); // O(nlogn)
        for(int N1 = 0; N1 < nums.size(); ++N1){
            // 第一个数字去重
            while(N1 > 0 && N1 < nums.size() && nums[N1] == nums[N1-1]){
                ++N1;
            }
            int N2 = N1 + 1, N3 = nums.size() - 1;
            while(N2 < N3){
                while(N2 < N3 && N2 > N1 + 1 && nums[N2] == nums[N2-1]){
                    ++N2;
                }
                while(N2 < N3 && N3 < nums.size() - 1 && nums[N3] == nums[N3 + 1]){
                    --N3;
                }

                if(N2 >= N3){
                    break;
                }
                
                if(nums[N1] + nums[N2] + nums[N3] == 0){
                    ans.push_back({nums[N1], nums[N2], nums[N3]});
                    ++N2;
                }else if(nums[N2] + nums[N3] > -nums[N1]){
                    --N3;
                }else{
                    ++N2;
                }
            }
        }
        return ans;
    }
};
```

##### 16三数最近

给定一个数组，要求在这个数组中找出 3 个数之和离 target 最近;

解题思路，类似与三树之和。只不过多了一个判断

```C++
class Solution {
public:
    // 还可以适当去重
    int threeSumClosest(vector<int>& nums, int target) {
        sort(nums.begin(), nums.end()); // 排序
        int absCloseVal = INT_MAX, ans;
        for(int N1 = 0; N1 < nums.size(); ++N1){
            int N2 = N1 + 1, N3 = nums.size() - 1;
            while(N2 < N3){
                int sum = nums[N1] + nums[N2] + nums[N3];
                if(sum == target){
                    return target;
                }

                if(abs(sum - target) < absCloseVal){
                    absCloseVal = abs(sum - target);
                    ans = sum;
                }

                if(sum < target){
                    ++N2;
                }else{
                    --N3;
                }
            }
        }
        return ans;
    }
};
```

##### 27元素复写；

​	去除重复的元素

```C++
class Solution {
public:
    int removeElement(vector<int>& nums, int val) {
        int freeloc = 0;
        for(int i = 0; i < nums.size(); ++i){
            if(nums[i] != val){
                nums[freeloc++] = nums[i];
            }
        }
        return freeloc;
    }
};
```

##### 31下一个排列

```C++
class Solution {
public:
    void nextPermutation(vector<int>& nums) {
        int first = nums.size() - 1;
        // 从尾部寻找第一个顺序对，调整为逆序对
        while(first > 0 && nums[first - 1] >= nums[first]){
            --first;
        }
        if(first <= 0){
            reverse(nums.begin(), nums.end());
            return;
        }

        // 在[first-1, end)中寻找第一个
        int second = nums.size() - 1;
        while(second >= first && nums[second] <= nums[first-1]){
            --second;
        }
        swap(nums[first-1], nums[second]); // 交换，生成一个逆序对
        reverse(nums.begin() + first, nums.end()); // 把逆序对后面的摆顺; 逆序变成顺序，值小
    }
};
```

##### 36有效数独

​	采用暴力方式

```C++
class Solution {
public:
    bool isValidSudoku(vector<vector<char>>& board) {
        return rowValid(board) && colValid(board) && threeCellValid(board);
    }

private:
    bool rowValid(vector<vector<char>>& board){
        for(int i=0; i<board.size(); ++i){
            bool state[9] = {false};
            for(int j=0; j<board[0].size(); ++j){
                if(board[i][j] != '.'){
                    if(state[board[i][j] - '0' - 1]){
                        return false;
                    }
                    state[board[i][j] - '0' - 1] = true;
                }
            }
        }
        return true;
    }

    bool colValid(vector<vector<char>>& board){
        for(int i=0; i<board.size(); ++i){
            bool state[9] = {false};
            for(int j=0; j<board[0].size(); ++j){
                if(board[j][i] != '.'){
                    if(state[board[j][i] - '0' - 1]){
                        return false;
                    }
                    state[board[j][i] - '0' - 1] = true;
                }
            }
        }
        return true;
    }

    bool threeCellValid(vector<vector<char>>& board){
        for(int i=0; i<3; ++i){
            for(int j=0; j<3; ++j){
                if(!valid(board, i, j)){
                    return false;
                }
            }
        }
        return true;
    }

    bool valid(vector<vector<char>>& board, int r, int c){
        bool state[9] = {false};
        for(int i=0; i<3; ++i){
            for(int j=0; j<3; ++j){
                int ridx = r * 3 + i;
                int cidx = c * 3 + j;
                if(board[ridx][cidx] == '.') continue;
                if(state[board[ridx][cidx] - '0' - 1]){
                    return false;
                }
                state[board[ridx][cidx] - '0' - 1] = true;
            }
        }
        return true;
    }
};
```

##### 37解数独问题

```C++
class Solution {
public:
    vector<vector<char>> ans;
    void solveSudoku(vector<vector<char>>& board){
        _solveSudoku(board); // 因为回溯会将棋盘复位，因此调用一个内部函数来dfs
        board = ans;
    }

    void _solveSudoku(vector<vector<char>>& board) {
        // 寻找第一个有空的位置
        auto pairs = findFirstSpace(board);
        if(pairs.first == -1){
            ans = board; // 收集结果的位置
            return;
        }

        for(char ch = '1'; ch <= '9'; ++ch){
            if(Isvalid(board, pairs, ch)){
                board[pairs.first][pairs.second] = ch;
                _solveSudoku(board);
                board[pairs.first][pairs.second] = '.';
            }
        }
    }

private:
    pair<int, int> findFirstSpace(vector<vector<char>>& board){
        for(int i=0; i<9; ++i){
            for(int j=0; j<9; ++j){
                if(board[i][j] == '.'){
                    return {i, j};
                }
            }
        }
        return {-1, -1};
    }

    bool Isvalid(vector<vector<char>>& board, pair<int, int>& pairs, char& ch){
        return _Valid(board, pairs, ch);
    }

    bool _Valid(vector<vector<char>>& board, pair<int, int>& pairs, char& ch){
        int ridx = pairs.first, cidx = pairs.second; // {i, j}
        for(int i=0; i<9; ++i){
            if(board[ridx][i] == ch || board[i][cidx] == ch){
                return false;
            }
        }

        // 九宫格
        ridx /= 3;
        cidx /= 3;
        for(int i=0; i<3; ++i){
            for(int j=0; j<3; ++j){
                if(board[ridx * 3 + i][cidx * 3 + j] == ch){
                    return false;
                }
            }
        }
        return true;
    }
};
```

##### 39.组合目标和

回溯算法穷举;不用考虑去重，还有去重的版本

```C++
class Solution {
public:
    vector<vector<int>> combinationSum(vector<int>& candidates, int target) {
        vector<vector<int>> ans;
        vector<int> path;
        int sum = 0;
        backtracking(candidates, ans, path, 0, sum, target);
        return ans;
    }

private:
    // 因为可以重复取，因此starIdx不用加
    void backtracking(vector<int>& candidates, vector<vector<int>>& ans, vector<int>& path, int startIdx, int& sum, int& target){
        if(sum >= target){
            if(sum == target){
                ans.push_back(path);
            }
            return;
        }
        for(int i=startIdx; i<candidates.size(); ++i){
            sum += candidates[i];
            path.push_back(candidates[i]);
            backtracking(candidates, ans, path, i, sum, target);
            sum -= candidates[i];
            path.pop_back();
        }
    }
};
```

41 第一个缺失的正整数

```C++
class Solution {
public:
    // T: O(n); S: O(n)
    int firstMissingPositive1(vector<int>& nums) {
        // 寻找最小未出现的正数
        int len = nums.size();
        vector<bool> state(len, false); // 这里要优化，否则不满足O(1)空间复杂度 
        for(int i=0; i<nums.size(); ++i){
            if(0 < nums[i] && nums[i] <= len){
                state[nums[i] - 1] = true;
            }
        }

        for(int i=0; i<nums.size(); ++i){
            if(!state[i]){
                return i + 1;
            }
        }
        return len + 1;
    }
    // 原地哈希表; 记录1-N出现的情况； 重复利用现有数组
    int firstMissingPositive(vector<int>& nums){
        for(int i=0; i<nums.size(); ++i){
            while(nums[i] != i + 1){
                if(nums[i] <= 0 || nums[i] > nums.size() || nums[i] == nums[nums[i]-1])
                    break;
                // 将nums[i]放置到对应位置上[1, 2, 3...]
                int idx = nums[i] - 1;
                nums[i] = nums[idx];
                nums[idx] = idx + 1;
            }
        }
        for(int i=0; i<nums.size(); ++i){
            if(nums[i] != (i + 1)){
                return (i + 1);
            }
        }
        return nums.size() + 1;
    }
};
```

##### 42接雨水问题

​	思路：单调栈的应用;这里采用的是垂直切割，当然也可以水平切割

```C++
class Solution {
public:
    int trap(vector<int>& height) {
        // 定义left[i]为index=i左侧的柱状图最大值
        // 定义right[i]为index=i右侧的柱状图最大值
        vector<int> left(height.size(), 0);
        vector<int> right(height.size(), 0);

        int maxVal = height[0];
        for(int i=1; i<height.size(); ++i){
            left[i] = maxVal;
            if(maxVal < height[i]){
                maxVal = height[i];
            }
        }

        maxVal = height[height.size() - 1];
        for(int i=height.size()-2; i>=0; --i){
            right[i] = maxVal;
            if(height[i] > maxVal){
                maxVal = height[i];
            }
        }

        int waterArea = 0;
        for(int i=0; i<height.size(); ++i){
            if(min(left[i], right[i]) > height[i]){
                // 面积公式
                waterArea += min(left[i], right[i]) - height[i];
            }
        }
        return waterArea;
    }
};
```

##### 43字符串相乘

​	比如字符串"2" 和字符串"3"相乘---> 2 * 3 = 6--->result = "6"; 感悟，还是对基本的运算原理总结不到位，对位相乘，其结果保存在i+j+1位上，只不过需要考虑进位而已

```C++
class Solution {
public:
    // 内置方式; 会严重溢出
    using ll = long long;
    string multiply1(string num1, string num2) {
        ll n1 = atoi(num1.c_str());
        ll n2 = atoi(num2.c_str());
        ll ret = n1 * n2;
        return to_string(ret);
    }
    // 根据注释：注意：不能使用任何内置的 BigInteger 库或直接将输入转换为整数。
    // 采用直接对字符串模拟乘法 
    string multiply(string num1, string num2){
        int len1 = num1.size(), len2 = num2.size();
        vector<int> arr(len1 + len2, 0);
        for(int i=len1-1; i>=0; i--){
            for(int j=len2-1; j>=0; j--){
                int n1 = num2[j] - '0';
                int n2 = num1[i] - '0';
                int res = n1 * n2;
                arr[i+j+1] += res; // 这里按位保存，并未进位
            }
        }

        for(int i=arr.size()-1; i>0; i--){
            if(arr[i] >= 10){
                arr[i-1] += arr[i] / 10;
            }
            arr[i] %= 10;
        }

        string ans;
        int i = 0; // 判断高位是否为0
        while(i < arr.size() && arr[i] == 0){
            i++;
        }
        if(i == arr.size()){
            return "0";
        }
        for(;i<arr.size(); ++i){
            ans.push_back(arr[i] + '0');
        }
        return ans;
    }
};
```

##### 45跳跃游戏II

```C++
class Solution {
public:
    int jump(vector<int>& nums) {
        int fstp = 0, cnt = 0;
        while(fstp < nums.size() - 1){
            int estp = fstp + nums[fstp]; // 当前跳到最远的地方
            if(estp >= nums.size() - 1){
                return ++cnt;
            }
            int maxend = estp;  // 记录能跳到最远的地方
            for(int i = fstp + 1; i <= estp; ++i){
                if(i + nums[i] > maxend){
                    fstp = i;
                    maxend = i + nums[i];
                }
            }
            ++cnt;
        }
        return cnt;
    }
};
```

##### 46全排列

​	思想，回溯算法 + 状态记忆矩阵

```C++
class Solution {
public:
    vector<vector<int>> permute(vector<int>& nums) {
        vector<vector<int>> ans;
        vector<int> path;
        back(nums, ans, path);
        return ans;
    }

private:
    bool state[6] = {false};
    void back(vector<int>& nums, vector<vector<int>>& ans,  vector<int>& path){
        if(path.size() == nums.size()){
            ans.push_back(path);
            return;
        }

        for(int i=0; i<nums.size(); ++i){
            if(!state[i]){
                state[i] = true;
                path.push_back(nums[i]);
                back(nums, ans, path);
                state[i] = false;
          /*    while(i < nums.size() - 1 && path.back() == nums[i+1]){ // 去重
                    ++i;
                }
          */ 去重步骤； 去重前提是有序
                path.pop_back();
            }
        }
    }
};
```

##### 48旋转图像

​	利用转置和镜像规则

```C++
class Solution {
public:
    void rotate(vector<vector<int>>& matrix) {
        transpose(matrix);
        minor(matrix);
    }

private:
    void transpose(vector<vector<int>>& matrix){
        // 实现A^T功能---> a[i][j] swap with a[j][i]
        int n = matrix.size();
        for(int i=0; i<n; ++i){
            for(int j = i + 1; j < n; ++j){
                swap(matrix[i][j], matrix[j][i]);
            }
        }
    }

    void minor(vector<vector<int>>& matrix){
        int n = matrix.size();
        for(int i=0; i<n; ++i){
            for(int j=0; j<n/2; ++j){
                swap(matrix[i][j], matrix[i][n-1-j]);
            }
        }
    }
};
```

##### 50 Power(x, n)

​	难点在于处理边界问题，特别是n=-(2^31)时的处理

```C++
// 非递归版本是 位运算的方式，每次折半一样
class Solution {
public:
    double myPow(double x, int n) {
        if(n < 0){
            if(n == INT_MIN){
                return 1. / (myPow(x, -(n + 1)) * x);
            }
            return 1. / myPow(x, -n);
        }

        if(n == 1){
            return x;
        }

        if(n == 0){
            return 1;
        }

        if(n % 2 == 0){
            double ans = myPow(x, n / 2);
            return ans * ans; // 注意这步递归的写法
        }else{
            double ans = myPow(x, n / 2);
            return ans * ans * x;
        }
    }
};
```

##### 53最大连续子数组和

​	贪心和dp，核心思想就是正的要，负的是负担

```C++
class Solution {
public:
    // 贪心
    int maxSubArray1(vector<int>& nums) {
        int maxVal = nums[0];
        int maxTmp = nums[0];
        for(int i=1; i<nums.size(); ++i){
            if(maxTmp <= 0)
                maxTmp = nums[i];
            else
                maxTmp += nums[i];
        
            if(maxVal < maxTmp)
                maxVal = maxTmp;
            
        }
        return maxVal;
    }

    // dp
    int maxSubArray2(vector<int>& nums){
        vector<int> dp(nums.size(), 0);
        // 定义dp[i]为以nums[i]结尾连续子数组的最大和
        int maxVal = nums[0];
        dp[0] = nums[0];
        for(int i=1; i<nums.size(); ++i){
            if(dp[i-1] < 0)
                dp[i] = nums[i];
            else
                dp[i] = nums[i] + dp[i-1];
            if(maxVal < dp[i])
                maxVal = dp[i];
        }
        return maxVal;
    }
    
    // dp的数组可以优化

    int maxSubArray(vector<int>& nums){
        
        // 定义dp[i]为以nums[i]结尾连续子数组的最大和
        int maxVal = nums[0];
        int dp0 = nums[0], dp1 = 0;
        for(int i=1; i<nums.size(); ++i){
            if(dp0 < 0)
                dp1 = nums[i];
            else
                dp1 = nums[i] + dp0;
            if(maxVal < dp1)
                maxVal = dp1;
            
            dp0 = dp1;
        }
        return maxVal;
    }

};
```

##### 56合并区间

​	要考虑好相交、包含(包含意味着尾端值的确定)等

```C++
class Solution {
public:
    vector<vector<int>> merge(vector<vector<int>>& intervals) {
        this->sort(intervals);
        vector<vector<int>> ans;
        int fidx = 0, eidx = 0;
        while(fidx < intervals.size()){
            int end = intervals[eidx][1];
            while(eidx + 1 < intervals.size() && end >= intervals[eidx+1][0]){
                ++eidx;
                end = max(end, intervals[eidx][1]); // 要维持好尾部的最大值，未必是intervals[eidx]][1]
            }
            ans.push_back({intervals[fidx][0], end});
            fidx = eidx = eidx + 1; 
        }
        return ans;
    }

private:
    void sort(vector<vector<int>>& intervals){
        ::sort(intervals.begin(), intervals.end(), cmp); // 升序排列
    }

    static bool cmp(const vector<int>& lhs, const vector<int>& rhs){
        return lhs[0] < rhs[0];
    }
};
```

##### 57插入区间

​	采用遍历方式吧，即使二分，插入的复杂度还是O(n);

```C++
class Solution {
public:
    vector<vector<int>> insert(vector<vector<int>>& intervals, vector<int>& newInterval){
        // 遍历方式吧
        vector<vector<int>> ans;
        int i, j;
        for(i=0; i<intervals.size(); ++i){
            if(intervals[i][1] < newInterval[0]){
                ans.push_back(intervals[i]);
            }else{ // intervals[i][1] >= newInterval[0];
                 if(newInterval[1] < intervals[i][0]){
                     ans.push_back(newInterval); // 缝隙插入
                     j = i;
                 }else if(newInterval[1] <= intervals[i][1]){
                     ans.push_back({min(newInterval[0], intervals[i][0]), intervals[i][1]});
                     j = i + 1;
                 }else{
                     j = i + 1;
                     while(j < intervals.size() && intervals[j][0] <= newInterval[1]){
                         ++j;
                     }
                     ans.push_back({min(newInterval[0], intervals[i][0]), max(intervals[j-1][1], newInterval[1])});
                 }
                 
                 for(; j<intervals.size(); ++j){
                     ans.push_back(intervals[j]);
                 }
                 return ans;
            }
        }
        ans.push_back(newInterval); // 这里是没有插入的
        return ans;
    }
};
```

##### 58最后单词的长度

```C++
class Solution {
public:
    int lengthOfLastWord(string s) {
        int idx = s.size() - 1;
        while(idx >= 0 && s[idx] == ' ')
            --idx;
        int end = idx;
        while(idx >=0 && s[idx] != ' '){
            --idx;
        }
        return end - idx;
    }
};
```

59旋转矩阵

​	采用计数的方式进行，需要注意边界问题。到底哪些是闭合，哪些不是

```C++
class Solution {
public:
    vector<vector<int>> generateMatrix(int n) {
        int totalCnt = n * n;
        vector<vector<int>> spinMatrix(n, vector<int>(n, -1));
        int cnt = 0;
        int i = -1, j = -1;
        while(cnt < totalCnt){
            ++i, ++j;
            int board = i;
            // 左闭右闭
            for(; j < n - board; ++j){
                spinMatrix[i][j] = cnt + 1;
                ++cnt;
            }

            ++i, --j;
            for(; i < n - board; ++i){
                spinMatrix[i][j] = cnt + 1;
                ++cnt;
            }
            --i, --j;
            for(; j >= board; --j){
                spinMatrix[i][j] = cnt + 1;
                ++cnt;
            }

            --i, ++j;
            for(; i > board; --i){
                spinMatrix[i][j] = cnt + 1;
                ++cnt;
            }
        }
        return spinMatrix;
    }
};
```

##### 61旋转链表

```C++
class Solution {
public:
    ListNode* rotateRight(ListNode* head, int k) {
        if(head == nullptr) return head;
        size_t len = length(head); // 计算长度
        int modK = k % len;       // 只用考虑一个长度内的，取余
        if(len == 1 || modK == 0) return head;
        // 上述都是边界问题
        ListNode* fast = head, *slow = head;
        while(modK--){
            fast = fast->next;
        }
        // 快慢指针定位头结点和尾节点
        while(fast->next){ 
            fast = fast->next;
            slow = slow->next;
        }
        ListNode* newHead = slow->next;
        fast->next = head;
        slow->next = nullptr;
        return newHead;
    }

private:
    size_t length(ListNode* head){
        int cnt = 0;
        while(head){
            ++cnt;
            head = head->next;
        }
        return cnt;
    }
};

// 63 有障碍版本的不同路径数
class Solution {
public:
    int uniquePathsWithObstacles(vector<vector<int>>& obstacleGrid) {
        int m = obstacleGrid.size(), n = obstacleGrid[0].size();
        vector<vector<int>> dp(m, vector<int>(n, 0));
        // 初始化
        for(int i = 0; i < m; ++i){
            if(obstacleGrid[i][0] != 1){
                if(i == 0 || (i > 0 && dp[i-1][0])){
                    dp[i][0] = 1;
                }
            }
        }

        for(int j = 1; j < n; ++j){
            if(obstacleGrid[0][j] != 1 && dp[0][j-1]){
                dp[0][j] = 1;
            }
        }

        for(int i=1; i<m; ++i){
            for(int j=1; j<n; ++j){
                if(obstacleGrid[i][j] != 1){
                    dp[i][j] = dp[i-1][j] + dp[i][j-1];
                }
            }
        }
        return dp[m-1][n-1];
    }
};
```

##### 66加一

```C++
class Solution {
public:
    vector<int> plusOne(vector<int>& digits) {
        int flag = 0;
        for(int j=digits.size() - 1; j >= 0; j--){
            if(j == digits.size() - 1){
                if(digits[j] + 1 >= 10){
                    flag = 1;
                    digits[j] = (digits[j] + 1) % 10;
                }else{
                    digits[j]++;
                }
            }else if(flag == 1){
                if(digits[j] + 1 >= 10){
                    flag = 1;
                    digits[j] = (digits[j] + 1) % 10;
                }else{
                    digits[j]++;
                    flag = 0;
                }
            }

            if(flag == 0){
                return digits;
            }
        }
        digits.insert(digits.begin(), 1);
        return digits;
    }
};
```

##### 71简化路径

​	将一个unix路径简化成一个标准的绝对路径

```C++
class Solution {
public:
    string simplifyPath(string path) {
        // 处理三类.; 
        string ans;
        ans.push_back('/');
        for(int i=0; i<path.size(); ++i){
            if(path[i] == '.'){
                int cnt = 0;
                while(i < path.size() && path[i] == '.'){
                    ++cnt;
                    ++i;
                }
                if(cnt == 1 && ((i < path.size() && path[i] == '/' && ans.back() == '/') || i == path.size())){
                    continue;
                }else if(cnt == 2 && ans.back() == '/' && ((i < path.size() && path[i] == '/') || i == path.size())){
                    if(ans.size() > 1)
                        ans.pop_back();
                    while(ans.size() > 1 && ans.back() != '/'){
                        ans.pop_back();
                    }
                }else{
                    ans.append(cnt, '.');
                    while(i < path.size() && path[i] != '/'){
                        ans.push_back(path[i]);
                        ++i;
                    }
                    ans.push_back('/');
                }
            }else if(path[i] == '/'){
                if(ans.back() == '/'){
                    continue; // 处理连续的///
                }else if(i + 1 < path.size()){
                    ans.push_back(path[i]);
                }
            }else{
                ans.push_back(path[i]);
            }
        }
        if(ans.size() > 1 && ans.back() == '/')
            ans.pop_back();
        return ans;
    }
};
```

##### 75颜色分类

```C++
class Solution {
public:
    void sortColors(vector<int>& nums) {
        int colors[3] = {0};
        for(auto& elem : nums){
            ++colors[elem]; // 计数的方式
        }
        // 覆盖方式
        for(int i=0; i<nums.size(); ++i){
            if(i < colors[0]){
                nums[i] = 0;
            }else if(i < colors[0] + colors[1]){
                nums[i] = 1;
            }else{
                nums[i] = 2;
            }
        }
    }
};
```

##### 76最小覆盖子串

​	关键是自己的理解出了点问题，不用考虑是不是重复的字母，移除即可，通过count数组来判断

```C++
class Solution {
public:
    string minWindow(string s, string t) {
        // 边界判断
        if(s.size() < t.size()){
            return "";
        }
        int count[128] = {0};
        // 统计匹配字符串中各字符的数量
        for(auto& elem : t){
            ++count[elem]; 
        }
        int needCnt = t.size();
        int len = INT_MAX, start = 0;
        // 滑动窗口思想
        for(int i = 0, j = 0; i < s.size() && j < s.size();){
            while(j < s.size() && needCnt > 0){
                if(count[s[j]] > 0){
                    --needCnt;
                }
                --count[s[j]];  // 这里考虑了很多个重复字符的问题
                ++j;
            }

            // 上述循环出来有两种可能，j = s.size() 或者needCnt = 0;
            while(i < s.size() && count[s[i]] < 0){
                ++count[s[i]]; // 这里是不在t中的字符
                ++i;
            }

            if(j - i < len && needCnt == 0){
                start = i;
                len = j - i;
            }

            // 从窗口头部移除一个
            count[s[i]]++;
            ++i;
            needCnt++;
        }
        return len == INT_MAX ? "" : s.substr(start, len);
    }
};
```

##### 77组合问题

​	组合、排列可以考虑回溯算法，回溯本质就是暴力穷举

```C++
class Solution {
public:
    vector<vector<int>> combine(int n, int k) {
        vector<vector<int>> ans;
        vector<int> path;
        back(ans, path, 1, n, k);
        return ans;
    }

private:
    void back(vector<vector<int>>& ans, vector<int>& path, int startidx, int& n, int k){
        if(path.size() == k){
            ans.push_back(path);
            return;
        }

        for(int i=startidx; i<=n; ++i){
            path.push_back(i);
            back(ans, path, i + 1, n, k);
            path.pop_back();
        }
    }
};
```

##### 79单词搜索

​	记忆矩阵 + 深搜

```C++
class Solution {
public:
    bool exist(vector<vector<char>>& board, string word) {
        if(board.empty() || board[0].empty()) return false;
        int m = board.size(), n = board[0].size();
        vector<vector<bool>> state(m, vector<bool>(n, false));
        for(int i=0; i<m; ++i){
            for(int j=0; j<n; ++j){ // if第一个条件起到剪枝操作
                if(board[i][j] == word[0] && dfs(board, state, word, i, j, 0)){
                    return true;
                }
            }
        }
        return false;
    }


private:
    bool dfs(vector<vector<char>>& board, vector<vector<bool>>& state, string& word, int i, int j, int widx){
        // 先判断结果
        if(widx >= word.size()){
            return true;
        }

        if(i < 0 || i >= state.size() || j < 0 || j >= state[0].size()){
            return false;
        }

        if(state[i][j] || board[i][j] != word[widx]){
            return false;
        }

        state[i][j] = true;
        bool upRet = dfs(board, state, word,  i - 1, j, widx + 1);
        bool downRet = dfs(board, state, word, i + 1, j, widx + 1);
        bool leftRet = dfs(board, state, word, i, j - 1, widx + 1);
        bool rightRet = dfs(board, state, word, i, j + 1, widx + 1);
        state[i][j] = false;
        return upRet || downRet || leftRet || rightRet;
    }
};
```

##### 80.删除有序数组的重复项

​	通常采用原地覆盖方式--->快慢指针方式

```C++
class Solution {
public:
    int removeDuplicates(vector<int>& nums) {
        // 覆盖方式，在一个有序数组中，重复出现的元素个数最多是二次
        int freeIdx = 1;
        for(int i=1; i<nums.size(); ++i){
            if(nums[i] == nums[i-1]){
                while(i + 1 < nums.size() && nums[i+1] == nums[i]){
                    ++i;
                }
            }
            nums[freeIdx++] = nums[i];
        }  
        return freeIdx;
    }
};
```

##### 81.搜索螺旋矩阵II

​	关键是分门别类的考虑target所处范围，大区间，小区间，混合区间

```C++
class Solution {
public:
    bool search(vector<int>& nums, int target) {
        // 螺旋数组，部分有序条件下的二分查找应用
        int left = 0, right = nums.size() - 1;
        while(left <= right){
            int mid = left + (right - left) / 2;
            if(nums[mid] == target)
                return true;
            else if(nums[left] < nums[mid]){ // 在数值大的一部分区间里
                if(nums[left] <= target && target < nums[mid]){
                    right = mid - 1;
                }else{
                    left = mid + 1;
                }
            }else if(nums[mid] < nums[right]){ // 在数值小的一部分区间里
                if(nums[mid] < target && target <= nums[right]){
                    left = mid + 1;
                }else{
                    right = mid - 1;
                }
            }else{
                if(nums[left] == nums[mid]){
                    ++left;
                }

                if(nums[right] == nums[mid]){
                    --right;
                }
            }
        }
        return false;
    }
};
```

##### 82删除排序链表中的重复元素II

这里突然来了灵感，感觉可以划分成多个子问题，因此使用了递归方式。关键是边界条件要判决好;

​	也可以采用标记法

```C++
class Solution {
public:
    // 递归方式
    ListNode* deleteDuplicates(ListNode* head) {
        // 有重复的节点都删除
        if(head == nullptr) return head;
        if(head->next == nullptr) return head;
        if(head->val != head->next->val){
            head->next = deleteDuplicates(head->next);
        }else{
            while(head && head->next && (head->val == head->next->val)){
                int tmp = head->val;
                while(head && head->val == tmp){
                    head = head->next;
                }
            }
            if(head){
                head->next = deleteDuplicates(head->next);
            }
        }
        return head;
    }
};
```

##### 83.删除链表重复元素I

​	链表中使用递归是yyds

```C++
class Solution {
public:
    ListNode* deleteDuplicates(ListNode* head) {
        if(head == nullptr || head->next == nullptr) return head;
        if(head->val != head->next->val)
            head->next = deleteDuplicates(head->next);
        else{
            ListNode* curr = head->next;
            while(curr && curr->val == head->val){
                curr = curr->next;
            }
            head->next = deleteDuplicates(curr);
        }
        return head;
    }
};
```

##### 84柱状图中最大矩形的值

```C++
class Solution {
public:
    int largestRectangleArea(vector<int>& heights) {
        int maxArea = 0;
        heights.push_back(0); 
        heights.insert(heights.begin(), 0);
        stack<int> stk;
        stk.push(0);
        for(int i=1; i<heights.size(); ++i){
            if(heights[i] < heights[stk.top()]){
                // i是stk.top右侧第一个比其的矮的索引,
                while(!stk.empty() && heights[i] < heights[stk.top()]){
                    int mid = stk.top();
                    stk.pop();
                    if(!stk.empty()){
                        int left = stk.top();  // 左侧值
                        maxArea = max(maxArea, (i - left - 1) * heights[mid]);
                    }
                }
            }
            stk.push(i);
        }
        return maxArea;
    }
};
```

##### 88合并两个有序数组

```C++
class Solution {
public:
    // copy_backward思想
    void merge(vector<int>& nums1, int m, vector<int>& nums2, int n) {
        int idx1 = m - 1, idx2 = n - 1, idx = m + n - 1;
        while(idx >= 0){
            if(idx1 < 0){
                nums1[idx--] = nums2[idx2--];
            }else if(idx2 < 0){
                nums1[idx--] = nums1[idx1--];
            }else if(nums1[idx1] < nums2[idx2]){
                nums1[idx--] = nums2[idx2--];
            }else{
                nums1[idx--] = nums1[idx1--];
            }
        }
    }
};
```

##### 90子集II

```C++
class Solution {
public:
    vector<vector<int>> subsetsWithDup(vector<int>& nums) {
        sort(nums.begin(), nums.end());
        vector<vector<int>> ans;
        vector<int> path;
        back(nums, ans, path, 0);
        return ans;
    }

private:
    void back(vector<int>& nums, vector<vector<int>>& ans, vector<int>& path, int startIdx){
        ans.push_back(path);
        if(startIdx == nums.size()) return;
        for(int i=startIdx; i<nums.size(); ++i){
            path.push_back(nums[i]);
            back(nums, ans, path, i + 1);
            while(i + 1 < nums.size() && nums[i+1] == path.back())  ++i;
            path.pop_back();
        }
    }
};
```

##### 91解码方法

​	解决字符串解码问题，实际上就是DP，简单

```C++
class Solution {
public:
    int dp[100 + 2] = {0};
    int numDecodings(string s) {
        // 解码方法, DP; dp[i]表示长度为i的解码方式; 类似于青蛙跳台阶
        dp[0] = dp[1] = 1;
        if(s[0] == '0') return 0;
        for(int i=2; i<=s.size(); ++i){
            if(s[i-1] == '0'){
                if(Isvalid(s, i-2, i-1)) {
                    dp[i] = dp[i-2];
                }else{
                    return 0;
                }
            }else{
                if(Isvalid(s, i-2, i-1)){
                    dp[i] = dp[i-1] + dp[i-2];
                }else{
                    dp[i] = dp[i-1];
                }
            }
        }
        return dp[s.size()];
    }

private:
    bool Isvalid(string& s, int i, int j){
        if(s[i] == '0'){
            return false;
        }
        int nums = 0;
        while(i <= j){
            nums = nums * 10 + s[i] - '0';
            ++i;
        }
        return 0 < nums && nums < 27;
    }
};
```

##### 92反转链表II

```C++
class Solution {
public:
    ListNode* reverseBetween(ListNode* head, int left, int right) {
        if(left == right) return head;
        ListNode* dummy = new ListNode(-1);
        dummy->next = head;
        ListNode* pre = dummy, *newHead = head, *tail = nullptr;
        int num = right - left;
        while(--left){
            pre = newHead;
            newHead = newHead->next;
        }
        tail = newHead;
        while(num--){
            tail = tail->next;
        }
        ListNode* tmp = tail->next;
        tail->next = nullptr;
        reverse(newHead);
        pre->next = tail;
        newHead->next = tmp;
        return dummy->next;
    }

private:
    ListNode* reverse(ListNode* head){
        if(head->next == nullptr) return head;
        ListNode* p = reverse(head->next);
        p->next = head;
        return head;
    }
};
```

##### 93有效IP位

​	回溯 + 剪枝

```C++
class Solution {
public:
    vector<string> restoreIpAddresses(string s) {
        int len = s.size();
        vector<string> ans;
        vector<int> path;
        if(len < 4 || len > 12) return ans;
        back(s, ans, path, 0);
        return ans; 
    }
private:
    void back(string& s, vector<string>& ans, vector<int>& path, int startidx){
        // 采用闭区间方式
        if(startidx == s.size()){
            if(path.size() == 4)
                push(ans, path);// 收割答案
            return;
        }
        
        for(int i=startidx; i < startidx+3 && (s.size() - 1 -i <= 12 - 3 * path.size()); ++i){
            if(IsValid(path, s, startidx, i)){ // s[startidx, i]闭区间
                back(s, ans, path, i + 1);
                path.pop_back();
            }
        }
    }

    bool IsValid(vector<int>& path, string& s, int l, int r){
        if(s[l] == '0' && l < r)
            return false; // 前导零
        int val = 0;
        while(l <= r){
            val = val * 10 + s[l] - '0';
            ++l;
        }
        bool ret = (val >= 0 && val <= 255);
        if(ret) path.push_back(val);
        return ret;
    }

    void push(vector<string>& ans, vector<int>& path){
        string s;
        for(int i=0; i<path.size(); ++i){
            s += to_string(path[i]);
            if(i < 3)
                s.push_back('.');
        }
        ans.push_back(s);
    }
};
```

##### 95.不同的二叉搜索树

```C++
class Solution {
public:
    // 递归方式，构造所有的BST
    vector<TreeNode*> generateTrees(int n) {
        if(n < 1) return {nullptr};
        return generateTrees(1, n);
    }

private:
    // 问题拆分，回溯方式。以i为根节点的BST, 则[1, i-1]的元素构成的左子树, [i + 1, n]构成的右子树。各选一个进行组合即可。
    vector<TreeNode*> generateTrees(int start, int end) {
        if(start > end){
            return {nullptr};
        }

        vector<TreeNode*> allTrees;
        for(int i = start; i<=end; ++i){
            // 获得所有可行的左子树
            vector<TreeNode*> leftTrees = generateTrees(start, i - 1);
            // 获得所有可行的右子树
            vector<TreeNode*> rightTrees = generateTrees(i + 1, end);
            // 合并
            
            for(int j=0; j<leftTrees.size(); ++j){
                for(int k=0; k<rightTrees.size(); ++k){
                    TreeNode* root = new TreeNode(i);
                    root->left = leftTrees[j];
                    root->right = rightTrees[k];
                    allTrees.push_back(root);
                }
            }
        }
        return allTrees;
    }
};
```

##### 96.不同的BST数量-->组成问题

```C++
class Solution {
public:
    // 本题的本质就是求n个节点可以构成结构，实际上与结点的数值没有很大关系
    int numTrees(int n) {
        if(n < 0) return 0;
        // return count(1, n);
        const int len = 20;
        int dp[len] = {0}; // dp[i]表示i个结点构成的树结构数量
        dp[0] = 1;
        for(int i=1; i<=n; ++i){
            for(int j=0; j <=i-1; ++j){
                dp[i] += dp[j] * dp[i-1-j];
            }
        }
        return dp[n];
    }

private:

    int count(int start, int end){
        //[start, end] 构成不同的BST数量
        if(start >= end) return 1;
        int Cnt = 0;
        for(int i=start; i<=end; ++i){
            int lCnt = count(start, i - 1); // 递归造成了很多冗余
            int rCnt = count(i + 1, end); // 递归造成了很多冗余
            Cnt += lCnt * rCnt;
        }
        return Cnt;
    }
};
```

##### 105.从前序和中序中构造二叉树

```C++
class Solution {
public:
    TreeNode* buildTree(vector<int>& preorder, vector<int>& inorder) {
        if(preorder.empty()) return nullptr;
        return construct(preorder, 0, preorder.size()-1, inorder, 0, inorder.size()-1);
    }

private:
    TreeNode* construct(vector<int>& preorder, int pl, int pr, vector<int>& inorder, int il, int ir){
        // 前序：中左右；  中序：左中右
        if(pr < pl) return nullptr;
        TreeNode* root = new TreeNode(preorder[pl]);
        // 通过前序中的根节点再中序中分割
        int imid = il;
        while(imid <= ir){
            if(inorder[imid] == preorder[pl]) break;
            ++imid;
        }
        root->left = construct(preorder, pl + 1, pl + imid - il, inorder, il, imid - 1);
        root->right = construct(preorder, pl + imid - il + 1, pr, inorder, imid + 1, ir);
        return root;
    }
};
```

##### 106.有序数组构造二叉树

​	递归方式

```C++
class Solution {
public:
    TreeNode* sortedArrayToBST(vector<int>& nums) {
        return construct(nums, 0, nums.size() - 1);
    }

// 递归方式， 中间二分
private:
    TreeNode* construct(vector<int>& nums, int left, int right){
        if(left > right) return nullptr;
        if(left == right) return new TreeNode(nums[left]);
        int mid = left + (right - left ) / 2;
        TreeNode* root = new TreeNode(nums[mid]);
        root->left = construct(nums, left, mid - 1);
        root->right = construct(nums, mid + 1, right);
        return root;
    }
};
```

##### 109有序链表转化为平衡BST

​	// 双指针思路

```C++
class Solution {
public:
    TreeNode* sortedListToBST(ListNode* head) {
        return construct(head, nullptr);
    }

private:
    TreeNode* construct(ListNode* head, ListNode* tail){
        // 左闭右开
        if(!head || head == tail) return nullptr;
        ListNode* fast = head, *slow = head;
        while(fast != tail){
            fast = fast->next;
            if(fast != tail){
                fast = fast->next;
                slow = slow->next;
            }
        }
        TreeNode* root = new TreeNode(slow->val);
        root->left = construct(head, slow);
        root->right = construct(slow->next, tail);
        return root;
    }
};
```

##### 114.二叉树链表化

​	借助栈的思想

```C++
class Solution {
public:
    void flatten(TreeNode* root) {
        // 栈的思想，先序
        if(!root) return;
        stack<TreeNode*> stk;
        stk.push(root);
        TreeNode* dummy = new TreeNode(-1);
        TreeNode* head = dummy;
        while(!stk.empty()){
            head->right = stk.top();
            head->left = nullptr;
            head = head->right;
            stk.pop();
            if(head->right) stk.push(head->right);
            if(head->left) stk.push(head->left);
        }
        delete dummy;
    }
};
```

##### 116.填充每个结点的下一个右侧节点指针

​	思路:看到水平连线，瞬间想到层序遍历

```C++
class Solution {
public:
    Node* connect(Node* root) {
        // FIFO
        if(!root) return root;
        queue<Node*> mq;
        mq.push(root);
        while(!mq.empty()){
            int len = mq.size();
            while(len--){
                Node* top = mq.front();
                mq.pop();
                if(len){ // 不能队列是否为空判断
                    top->next = mq.front();
                }
                if(top->left)   mq.push(top->left);
                if(top->right)  mq.push(top->right);
            }
        }
        return root;
    }
};
```



##### 118杨辉三角

```C++
class Solution {
public:
    vector<vector<int>> generate(int numRows) {
        // 生成
        vector<vector<int>> ans;
        for(int i=0; i<numRows; ++i){
            ans.push_back(vector<int>(i + 1, 1));
        }
        // 填充
        for(int i=2; i<numRows; ++i){
            for(int j=1; j<i; ++j){
                ans[i][j] = ans[i-1][j] + ans[i-1][j-1];
            }
        }
        return ans;
    }
};

// 杨辉三角II, 输出某一行
class Solution {
public:
    vector<int> getRow(int rowIndex) {
        vector<int> ans(rowIndex + 1, 1);
        if(rowIndex < 2) return ans;
        for(int i=2; i<=rowIndex; ++i){
            for(int j=i-1; j > 0; j--){
                ans[j] = ans[j] + ans[j-1]; // 倒着来，总结出这个规律
            }
        }
        return ans;
    }
};
```

##### 120三角形最小路径和

```C++
class Solution {
public:
    int minimumTotal1(vector<vector<int>>& triangle) {
        int ans = INT_MAX;
        findLayerPathMin(triangle, 0, 0, 0, ans);
        return ans;
    }

    int minimumTotal(vector<vector<int>>& triangle) {
        if(triangle.size() == 1) return triangle[0][0];
        // 是不是可以考虑dp;
        vector<vector<int>>& dp = triangle;
        int ans = INT_MAX;
        for(int i=1; i<triangle.size(); ++i){
            dp[i][0] = dp[i-1][0] + triangle[i][0];
            for(int j=1; j<i; ++j){
                dp[i][j] = min(dp[i-1][j-1], dp[i-1][j]) + triangle[i][j];
            }
            dp[i][i] = dp[i-1][i-1] + triangle[i][i];
        } 
        for(int j=0; j<triangle.size(); ++j){
            ans = min(ans, triangle.back()[j]);
        }
        return ans;
    }

private:
    // dfs会超时
    void findLayerPathMin(vector<vector<int>>& triangle, int i, int j, int pathSum, int& ans){
        if(i == triangle.size()){
            if(pathSum < ans){
                ans = pathSum;
            }
            return;
        }
        if(j >= triangle[i].size()){
            return;
        }

        findLayerPathMin(triangle, i + 1, j, pathSum + triangle[i][j], ans);
        findLayerPathMin(triangle, i + 1, j + 1, pathSum + triangle[i][j], ans);
    }
};
```

##### LC128最长连续序列

​	o(n)需要借助哈希表，枚举起点的位置。

```C++
class Solution {
public:
    int longestConsecutive(vector<int>& nums) {
        unordered_set<int> uset;
        int len = 0;
        for(auto& elem : nums) uset.insert(elem);
        for(auto beg = uset.begin(); beg != uset.end(); ++beg){
            int elem = *beg;
            if(uset.find(elem - 1) == uset.end()){
                int cnt = 1;
                int tmp = elem + 1;
                while(uset.find(tmp) != uset.end()){
                    ++cnt;
                    ++tmp;
                }
                if(len < cnt){len = cnt;}
            }
        }
        return len;
    }
};
```

##### LC152 最大乘积子数组

```C++
/* 维护区间内的最大乘积和最小乘积， 采用DP思想。 max(f(n)) = max(max(f(n-1)) * nums[n], min(f(n-1)) * nums[n])   */
class Solution {
public:
    int maxProduct(vector<int>& nums) {
        // 乘积最大的子数组, max(f(n)) = max(max(f(n-1)) * n, min(f(n-1)) * n)
        int maximum = nums[0], minimum = nums[0], res = nums[0];
        for(int i=1; i<nums.size(); ++i){
            if (nums[i] < 0){
                swap(maximum, minimum); // 来了负号，就交换
            }
            maximum = max(maximum * nums[i], nums[i]);
            minimum = min(minimum * nums[i], nums[i]);
            res = max(maximum, res);
        }
        return res;
    }
};
```

##### LC164最大间距

​	给定一个无序的数组 `nums`，返回 *数组在排序之后，相邻元素之间最大的差值* 。如果数组元素个数小于 2，则返回 `0` 。

您必须编写一个在「线性时间」内运行并使用「线性额外空间」的算法。

​	<font color="red">基数排序，可以实现O(N)时间复杂度的排序?</font>

```C++
class Solution {
public:
    int maximumGap(vector<int>& nums) {
        int n = nums.size();
        if(n < 2) return 0;
        if(n == 2) return abs(nums[0] - nums[1]);

        int exp = 1;
        vector<int> buf(n);
        int maxVal = *max_element(nums.begin(), nums.end()); // 选出最大值
        while(maxVal >= exp){
            vector<int> cnt(10);
            for(int i=0; i<n; ++i){
                int digit = (nums[i] / exp) % 10;
                cnt[digit]++; // 各数字落在0-9的数量统计
            }

            for(int i=1; i<10; ++i){
                cnt[i] += cnt[i-1]; // 数量累计是什么意思
            }

            for(int i=n-1; i>=0; --i){
                int digit = (nums[i] / exp) % 10;
                buf[cnt[digit] - 1] = nums[i];
                cnt[digit]--;
            }

            copy(buf.begin(), buf.end(), nums.begin());
            exp *= 10;
        }

        int ret = 0;
        for(int i=1; i<n; ++i){
            ret = max(ret, nums[i] - nums[i-1]);
        }
        return ret;
    }
};
```

##### LC167. 有序数组的两数之和

```C++
class Solution {
public:
    vector<int> twoSum(vector<int>& numbers, int target) {
        int n = numbers.size();  
        int lidx = 0, ridx = n - 1;
        while(lidx < ridx){
            int ans = numbers[lidx] + numbers[ridx];
            if(ans == target) return {lidx + 1, ridx + 1};
            else if(ans < target) ++lidx;
            else --ridx;
        }
        return {-1, -1};
    }
};
```

##### LC204 计数质数

​	给定整数 n ，返回 所有小于非负整数 n 的质数的数量 。

```C++
// 标记法 比如说i是质数，那么2i, 3i, 4i, ...都不是质数
class Solution{
public:
    int countPrimes(int n){
        vector<bool> primers(n, true);
        int cnt = 0;
        for(int i=2; i<n; ++i){
            if(primers[i]){
                ++cnt;
                if((long long)i * i < n){
                    for(int j=i; j<n; j+=i){ // 这一步会不会造成重复执行的步骤
                        primers[j] = false;
                    }
                }
            }
        }
        return cnt;
    }
};
```



##### LC208 实现Trie（前缀树)

​	解释：前缀树是一种树形数据结构，用于高效地存储和检索字符串数据集中的键。这一数据结构有相当多的应用场景，例如自动补完和拼写检查。

请你实现Trie类：

- `Trie()` 初始化前缀树对象。

- `void insert(String word)` 向前缀树中插入字符串 `word` 。

- `boolean search(String word)` 如果字符串 `word` 在前缀树中，返回 `true`（即，在检索之前已经插入）；否则，返回 `false` 。

- `boolean startsWith(String prefix)` 如果之前已经插入的字符串 `word` 的前缀之一为 `prefix` ，返回 `true` ；否则，返回 `false` 

  <font color="red">所有单词的搜索都是从字典树的根节点开始的。</font>各个根节点的字符就是我们想要的。

**示例：**

```
输入
["Trie", "insert", "search", "search", "startsWith", "insert", "search"]
[[], ["apple"], ["apple"], ["app"], ["app"], ["app"], ["app"]]
输出
[null, null, true, false, true, null, true]

解释
Trie trie = new Trie();
trie.insert("apple");
trie.search("apple");   // 返回 True
trie.search("app");     // 返回 False
trie.startsWith("app"); // 返回 True
trie.insert("app");
trie.search("app");     // 返回 True
```

```C++
class Trie {
public:
    struct TreeNode{
        bool Isword = false;
        unordered_map<char, TreeNode*> umap;
    };
public:
    Trie() {
        root = new TreeNode();
    }
    
    void insert(string word) {
        TreeNode* curr = root;
        for(auto& elem: word){
            if(curr->umap.find(elem) == curr->umap.end()){
                curr->umap[elem] = new TreeNode();
            }
            curr = curr->umap[elem]; // 节点跳转
        }
        curr->Isword = true;
    }
    
    bool search(string word) {
        TreeNode* curr = root;
        for(auto& elem : word){
            if(curr->umap.find(elem) == curr->umap.end()){
                return false;
            }
            curr = curr->umap[elem];
        }
        return curr->Isword;
    }
    
    bool startsWith(string prefix) {
        TreeNode* curr = root;
        for(auto& elem : prefix){
            if(curr->umap.find(elem) == curr->umap.end()){
                return false;
            }
            curr = curr->umap[elem];
        }
        return true;
    }
private:
    TreeNode* root;
};
```

##### LC213打家劫舍II

​	环问题，转换为非环问题

```C++
class Solution {
 public:
  int robrange(vector<int>& nums){
    if(nums.size() == 0) return 0;
    if(nums.size() == 1) return nums[0];
    vector<int> dp(nums.size(), 0); // dp[i]表示nums[0...i]可以获得的最大利润
    dp[0] = nums[0];
    dp[1] = std::max(nums[0], nums[1]); 
    for(int i = 2; i < nums.size(); ++i){
      dp[i] = std::max(dp[i-2] + nums[i], dp[i-1]);
    }
    return dp[nums.size() - 1];
  }
  int rob(vector<int>& nums) {
    if(nums.size() == 0) return 0;
    if(nums.size() == 1) return nums[0];
    std::vector<int> vec1(nums.begin(), nums.end() - 1);
    std::vector<int> vec2(nums.begin() + 1, nums.end());
    int max1 = robrange(vec1); // 好方法，将环打开
    int max2 = robrange(vec2);
    return std::max(max1, max2);
  }
};
```

##### LC218. 天际线问题

```C++
class Solution {
public:
    vector<vector<int>> getSkyline(vector<vector<int>>& buildings)
    {
        vector<pair<int,long>> sortedBuildings;
        for(auto & building: buildings)
        {
            int left = building[0];
            int right = building[1];
            long height = building[2];
            sortedBuildings.push_back(make_pair(left,-height)); // 存为负数是为了区分左右端点
            sortedBuildings.push_back(make_pair(right,height));
        }

        std::sort(sortedBuildings.begin(),sortedBuildings.end(),[](auto &left,auto &right){return left.first < right.first || (left.first == right.first && left.second < right.second);});
       
        multiset<int,greater<int>> pq;//降序排序
        pq.insert(0); // 开始时，左侧为0
        vector<vector<int>> ans;
        for(auto & build: sortedBuildings)
        {
            int x = build.first;
            long y = build.second;
            int top = *(pq.begin());//取第一个元素，即最大元素
            if(y < 0)//左边界
            {
                y = -y;
                if(y > top)
                {
                    ans.push_back({x,(int)y});
                }
                pq.insert(y);
            }
            else //右边界
            {
                pq.erase(pq.find(y));//只删除重复元素中的一个
                int tmp = *(pq.begin());
                if(top > tmp)   // 为什么只在 top > tmp时记录结果。因为左端点已经记录
                {
                    ans.push_back({x,tmp});
                }
            }
        }
        return ans;
    }
};
```



##### LC228 汇总区间

```C++
class Solution {
public:
    typedef long long ll;
    vector<string> summaryRanges(vector<int>& nums) {
        vector<string> ans;
        int lidx = 0;
        for(int i=0; i<nums.size();){
            int cnt = 0;
            // ll是防止溢出
            while(i <nums.size() && (ll)nums[i] - nums[lidx] == cnt){
                ++i;
                ++cnt;
            }
            if(cnt == 1){
                ans.push_back(to_string(nums[lidx]));
            }else{
                string tmp = to_string(nums[lidx]);
                tmp += "->" + to_string(nums[lidx + cnt - 1]);
                ans.push_back(tmp);
            }
            lidx = i;
        }
        return ans;
    }
};
```

##### LC236二叉树的最近公共祖先

```C++
class Solution {
public:
    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {
        TreeNode** ans = &root;
        last(root, p, q, ans);
        return *ans;
    }

private:
    bool last(TreeNode* root, TreeNode* p, TreeNode* q, TreeNode** ans){
        if(!root) return false;
        bool lret = last(root->left, p, q, ans);
        bool rret = last(root->right, p, q, ans);
        if(lret && rret){
            *ans = root;
            return true;
        }else if(lret || rret){
            if(root->val == p->val || root->val == q->val){
                *ans = root;
            }
            return true;
        }
        return root->val == p->val || root->val == q->val;
    }
};
```

##### LC239滑动窗口的最大值

```C++
class Solution {
public:
    vector<int> maxSlidingWindow(vector<int>& nums, int k) {
        // 维护单调队列
        deque<int> dq;
        int idx = 0;
        for(; idx < k; ++idx){
            if(dq.empty()){
                dq.push_back(nums[idx]);
            }else if(dq.back() >= nums[idx]){
                   dq.push_back(nums[idx]);
            }else{
                while(!dq.empty() && dq.back() < nums[idx]) dq.pop_back();
                dq.push_back(nums[idx]);
            }
        }
        vector<int> ans;
        for(; idx < nums.size(); ++idx){
            ans.push_back(dq.front());
            // 移除元素
            if(nums[idx - k] == dq.front()) dq.pop_front();
            while(!dq.empty() && dq.back() < nums[idx]) dq.pop_back();
            dq.push_back(nums[idx]);
        }
        ans.push_back(dq.front());
        return ans;
    }
};
```

##### LC240搜索二维矩阵II

```C++
class Solution {
public:
    bool searchMatrix1(vector<vector<int>>& matrix, int target) {
        int m = matrix.size(); int n = matrix[0].size();
        for(int i=0; i<m; ++i){
            if(lower_bound(matrix[i], target)) return true;
        }   
        return false;
    }

    bool searchMatrix(vector<vector<int>>& matrix, int target) {
        int m = matrix.size(), n = matrix[0].size();
        int ridx = 0, cidx = n - 1;
        while(ridx < m && cidx >= 0){
            if(matrix[ridx][cidx] == target) return true;
            if(matrix[ridx][cidx] < target) ++ridx;
            else --cidx;
        }
        return false;
    }

private:
    bool lower_bound(vector<int>& nums, int target){
        int lidx = 0, ridx = nums.size() - 1;
        while(lidx <= ridx){
            int mid = lidx + (ridx - lidx) / 2;
            if(nums[mid] == target) return true;
            else if(nums[mid] < target) lidx = mid + 1;
            else ridx = mid - 1;
        }
        return false;
    }
};
```

##### LC303 [区域和检索 - 数组不可变](https://leetcode.cn/problems/range-sum-query-immutable/)

```C++
// 考察对象，前缀和
class NumArray {
public:
    NumArray(vector<int>& nums) {
        for(int i=0; i<nums.size(); ++i){
            pre[i+1] = pre[i] + nums[i];
        }
    }
    
    int sumRange(int left, int right) {
        return pre[right + 1] - pre[left];
    }

private:
    
    int pre[10001] = {0};
};
```

##### LC304 [二维区域和检索 - 矩阵不可变](https://leetcode.cn/problems/range-sum-query-2d-immutable/)

```C++
class NumMatrix {
public:
    NumMatrix(vector<vector<int>>& matrix) {
        int m = matrix.size(), n = matrix[0].size();
        for(int i=0; i<m; ++i){
            for(int j=0; j<n; ++j){
                preSum[i+1][j+1] = preSum[i+1][j] + preSum[i][j+1] - preSum[i][j] + matrix[i][j];
                cout << preSum[i+1][j+1] << " ";
            }
            cout << endl;
        }
        //打印数组
        
    }
    
    int sumRegion(int row1, int col1, int row2, int col2) {
        return preSum[row2+1][col2+1] - preSum[row2 + 1][col1] - preSum[row1][col2 + 1] + preSum[row1][col1];
    }

private:
    int preSum[201][201] = {0};
};
```

##### LC307[区域和检索 - 数组可修改](https://leetcode.cn/problems/range-sum-query-mutable/)

```C++
/*
	1.动态前缀和，动态更新单点
	2.树状数组，查询，更新 logN
树状数组主要的功能是实现单点数值的更新，同时查询某个区间内的值。
*/

const int N = 1e5;
class NumArray {
private:
    int n;
    vector<int> curr;
	int tr[N] = {0};
    
    int lowbit(int x){
        return x&-x;
    }
    
    // 索引从1开始的
    void add(int index, int val){
        for(int i=index; i<=n; i+=lowbit(i)){
            tr[i] += val;
        }
    }
 	
    int query(int index){
        // 1 ~ index的和
        int res = 0;
        for(int i=index; i>0; i-=lowbit(i)){
            res += tr[i];
        }
        return res;
    }
public:
    NumArray(vector<int>& nums) {
        curr = nums;
        n = nums.size();
        memset(tr, 0, sizeof(tr));
        for(int i=0; i<n; ++i){
            add(i + 1, nums[i]);
        }
    }
    
    void update(int index, int val) {
        int delta = val	- curr[index];
        add(index + 1, delta);
        curr[index] = val;
    }
    
    int sumRange(int left, int right) {
        return query(right + 1) - query(left);
    }
};
```

##### LC315 计算右侧小于当前元素的个数

​	在归并的过程中计算逆序对数量，倒序遍历

```C++
class Solution {
public:
    // 超时了，主要原因在于插入节点缓慢
    vector<int> countSmaller1(vector<int>& nums) {
        int len = nums.size();
        vector<int> count(len, 0);
        vector<int> ans;
        ans.reserve(len);
        ans.push_back(nums[len-1]);
        for(int i=len-2; i>=0; --i){
            if(ans.back() < nums[i]){
                count[i] = ans.size();
                ans.push_back(nums[i]);
            }else{
                auto iter = lower_bound(ans.begin(), ans.end(), nums[i]); // 寻找第一个大于等于
                count[i] = iter - ans.begin();
                ans.insert(iter, nums[i]);
            }
        }
        return count;
    }

    
    vector<int> countSmaller(vector<int>& nums){
        // 归并中计算逆序对数量的扩展
        int len = nums.size();
        vector<pair<int, int>> arr;
        vector<int> count(len, 0);
        for(int i=0; i<len; ++i){
            arr.push_back({nums[i], i});
        }
        // 对pair数组排序，同时计算逆序对数量，加入到对应的索引中
        vector<pair<int, int>> tmp(len);
        mergeSort(arr, tmp, count, 0, len - 1);
        return count;
    }

private:
    void mergeSort(vector<pair<int, int>>& arr, vector<pair<int, int>>& tmp, vector<int>& count, int lidx, int ridx){
        // 闭区间
        if(lidx >= ridx) return;

        int mid = lidx + (ridx - lidx) / 2;
        mergeSort(arr, tmp, count, lidx, mid);
        mergeSort(arr, tmp, count, mid + 1, ridx);
        merge(arr, tmp, count, lidx, mid, ridx);
    }

    void merge(vector<pair<int, int>>& arr, vector<pair<int, int>>& tmp, vector<int>& count, int lidx, int mid, int ridx){
        // 拷贝
        for(int i=lidx; i<=ridx; ++i){
            tmp[i] = arr[i];
        }
        
        // 归并回去,从大到小
        int left = mid, right = ridx;
        for(int i=ridx; i>=lidx; --i){
            if(left < lidx){
                arr[i] = tmp[right--];
            }else if(right <= mid){
                arr[i] = tmp[left--];
            }else if(tmp[left].first <= tmp[right].first){
                arr[i] = tmp[right--];
            }else{
                count[tmp[left].second] += right - mid;
                arr[i] = tmp[left--]; 
            }
        }
    }
};
```

## String

##### LC5 最长回文子串

```C++
class Solution {
public:
    string longestPalindrome(string s) {
        int n = s.size();
        // 定义dp数组, dp[i][j]表示s[i...j]是否是回文
        vector<vector<bool>> dp(n, vector<bool>(n, false));
        int left = -1, right = -1, len = 0;
        for(int i=n-1; i>=0; --i){
            for(int j=i; j<n; ++j){
                if(i == j){
                    dp[i][j] = true;
                }else if(s[i] == s[j] && i + 1 == j){
                    dp[i][j] = true;
                }else if(s[i] == s[j] && dp[i+1][j-1]){
                    dp[i][j] = true;
                }

                if(dp[i][j] && len < j - i + 1){
                    len = j - i + 1;
                    left = i, right = j;
                }
            }
        }
        return s.substr(left, len);
    }
};
```

##### LC6 N字变换

```c++
class Solution {
public:
    string convert(string s, int numRows) {
        if(numRows == 1) return s;
        // 模拟大法
        vector<string> str(numRows);
        int loc = 0;
        bool flag = true;
        for(int idx=0; idx<s.size(); ++idx){
            if(flag){
                str[loc].append(1, s[idx]);
                ++loc;
                if(loc == numRows){
                    loc -= 2;
                    flag = (loc == 0);
                } 
            }else{
                str[loc].append(1, s[idx]);
                --loc;
                if(loc == 0){
                    flag = true;
                }
            }
        }
        // 组合
        string ans;
        for(int idx=0; idx<numRows; ++idx){
            ans += str[idx];
        }
        return ans;
    }
};
```

##### LC12整数转换成罗马数字

​	// 递归

```C++
class Solution {
public:

    string intToRoman(int num) {
        if(num == 0) return "";
        if(umap.find(num) != umap.end()){
            ans += umap[num];
        }else{
            for(auto beg = umap.rbegin(); beg != umap.rend(); ++beg){
                if(beg->first < num){
                    ans += beg->second;
                    intToRoman(num - beg->first);
                    break;
                }
            }
        }
        return ans;
    }

    // 哈希枚举所有组合
private:
    string ans;
    map<int, string> umap = {{1, "I"}, {4, "IV"}, {5, "V"}, \
                                       {9, "IX"}, {10, "X"}, {40, "XL"},\
                                       {50, "L"}, {90, "XC"}, {100, "C"}, {400, "CD"},\
                                       {500, "D"}, {900, "CM"}, {1000, "M"}};
    
};
```

// 也可以采用贪心的方式

```C++
package leetcode

func intToRoman(num int) string {
	values := []int{1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1}
	symbols := []string{"M", "CM", "D", "CD", "C", "XC", "L", "XL", "X", "IX", "V", "IV", "I"}
	res, i := "", 0
	for num != 0 {
		for values[i] > num {
			i++
		}
		num -= values[i]
		res += symbols[i]
	}
	return res
}
```

##### LC22 括号生成

```C++
class Solution {
public:
    vector<string> generateParenthesis(int n) {
        vector<string> ans;
        string path;
        int count = 0;
        back(ans, path, 0, count, n);
        return ans;
    }
// 回溯算法，枚举
private:
    char brackets[2] = {'(', ')'};
    void back(vector<string>& ans, string& path, int sidx, int& count, int& n){
        if(count > n || count < 0) return;
        if(sidx == 2 * n){
           if(count == 0)  ans.push_back(path);
           return;
        }

        for(int i=0; i<2; ++i){
            i == 0 ? ++count : --count;
            path.push_back(brackets[i]);
            back(ans, path, sidx + 1, count, n);
            i == 0 ? --count : ++count;
            path.pop_back();
        }
    }
};
```

##### LC24 两两交换链表的节点	

```C++
class Solution {
public:
    ListNode* swapPairs(ListNode* head) {
        if(!head || !head->next) return head;
        ListNode* next = head->next;
        head->next = next->next;
        next->next = head;
        head->next = swapPairs(head->next);
        return next;
    }
};
```

##### LC25 k个一组翻转链表

```C++
class Solution {
public:
    ListNode* reverseKGroup(ListNode* head, int k) {
        if(!head) return head;
        ListNode* ntail = head, *nHead = head;
        int cnt = k;
        while(--cnt && nHead->next){
            nHead = nHead->next;
        }
        if(cnt > 0) return head;
        ListNode* next = nHead->next;
        nHead->next = nullptr;
        reverse(head);
        ntail->next = reverseKGroup(next, k);
        return nHead;
    }

private:
    // 翻转链表,返回头结点
    ListNode* reverse(ListNode* head){
        if(!head || !head->next) return head;
        ListNode* nHead = reverse(head->next);
        head->next->next = head;
        head->next = nullptr;
        return nHead;
    }
};
```

##### LC224 基本计算器

```C++
class Solution {
public:
    int calculate(string s) {
        stack<int> ops;
        ops.push(1); // 绝对符号（也就是去括号后的）, 默认以+起始
        int sign = 1;

        int ret = 0;
        int n = s.length();
        int i = 0;
        while(i < n){
            if(s[i] == ' '){
                ++i;
            }else if(s[i] == '+'){
                sign = ops.top();
                ++i;
            }else if(s[i] == '-'){
                sign = -ops.top();
                ++i;
            }else if(s[i] == '('){
                ops.push(sign);
                ++i;
            }else if(s[i] == ')'){
                ops.pop();
                ++i;
            }else{
                long num = 0;
                while(i < n && s[i] >='0' && s[i] <='9'){
                    num = num * 10 + s[i] - '0';
                    ++i;
                }

                ret += sign * num;
            }
        }
        return ret;
    }
};
```

##### LC225 二叉树前序遍历序列化验证

​	对于一个非null节点，其一定有两个孩子节点（题目中空节点以‘#’表示)---->其出度为2，其入度可以为1（非根节点），也可以为0(根节点)、

​	对于一个null节点，其出度为0，入度为1；

思路：我们开始构建这颗树，在构建过程中，我们记录出度和入度之间的差异 diff = outdegree - indegree。当下一个节点到来时，我们将 diff 减 1，因为这个节点提供了一个度。如果这个节点不为 null，我们将 diff 增加 2，因为它提供两个出度。如果序列化是正确的，则 diff 应该永远不会为负，并且 diff 在完成时将为零。最后判断一下 diff 是不是为 0 即可判断它是否是正确的二叉树的前序序列化。

```C++
class Solution {
public:
    bool isValidSerialization1(string preorder) {
        // 判断一个字符序列是否是前序遍历得到的 中左右
        // 对输入分割成字符数组
        auto vec = split(preorder, ',');
        // 定义出度和入度的差异,在顺序遍历的过程中diff - 1 (减去入度), 如果下一个节点不为null--> diff + 2 (这个节点有两个出度)
        int diff = 1;
        for(string& elem : vec){
            --diff;
            if(diff < 0) return false;
            if(elem != "#") diff +=2;
        }
        return diff == 0;
    }

    bool isValidSerialization(string preorder){
        // 栈的思想
        char stk[10000];
        int idx = 0;
        int len = preorder.size();
        int lidx = 0;
        for(int i=0; i<len; ++i){
            lidx = i;
            while(i < len && preorder[i] != ',') ++i;
            if(preorder[lidx] != '#') stk[idx++] = '*';
            else stk[idx++] = '#';
            // 利用栈的思想
            if(idx == 2 && stk[idx-1] == '#' && stk[idx-2] == '#') return false;
            else{
                while(idx >= 3 && stk[idx-1] == '#' && stk[idx-2] == '#'){
                    stk[idx-3] = '#';
                    idx -= 2;
                }
            }
        }
        return idx == 1 && stk[idx-1] == '#'; 
        
    }

private:
    vector<string> split(string& preorder, char ch){
        int len = preorder.size();
        vector<string> ans;
        int lidx;
        for(int i=0; i<len; ++i){
            lidx = i;
            while(i < len && preorder[i] != ch) ++i;
            ans.push_back(preorder.substr(lidx, i - lidx));
        }
        return ans;
    }
};
```

##### LC767.重构字符串

​	重要的思想是模拟，理解最多的元素出现频率不能超过一半。

```C++
class Solution {
public:
    string reorganizeString(string s) {
        unordered_map<int, int> umap;
        int maxFreq = 0;
        for(auto& ch : s){
            umap[ch]++;
            maxFreq = max(umap[ch], maxFreq);
        }
        // 排除绝对不可能的, m 个需要m-1个不同的 2 * m - 1 <= s.size();
        if(2 * maxFreq - 1 > s.size()) return "";
        
        vector<pair<int, int>> vec(umap.begin(), umap.end());
        sort(vec.begin(), vec.end(), cmp);

        string res(s);
        int index = 0; // 先按奇数位展开
        for(int i=0; i<vec.size(); ++i){
            while(vec[i].second--){
                res[index] = vec[i].first;
                index += 2;
                if(index >= s.size()) index = 1; // 奇数位插满了插入到偶数位
            }
        }
        return res;
        
    }

private:
    static bool cmp(const pair<int, int>& a, const pair<int, int>& b){
        return a.second > b.second;
    }
};
```

##### LC394.字符串解码

```C++
class Solution {
public:
    string decodeString(string s) {
        stack<char> stk;
        for(int i=0; i<s.size(); ++i){
            if(s[i] != ']'){
                stk.push(s[i]);
            }else{
                string str, ans;
                while(stk.top() != '['){
                    str.append(1, stk.top());
                    stk.pop();
                }
                stk.pop();
                // 解析数字
                int cnt = 0, base = 1;
                while(!stk.empty() && '0' <= stk.top() && stk.top() <= '9'){
                    cnt = cnt  + (stk.top() - '0') * base;
                    base *= 10;
                    stk.pop();
                }
                for(int i=0; i<cnt; ++i){
                    ans += str;
                }

                // 插入回栈中
                for(int i=ans.size()-1; i>=0; --i){
                    stk.push(ans[i]);
                }
            }
        }
        string res;
        while(!stk.empty()){
            res.push_back(stk.top());
            stk.pop();
        }
        reverse(res.begin(), res.end());
        return res;
    }
};
```

##### LC395. 至少重复K次的字符子串

```C++
class Solution {
public:

    int longestSubstring(string s, int k){
        int res = 0, n = s.size();
        if(n < k) return 0;
        bitset<26> dic;
        for(auto& ch : s){
            dic[ch - 'a'] = 1;
        }

        int maxKinds = dic.count(), left, right, index, curCharKinds, geKCharKinds;
        int window[26];
        for(int i=1; i<=26; ++i){  // 重复字符的种类有限
            memset(window, 0, sizeof window);
            left = 0, right = 0, curCharKinds = 0, geKCharKinds = 0;
            while(right < n){
                index = s[right] - 'a';
                window[index]++;
                if(window[index] == 1) ++curCharKinds;
                if(window[index] == k) ++geKCharKinds;
                while(curCharKinds > i){
                    index = s[left] - 'a';
                    if(window[index] == 1) --curCharKinds;
                    if(window[index] == k) --geKCharKinds;
                    window[index]--;
                    ++left;
                }
                if(i == geKCharKinds)
                res = max(res, right - left + 1);
                ++right; // 移动右窗口
            }
        }
        return res;
    }
    int longestSubstring11(string s, int k) {
        int res = 0, n = s.size();
        if(n < k)   return 0;
        bitset<26> dic;
        for(char &c : s)    dic[c-'a'] = 1;
        int maxKinds = dic.count(), left, right, index, curCharKinds, geKCharKinds;
        int window[26];
        for(int i = 1; i <= maxKinds; i++) {
            memset(window,0, sizeof(window));
            left = 0, right = 0, curCharKinds = 0, geKCharKinds = 0;
            while(right < n) {
                index = s[right] - 'a';
                window[index]++; // 窗口记录频率
                if(window[index] == 1)  curCharKinds++;
                if(window[index] == k)  geKCharKinds++;
                while(curCharKinds > i) {
                    index = s[left] - 'a';
                    if(window[index] == 1)   curCharKinds--;
                    if(window[index] == k)   geKCharKinds--;
                    window[index]--;
                    left++;  // 窗口右移
                }
                if(geKCharKinds == i)   res = max(res, right-left+1);
                right++;
            } 
        }
        return res;
    }
};
```



## double pointer

##### LC19. 删除倒数第n个节点

```C++
class Solution {
public:
    ListNode* removeNthFromEnd(ListNode* head, int n) {
        ListNode* dummy = new ListNode(-1);
        dummy->next = head;
        ListNode* fast = dummy, *slow = dummy;
        int cnt = n;
        while(fast->next && cnt--){
            fast = fast->next;
        }
        if(cnt > 0) return head; // 不足n个节点
        while(fast->next){
            fast = fast->next;
            slow = slow->next;
        }
        if(slow == dummy){
            delete dummy;
            ListNode* ans = head->next;
            head->next = nullptr;
            delete head;
            return ans;
        }

        // 非头节点
        ListNode* temp = slow->next;
        slow->next = temp->next;
        delete temp;
        return head;
    }
};
```

##### LC28. 找出字符串中第一个匹配项的下标

```C++
class Solution {
public:
    int strStr(string haystack, string needle) {
        // kmp算法
        int len = needle.size();
        vector<int> next(len, 0); // 
        _count(needle, next);
        for(int i=0, j = 0; i<haystack.size(); ++i){
            while(j > 0 && haystack[i] != needle[j]){
                j = next[j-1];
            }

            if(haystack[i] == needle[j]){
                ++j;
            }

            if(j == len){
                return i - len + 1;
            }
        }

        return -1;
    }

private:
    void _count(string& needle, vector<int>& next){
        int j = 0; // 定义needle[0...j]的前缀
        int len = needle.size();
        for(int i=1; i<len; ++i){
            while(j > 0 && needle[j] != needle[i]){
                j = next[j-1];
            }
            if(needle[i] == needle[j]){
                ++j;
            }

            next[i] = j;
        }
    }
};
```

##### LC142.环形链表

```C++
class Solution {
public:
    ListNode *detectCycle(ListNode *head) {
        ListNode* dummy = new ListNode(-1);
        dummy->next = head;
        ListNode* f = dummy, *s = dummy;
        bool flag = false;
        while(f && f->next){
            f = f->next->next;
            s = s->next;
            if(f == NULL) break;
            if(s == f){
                flag = true;
                break;
            }
        }
        if(!flag) return NULL;
        ListNode* curr = dummy;
        while(curr != s){
            curr = curr->next;
            s = s->next;
        }
        return curr;
    }
};
```

##### LC349两个数组的交集

```C++
class Solution {
public:
    vector<int> intersection(vector<int>& nums1, vector<int>& nums2) {
        vector<int> ans;
        vector<bool> state(1001, false);
        for(auto& elem: nums1) state[elem] = true;
        for(auto& elem: nums2){
            if(state[elem]){
                ans.push_back(elem);
                state[elem] = false;
            }
        }
        return ans;
    }
};
```

##### LC125验证回文串

```C++
class Solution {
public:
    bool isPalindrome(string s) {
        int free = 0;
        int len = s.size();
        for(int i=0; i<len; ++i){
            if(isalpha(s[i])){
                s[free++] = tolower(s[i]);
            }else if(isdigit(s[i])){
                s[free++] = s[i];
            }
        }
        if(free == 0) return true;
        int lidx = 0, ridx = free - 1;
        while(lidx < ridx){
            if(s[lidx] != s[ridx]) return false;
            ++lidx, --ridx;
        }
        return true;
    }
};
```

##### LC350. 求两个矩阵的交集

```C++
class Solution {
public:
    vector<int> intersect(vector<int>& nums1, vector<int>& nums2) {
        vector<int> ans;
        unordered_map<int, int> umap;
        for(auto& elem : nums1) ++umap[elem];
        for(auto& elem : nums2){
            if(umap.find(elem) != umap.end() && umap[elem] > 0){
                ans.push_back(elem);
                --umap[elem];
            }
        }
        return ans;
    }
};
```

##### LC524.通过删除字母匹配到字典最长单词

```C++
class Solution {
public:
    string findLongestWord(string s, vector<string>& dictionary) {
        // s删除部分数据得到dic中的一个
        sort(dictionary.begin(), dictionary.end());
        int len = 0;
        string ans;
        for(int i=0; i<dictionary.size(); ++i){
            if(Isvalid(s, dictionary[i]) && len < dictionary[i].size()){
                ans = dictionary[i];
                len = ans.size();
            }
        }
        return ans;
    }

private:
    bool Isvalid(string& s, string& t){
        if(t.size() > s.size()) return false;
        int sidx = 0, tidx = 0;
        for(; sidx < s.size(); ++sidx){
            if(s[sidx] == t[tidx]){
                ++tidx;
            }

            if(tidx == t.size()) return true;
        }
        return false;
    }
};
```

##### LC532. 数组中的 k-diff 数对

(https://leetcode.cn/problems/k-diff-pairs-in-an-array/)

```C++
class Solution {
public:
    int findPairs(vector<int>& nums, int k) {
        sort(nums.begin(), nums.end()); // nlogn
        unordered_map<int, int> umap; // 统计元素的数量
        for(int i=0; i<nums.size(); ++i){
            ++umap[nums[i]];
        }
        int cnt = 0;
        for(int i=0; i<nums.size(); ++i){
            if(k == 0){
                if(umap[nums[i]] > 1) ++cnt;
            }else{
                if(umap.find(nums[i] + k) != umap.end()){
                    ++cnt;     
                }
            }

            while(i + 1 < nums.size() && nums[i+1] == nums[i]) ++i;
        }
        return cnt;
    }
};
```

##### LC567. 字符串的排列

(https://leetcode.cn/problems/permutation-in-string/)

```C++
class Solution {
public:
    bool checkInclusion(string s1, string s2) {
        // 滑动窗口的思想
        int freq[256] = {0};
        if(s2.size() == 0 || s2.size() < s1.size()){
            return false;
        }
        // 统计s1中各个字符出现的频率
        for(int i=0; i<s1.size(); ++i){
            ++freq[s1[i] - 'a'];
        }

        int left = 0, right = 0, count = s1.size();
        
        while(right < s2.size()){
            if(freq[s2[right] - 'a'] >= 1){
                --count;
            }
            --freq[s2[right] - 'a']; // 非期望的字母频率会出现负数的
            ++right;
            if(count == 0){
                return true;
            }
            // 下面是窗口大小的判断
            if(right - left == s1.size()){
                if(freq[s2[left] - 'a'] >= 0){
                    ++count;
                }
                freq[s2[left] - 'a']++;
                ++left;
            }
        }
        return false;
    }
};
```

##### LC581最短无序连续子数组

https://leetcode.cn/problems/shortest-unsorted-continuous-subarray/

```C++
class Solution {
public:
    int findUnsortedSubarray1(vector<int>& nums) {
        vector<int> sArr = nums;
        sort(sArr.begin(), sArr.end());
        int lidx = 0, ridx = nums.size() - 1;
        while(lidx < nums.size() &&nums[lidx] == sArr[lidx]) ++lidx;
        while(ridx >= 0 && nums[ridx] == sArr[ridx]) --ridx;
        if(lidx >= ridx) return 0;
        return ridx - lidx + 1;
    }
    // 维护单调栈数组
    int findUnsortedSubarray(vector<int>& nums){
        vector<int> stk, mstk;
        for(int idx = 0; idx < nums.size(); idx++){
            if(stk.empty()){
                stk.push_back(nums[idx]);
            }else if(stk.back() <= nums[idx]){
                stk.push_back(nums[idx]);
            }else{
                while(!stk.empty() && stk.back() > nums[idx]){
                    stk.pop_back();
                }
                stk.push_back(nums[idx]);
            }
        }

        for(int idx=nums.size()-1; idx>=0; --idx){
            if(mstk.empty()){
                mstk.push_back(nums[idx]);
            }else if(mstk.back() >= nums[idx]){
                mstk.push_back(nums[idx]);
            }else{
                while(!mstk.empty() && mstk.back() < nums[idx]){
                    mstk.pop_back();
                }
                mstk.push_back(nums[idx]);
            }
        }

        // 窗口收缩
        int lidx = 0, ridx = nums.size() - 1;
        while(lidx < nums.size() && lidx < stk.size() && nums[lidx] == stk[lidx]) ++lidx;
        int i = 0;
        while(ridx >= 0 && i < mstk.size() && nums[ridx] == mstk[i]){
            --ridx, ++i;
        }

        if(lidx >= ridx) return 0;
        return ridx - lidx + 1;
    }
};
```

##### LC611. 有效的三角形数量

​	tips：两边之和大于第三边（最大的那条边）

```C++
class Solution {
public:
    int triangleNumber(vector<int> &nums) {
        sort(nums.begin(), nums.end());
        int ans = 0;
        for (int k = 2; k < nums.size(); k++) {
            int c = nums[k];
            int i = 0; // a=nums[i]
            int j = k - 1; // b=nums[j]
            while (i < j) {
                if (nums[i] + nums[j] > c) {
                    // 由于 nums 已经从小到大排序
                    // nums[i]+nums[j] > c 同时意味着：
                    // nums[i+1]+nums[j] > c
                    // nums[i+2]+nums[j] > c
                    // ...
                    // nums[j-1]+nums[j] > c
                    // 从 i 到 j-1 一共 j-i 个
                    ans += j - i;
                    j--;
                } else {
                    // 由于 nums 已经从小到大排序
                    // nums[i]+nums[j] <= c 同时意味着
                    // nums[i]+nums[j-1] <= c
                    // ...
                    // nums[i]+nums[i+1] <= c
                    // 所以在后续的循环中，nums[i] 不可能作为三角形的边长，没有用了
                    i++;
                }
            }
        }
        return ans;
    }
};
```

##### LC658. 找到K个最接近的元素

```C++
class Solution {
public:
    vector<int> findClosestElements(vector<int>& arr, int k, int x) {
       /*
       |a - x| < |b - x| 或者
       |a - x| == |b - x| 且 a < b
       双指针，先找到第一个大于x的值
       */ 
       int r = upperBound(arr, x); // [0....l]都是小于等于x的
       int l = r - 1;
     
       deque<int> dq;
       bool flag = true;
       while(k--){
           int val = 0;
           if(l >= 0 && r < arr.size()){
               
            //    val = (x - arr[l] <= arr[r] - x) ? arr[l--] : arr[r++];
            if(x - arr[l] <= arr[r] - x){
                flag = true;
                val = arr[l--];
            }else{
                flag = false;
                val = arr[r++];
            }
           }else if(l >= 0){
               flag = true;
               val = arr[l--];
           }else{
               flag = false;
               val = arr[r++];
           }
           if(flag){
               dq.push_front(val);
           }else{
               dq.push_back(val);
           }
       }
       vector<int> ans(dq.begin(), dq.end());
       return ans;
       
    }


private:
    int upperBound(vector<int>& arr, int x){
        int left = 0, right = arr.size() - 1;
        while(left <= right){ // 结束的条件就是left > right
            int mid = left + (right - left) / 2;
            if(arr[mid] <= x){
                left = mid + 1;
            }else{ // arr[mid] > x
                right = mid - 1;
            }
        }
        return left;
    }
};
```

##### LC719.找出第K小的数对距离

```C++
class Solution {
public:
    int smallestDistancePair(vector<int>& nums, int k) {
        sort(nums.begin(), nums.end());
        // 可以在最大差值和最小差值之间进行二分
        int maxDiff = nums.back() - nums[0];
        int minDiff = 0;
        /*
        针对每个 mid，判断小于等于 mid 的差值有多少个。题意就转化为，在数组中找到这样一个数，使得满足 nums[i] - nums[j] ≤ mid 条件的组合数等于 k。那么如何计算满足两两数的差值小于 mid 的组合总数是本题的关键。
        */
        // 数值区间二分
        while(minDiff < maxDiff){
            int mid = minDiff + (maxDiff - minDiff) / 2;
            int tmp = findDistanceCount(nums, mid);

            if(tmp >= k){
                maxDiff = mid;
            }else{
                minDiff = mid + 1;
            }
        }
        return minDiff;
    }

private:
    int findDistanceCount(vector<int>& nums, int num){
        int count = 0, i = 0;
        for(int j=1; j<nums.size(); ++j){
            while(nums[j] - nums[i] > num && i < j) ++i;
            count += (j - i); // 统计数对距离小于等于num的数量
        }
        return count;
    }
};
```

##### LC763. 划分字母区间

(https://leetcode.cn/problems/partition-labels/)

```C++
class Solution {
public:
    vector<int> partitionLabels(string s) {
        int count[26] = {0};
        for(int idx=0; idx<s.size(); ++idx){
            count[s[idx] - 'a'] = idx; // 记录最远的位置
        }
        // 尽可能多的分片
        vector<int> ans;
        int lidx = 0, ridx = count[s[0] - 'a'];
        for(;lidx < s.size();){
            int tidx = lidx;
            ridx = count[s[tidx] - 'a'];
            while(tidx <= ridx){ // 维护一个窗口的最大值
                ridx = max(ridx, count[s[tidx]-'a']);
                ++tidx;
            }
            ans.push_back(tidx - lidx);
            lidx = tidx;
        }
        return ans;
    }

    int max(const int& lhs, const int& rhs){
        return lhs > rhs ? lhs : rhs;
    }
};
```

##### LC795. 区间子数组个数

(https://leetcode.cn/problems/number-of-subarrays-with-bounded-maximum/)

题目要求子数组最大元素在[L, R]区间内。假设count(bound)为计算所有元素都小于等于bound的子数组数量。那么本题所求的答案可以转化为count(R) - count(L-1)

```C++
class Solution {
public:
    int numSubarrayBoundedMax(vector<int>& nums, int left, int right) {
        return getAnswerPerBound(nums, right) - getAnswerPerBound(nums, left - 1);
    }


private:
    // 最大值小于等于Bound的子数组数量
    int getAnswerPerBound(vector<int>& nums, int bound){
        int res = 0, cnt = 0;
        for(auto& elem: nums){
            if(elem <= bound){ // 右区间以elem结尾的子数组
                cnt++;
            }else{
                cnt = 0;
            }
            res += cnt;
        }
        return res;
    }
};
```

##### LC825.适龄的朋友

```C++
class Solution {
public:
    // 可以接受的位子 0.5 * ages[x] + 7 < ages[y] <= age[x]; 
    int numFriendRequests(vector<int>& ages) {
        sort(ages.begin(), ages.end()); // 排序
        int left = 0, right = 0, res = 0;
        for(int i=0; i<ages.size(); ++i){ // 对每一个人进行判断
            if(ages[i] < 15) continue;
            while(left < ages.size() && ages[left] * 2 <= ages[i] + 14) ++left;
            while(right + 1 < ages.size() && ages[right+1] <= ages[i]) ++right;
            res += right - left; // right最终会和i重合，要排除
        }
        return res;
    }
};
```

##### L838. 推多米诺

(https://leetcode.cn/problems/push-dominoes/)

解题思路大致上就是模拟法

```C++
class Solution {
public:
    string pushDominoes(string dominoes) {
        int n = dominoes.size();
        int le = 0, ri = n - 1;

        for(int i = 0; i < n; i++) {
            if(dominoes[i] == '.') continue;

            if(dominoes[i] == 'L') { // 往左倒
                for(int j = i - 1; j >= 0 && dominoes[j] == '.'; j--) dominoes[j] = 'L';
                continue;
            }

            // dominoes[i] == 'R'
            int len = 0;    // 'R' -> 'L' 中间的牌
            for(int j = i + 1; j < n && dominoes[j] == '.'; j++) {
                dominoes[j] = 'R';
                len++;
            }
            int next = i + len + 1;     // 循环停止的位置
            if(next == n) break;
            if(dominoes[next] == 'R') continue;

            // 遇到了 'L'， 需要重新赋值
            int pos = i + len / 2 + 1;
            if(len % 2 == 1) {
                dominoes[pos++] = '.';
            } 
            while(pos < next) dominoes[pos++] = 'L';
            i = next;
        }

        return dominoes;
    }
};
```

##### LC845. 数组中的最长山脉

(https://leetcode.cn/problems/longest-mountain-in-array/)

思路：对每一个山峰进行双指针

```C++
class Solution {
public:
    int longestMountain(vector<int>& arr) {
        // 也就是存在一个山峰的最大长度
        int maxLen = 0;
        for(int idx = 1; idx < arr.size() - 1; ++idx){
            if(arr[idx] > arr[idx-1] && arr[idx] > arr[idx+1]){
                int lidx = idx-1, ridx = idx + 1;
                while(lidx >=1 && arr[lidx] > arr[lidx-1]) --lidx;
                while(ridx < arr.size() -1 && arr[ridx] > arr[ridx+1]) ++ridx;
                maxLen = max(maxLen, ridx - lidx + 1);
            }
        }
        return maxLen;
    }
};
```

##### LC870. 最优势洗牌

​	思想：田忌赛马思想

```C++
class Solution {
public:
    vector<int> advantageCount(vector<int>& nums1, vector<int>& nums2) {
        // 如果nums1[i] > nums2[i]---> ++cnt;
        int len = nums1.size();
        vector<pair<int, int>> t(len);
        for(int i=0; i<nums2.size(); ++i){
            t[i] = {nums2[i], i};
        }
        sort(t.begin(), t.end(), cmp);
        sort(nums1.begin(), nums1.end());
        
        int l1 = 0, r1 = len - 1, l2 = 0, r2 = len - 1;
        vector<int> ans(len, -1);
        while(l1 <= r1){
            while(l1 <= r1 && nums1[l1] > t[l2].first){
                ans[t[l2].second] = nums1[l1];
                ++l1, ++l2;
            }// 退出循环的可能， l1 > r1 或者 nums[l1] <= nums[l2];
            if(l1 > r1) break;
            ans[t[r2].second] = nums1[l1];
            --r2; ++l1; // 田忌赛马思想, 下等马与上等马比较
        }
        return ans;
    }
public:
    static bool cmp(const pair<int, int>& lhs, const pair<int, int>& rhs){
        return lhs.first < rhs.first || (lhs.first == rhs.first && lhs.second < rhs.second);
    }
};
```

##### LC881. 救生艇

​	思想：一只船尽可能的多装东西

```C++
class Solution {
public:
    int numRescueBoats(vector<int>& people, int limit) {
        // 类似于两数之和
        sort(people.begin(), people.end());
        int left = 0, right = people.size() - 1;
        int cnt = 0;
        while(right >= 0 && people[right] == limit) {++cnt; --right;}
        while(left <= right){
            // 分情况
            if(left == right){
                ++cnt;
                break;
            }

            if(people[left] + people[right] <= limit){
                ++cnt;
                ++left;
                --right;
                continue;
            }
            while(right > left && people[right] + people[left] > limit){
                ++cnt;
                --right;
            }
        }
        return cnt;
    }
};
```

##### LC969. 煎饼排序

```

```

## 链表

##### LC141.判断链表是否有环

```C++
class Solution {
public:
    bool hasCycle(ListNode *head) {
        ListNode* fast = head, *slow = head;
        while(fast && fast->next){
            fast = fast->next->next;
            slow = slow->next;
            if(fast == slow) return true;
        }
        return false;
    }
};
```

##### LC143.重排链表

```C++
class Solution {
public:
    void reorderList(ListNode* head) {
        if(!head) return;
        ListNode* curr = head, *pre = nullptr;
        while(curr->next){
            pre = curr;
            curr = curr->next;
        }
        if(!pre || pre == head) return;
        ListNode* tmp = head->next;
        head->next = curr;
        curr->next = tmp;
        pre->next = nullptr;
        reorderList(tmp);
    }
};
```

##### LC146.LRU Cache

```C++
class LRUCache {
public:
    typedef int key_type;
    typedef int value_type;
    LRUCache(int capacity) : m_capactity(capacity){
    }
    
    int get(int key) {
        if(m_itermap.find(key) == m_itermap.end()){
            return -1;
        }else{
            auto& iter = m_itermap[key]; 
            m_list.splice(m_list.begin(), m_list, iter);  // 访问后放到链表头部
            return *(m_itermap[key]->first);
        }
    }
    
    void put(int key, int value) {
        if(m_itermap.find(key) != m_itermap.end()){
            *(m_itermap[key]->first) = value;
            m_list.splice(m_list.begin(), m_list, m_itermap[key]);
        }else if(m_list.size() < m_capactity){
            value_type* vptr = new value_type(value);
            m_list.push_front({vptr, key});
            m_itermap[key] = m_list.begin();
        }else{
            auto& pairs = m_list.back();
            m_itermap.erase(pairs.second);
            delete pairs.first;
            value_type* vptr = new value_type(value);
            m_list.pop_back();
            m_list.push_front({vptr, key});
            m_itermap[key] = m_list.begin();
        }
    }

private:
    int m_capactity; // 页面数量
    list<pair<value_type*, key_type>> m_list; // 维护(value, key)的链表(实际上就是物理页面的地址或数据); 为什么还要保存key, 因为尾部删除的时候要找到key，更新m_itermap
    unordered_map<key_type, list<pair<value_type*, key_type>>::iterator> m_itermap;  // O(1)访问
};
```

##### LC328. 奇偶链表

```C++
class Solution {
public:
    ListNode* oddEvenList(ListNode* head) {
        if(!head) return head;
        // 目标：奇偶链拆分
        ListNode* oddHead = head; // 奇数
        ListNode* evenHead = nullptr;
        ListNode* ocurr = oddHead;
        ListNode* ecurr = evenHead;
        while(ocurr && ocurr->next){
            if(!ecurr){
                evenHead = ocurr->next;
                ecurr = ocurr->next;
            }else{
                ecurr->next = ocurr->next;
                ecurr = ecurr->next;
            }

            ocurr->next = ecurr->next;
            ocurr = ocurr->next;
            ecurr->next = nullptr;
        }
        ocurr = oddHead;
        while(ocurr && ocurr->next){
            ocurr = ocurr->next;
        }
        ocurr->next = evenHead;
        return oddHead;
    }
};
```

##### LC445. 两数之和II

```C++
class Solution {
public:
    ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) {
        int Aug = 0;
        stack<ListNode*> stk1;
        stack<ListNode*> stk2;
        ListNode* curr = l1;
        while(curr){
            stk1.push(curr);
            curr = curr->next;
        }
        curr = l2;
        while(curr){
            stk2.push(curr);
            curr = curr->next;
        }

        //弹元素
        bool flag = true;
        if(stk1.size() < stk2.size()) {
            stk1.swap(stk2);
            flag = false;
        }
        while(!stk1.empty() || !stk2.empty()){
            if(stk2.empty()){
                int val = Aug + stk1.top()->val;
                Aug = val / 10;
                stk1.top()->val = val % 10;
                stk1.pop();
            }else{
                int val = Aug + stk1.top()->val + stk2.top()->val;
                Aug = val / 10;
                stk1.top()->val = val % 10;
                stk1.pop();
                stk2.pop();
                
            }
        }

        if(Aug == 0) return flag ? l1 : l2;
        ListNode* dummy = new ListNode(Aug);
        dummy->next = flag ? l1 : l2;
        return dummy;
    }
};
```

##### LC622.设计循环队列

```C++
class MyCircularQueue {
public:
    MyCircularQueue(int k) {
        assert(k > 0);
        m_capacity = k;
        m_cirQue = new int[m_capacity];
        m_front = m_rear = 0;
        m_size = 0; 
    }
    ~MyCircularQueue(){
        delete[] m_cirQue;
    }
    
    bool enQueue(int value) {
        if(isFull()) return false;
        m_cirQue[m_rear] = value;
        m_rear = (m_rear + 1) % m_capacity; 
        ++m_size;
        return true;
    }
    
    bool deQueue() {
        if(isEmpty()) return false;
        m_front = (m_front + 1) % m_capacity;
        --m_size;
        return true;
    }
    
    int Front() {
        if(isEmpty()) return -1;
        return m_cirQue[m_front];
    }
    
    int Rear() {
        if(isEmpty()) return -1;
        return m_cirQue[(m_rear - 1 + m_capacity) % m_capacity];
    }
    
    bool isEmpty() {
        return m_size == 0;
    }
    
    bool isFull() {
        return m_size == m_capacity;
    }

private:
    int m_capacity;   // 记录循环数组长度
    size_t m_size;   // 记录一个长度
    int* m_cirQue;   // 记录内部数组首元素
    int m_front;    // 指向首元素
    int m_rear;    // 指向尾元素下一位置
};
```

​	第二种方法：区分队满和对空

```C++
class MyCircularQueue {
private:
    int front;
    int rear;
    int capacity;
    vector<int> elements;

public:
    MyCircularQueue(int k) {
        this->capacity = k + 1;
        this->front = this->rear = 0;
        elements = vector<int>(this->capacity, 0);
    }
    
    bool enQueue(int value) {
        if(isFull()) return false;
        elements[rear] = value;
        rear = (rear + 1) % this->capacity;
        return true;
    }
    
    bool deQueue() {
        if(isEmpty()) return false;
        front = (front + 1) % this->capacity;
        return true;
    }
    
    int Front() {
        if(isEmpty()) return -1;
        return elements[front];
    }
    
    int Rear() {
        if(isEmpty()) return -1;
        return elements[(rear - 1 + this->capacity) % this->capacity];
    }
    
    bool isEmpty() {
        return front == rear;
    }
    
    bool isFull() {
        return front == ((rear + 1) % this->capacity);
    }
};
```

##### LC707：设计链表

```C++
class MyLinkedList {
protected:
    struct LinkNode{
        int val;
        LinkNode* prev;
        LinkNode* next;
        LinkNode(int val) : val(val), prev(nullptr), next(nullptr) {}
    };
private:
    LinkNode* head;
    LinkNode* tail;
    int size;
public:
    MyLinkedList() {
        head = tail = nullptr;
        size = 0;
    }

    int get(int index) {
        if(size == 0) return -1;
        if(!IsIndexValid(index)) return -1;
        return getIndex(index)->val;
    }
    
    void addAtHead(int val) {
        if(head==tail && head==nullptr){
            head = tail = new LinkNode(val);
        }else{
            head->prev = new LinkNode(val);
            head->prev->next = head;
            head = head->prev;
        }
        ++size;
    }
    
    void addAtTail(int val) {
        if(head==tail && tail==nullptr){
            head = tail = new LinkNode(val);
        }else{
            tail->next = new LinkNode(val);
            tail->next->prev = tail;
            tail = tail->next;
        }
        ++size;
    }
    
    void addAtIndex(int index, int val) {
        if(index < 0 || index > size) return;
        if(index == size){
            addAtTail(val);
        }else if(index == 0){
            addAtHead(val);
        }else{
            LinkNode* curr = getIndex(index);
            LinkNode* tmp = new LinkNode(val);
            curr->prev->next = tmp;
            tmp->prev = curr->prev;
            tmp->next = curr;
            curr->prev = tmp;
            ++size;
        }
    }
    
    void deleteAtIndex(int index) {
        if(size == 0 ||  !IsIndexValid(index)) return;
        LinkNode* tNode = getIndex(index);
        if(size == 1){
            delete head;
            head = tail = nullptr;
        }else if(tNode == head){
            LinkNode* newHead = tNode->next;
            newHead->prev = nullptr;
            head->next = nullptr;
            delete head;
            head = newHead;
        }else if(tNode == tail){
            LinkNode* newTail = tail->prev;
            tail->prev = nullptr;
            newTail->next = nullptr;
            delete tail;
            tail = newTail;
        }else{
            tNode->prev->next = tNode->next;
            tNode->next->prev = tNode->prev;
            delete tNode;
        }
        --size;
    }

private:
    bool IsIndexValid(int index){
        if(0 <= index && index < size){
            return true;
        }
        return false;
    }
    LinkNode* getIndex(int index){
        // 获取一个有效index对应的节点
        LinkNode* curr = head;
        int tmpIndex = 0;
        while(tmpIndex != index){
            curr = curr->next;
            ++tmpIndex;
        }
        return curr;
    }
};
```

##### LC725.分隔链表

```C++
class Solution {
public:
    vector<ListNode*> splitListToParts(ListNode* head, int k) {
        int len = this->length(head);
        vector<ListNode*> ans(k, nullptr);
        split(head, len, k, ans);
        return ans;
    }

private:
    void split(ListNode* head, int len, int k, vector<ListNode*>& ans){
        int mod = len % k;
        int i;
        for(i=0; i<len; ++i){
            int interal = len / k;
            if(!head) break;
            while(interal-- && head){
                if(!ans[i]){
                    ans[i] = head;
                    continue;
                }
                head = head->next;
            }
            if(!head) break;
            if(mod != 0){
                --mod;
                if(ans[i] == nullptr){
                    ans[i] = head;
                }else{
                    head = head->next;
                }
            }
            if(!head) break;
            ListNode* tmp = head->next;
            head->next = nullptr;
            head = tmp;
        }
    }

    int length(ListNode* head){
        int cnt = 0;
        while(head){
            ++cnt;
            head = head->next;
        }
        return cnt;
    }
};
```

##### LC817.链表组件

```C++
class Solution {
public:
    int numComponents(ListNode* head, vector<int>& nums) {
        unordered_set<int> uset(nums.begin(), nums.end());
        int cnt = 0;
        while(head){
            while(head && uset.find(head->val) == uset.end()){
                head = head->next;
            }
            if(!head) return cnt;
            ++cnt;
            while(head && uset.find(head->val) != uset.end()){
                head = head->next;
            }
        }
        return cnt;
    }
};
```

##### LC876.链表的中间结点

```C++
class Solution {
public:
    ListNode* middleNode(ListNode* head) {
        ListNode* dummy = new ListNode(-1);
        dummy->next = head;
        ListNode* slow = dummy, *fast = dummy;
        while(1){
            if(fast->next && !fast->next->next){
                return slow->next;
            }
            if(!fast->next) return slow->next;
            fast = fast->next->next;
            slow = slow->next;
        }
    }
};
```

##### LC1171.从链表中删去总和值为零的连续点

```C++
class Solution {
public:
    ListNode* removeZeroSumSublists(ListNode* head) {
        if(!head) return head;
        // 排除开头为0的元素
        while(head && head->val == 0){
            ListNode* tmp = head;
            head = head->next;
        }
        if(!head) return head;

        unordered_set<int> uset = {0}; // 记录累加和, 利用map来描述某一段相加为, 出现插入相同的值意味着某一段和为0
        int sum = 0;
        ListNode* curr = head;
        while(curr && uset.find(curr->val + sum) == uset.end()){
            sum += curr->val;
            uset.insert(sum);
            curr = curr->next;
        }
        if(!curr) return head;
        if(sum + curr->val == 0) return removeZeroSumSublists(curr->next);

        ListNode* tmp = head;
        int lsum = 0;
        while(lsum + tmp->val != sum + curr->val){
            lsum += tmp->val;
            tmp = tmp->next;
        }
        tmp->next = curr->next;
        return removeZeroSumSublists(head);
    }
};
```

##### LC1669.合并两个链表

```C++
class Solution {
public:
    ListNode* mergeInBetween(ListNode* list1, int a, int b, ListNode* list2) {
        // a和b是索引的位置--->删除是闭区间的[a, b]
        ListNode* pre, *tail;
        int idx = 0;
        ListNode* curr = list1;
        while(idx != b){
            if(idx == a - 1){
                pre = curr;
            }
            ++idx;
            curr = curr->next;
        }
        pre->next = list2;
        ListNode* curr2 = list2;
        while(curr2->next){
            curr2 = curr2->next;
        }
        curr2->next = curr->next;
        return list1;
    }
};
```

## 栈

##### LC树的遍历

​	1）方法1是使用递归

```C++
// 前序遍历
class Solution {
public:
    vector<int> preorderTraversal(TreeNode* root) {
        prefix(root);
        return ans;
    }
private:
    void prefix(TreeNode* root){
        if(!root) return;
        ans.push_back(root->val);
        prefix(root->left);
        prefix(root->right);
    }
private:
    vector<int> ans;
};
// 栈的实现
class Solution {
public:
    vector<int> preorderTraversal(TreeNode* root) {
        // 栈实现前序遍历
        if(!root) return {};
        vector<int> ans;
        stack<TreeNode*> stk;
        stk.push(root);
        while(!stk.empty()){
            TreeNode* node = stk.top();
            stk.pop();
            ans.push_back(node->val); // 取中
            if(node->right){
                stk.push(node->right); // 压栈
            }
            if(node->left){
                stk.push(node->left);
            }
        }
        return ans;
    }
};
// 后序遍历
class Solution {
public:
    vector<int> postorderTraversal(TreeNode* root) {
        lastfix(root);
        return ans;
    }
private:
    void lastfix(TreeNode* node){
        if(!node) return;
        lastfix(node->left);
        lastfix(node->right);
        ans.push_back(node->val);
    }
private:
    vector<int> ans;
};
// 栈能不能实现后序遍历--->后序遍历，会改变原有节点值的实现
class Solution {
public:
    vector<int> postorderTraversal(TreeNode* root) {
        if(!root) return {};
        stack<TreeNode*> stk;
        vector<int> ans;
        stk.push(root);
        while(!stk.empty()){
            TreeNode* node = stk.top();
            if(isCenter(node)){
                ans.push_back(node->val);
                node->val = val;
                stk.pop();
                continue;
            }
            if(node->right){
                stk.push(node->right);
            }

            if(node->left){
                stk.push(node->left);
            }
        }
        return ans;
    }
private:
    const int val = -101;
    bool isCenter(TreeNode* node){
        if(node->left && node->left->val != val){
            return false;
        }
        if(node->right && node->right->val != val){
            return false;
        }
        return true;
    }
};
```

##### LC20有效括号

```C++
class Solution {
public:
    bool isValid(string s) {
        stack<char> stk;
        unordered_map<char, char> umap = {{')', '('}, {']', '['}, {'}', '{'}};
        for(auto& ch: s){
            if(umap.find(ch) == umap.end()){
                stk.push(ch);
            }else{
                if(!stk.empty() && stk.top() == umap[ch]){
                    stk.pop();
                }else{
                    return false;
                }
            }
        }
        return stk.empty();
    }
};
```

##### LC155.最小栈

```C++
// 一个辅助栈, 一个正常栈--->类似的最大栈实现原理也是类似的
class MinStack {
public:
    MinStack() {
    }
    
    void push(int val) {
        normalStk.push(val);
        if(auxStk.empty()){
            auxStk.push(val);
        }else if(val <= auxStk.top()){
            auxStk.push(val);
        }
    }
    
    void pop() {
        if(normalStk.top() == auxStk.top()){
            auxStk.pop();
        }
        normalStk.pop();
    }
    
    int top() {
        return normalStk.top();
    }
    
    int getMin() {
        return auxStk.top();
    }
private:
    stack<int> normalStk;
    stack<int> auxStk; // 维护当前栈的最小值
};
```

## 树

##### LC98判断是否是BST

<font color="red">// 总结：树的遍历要熟悉递归和迭代方式,前者很重要，能不能从一个复杂的问题中抽象出子问题。</font>

```C++
class Solution {
public:
    bool isValidBST1(TreeNode* root) {
        if(!root) return true;
        bool lret = isValidBST(root->left); // 判断左子树是否为BST
        bool rret = isValidBST(root->right); // 判断右子树是否为BST
        if(!lret || !rret) return false;
        // 子树都为BST的情况下考虑根； 存在错误, BST要求左子树最大值小于根值, 根值小于右子树
        if(!root->left && !root->right) return true;
        if(!root->left) return root->val < root->right->val;
        if(!root->right) return root->left->val < root->val;
        return root->left->val < root->val && root->val < root->right->val;

    }
    // BST中序遍历是有序的
    bool isValidBST2(TreeNode* root) {
        MFS(root);
        for(int i=0; i + 1 < ans.size(); ++i){
            if(ans[i] >= ans[i+1]){
                return false;
            }
        }
        return true;
    }

    // 能不能使用O(1)的复杂度
    bool isValidBST(TreeNode* root){
        return CenterFS(root);
    }

private:
    vector<int> ans;
    bool gret = true;
    int* pre = nullptr;
    void MFS(TreeNode* node){
        if(!node) return;
        MFS(node->left);
        ans.push_back(node->val);
        MFS(node->right);
    }

    bool CenterFS(TreeNode* node){
        if(!node) return gret;
        bool lret = CenterFS(node->left);
        if(!lret) return gret;
        if(pre == nullptr){
            pre = &(node->val);
        }else{
            if(*pre >= node->val){
                gret = false;
            }
            pre = &(node->val);
        }
        gret = gret && CenterFS(node->right);
        return gret;
    }
};
```

##### LC99恢复BST

找到了不是有序的相邻对, 只交换一次不能保证全局有序, 因此左一遍，右一遍的方式

```C++
class Solution {
public:
    void recoverTree(TreeNode* root) {
        // BST的值错了--->恢复
        // 思路:中序遍历是不是有序的:常规是左中右;遍历两遍: 一遍低到高; 二遍高到低
        InorderFS(root);
        pre = nullptr;
        InorderFS2(root);
    }

private:
    TreeNode* pre = nullptr;
    void InorderFS(TreeNode* node){
        if(!node) return;
        InorderFS(node->left);
        if(!pre){
            pre = node;
        }else{
            if(pre->val >= node->val){
                swap(pre->val, node->val);
            }
            pre = node;
        }
        InorderFS(node->right);
    }


    void InorderFS2(TreeNode* node){
        if(!node) return;
        InorderFS2(node->right);
        if(!pre){
            pre = node;
        }else{
            if(pre->val <= node->val){
                swap(pre->val, node->val);
            }
            pre = node;
        }
        InorderFS2(node->left);
    }
};
```

##### LC102层序遍历

```C++
class Solution {
public:
    vector<vector<int>> levelOrder(TreeNode* root) {
        vector<vector<int>> ans;
        if(!root) return ans;
        deque<TreeNode*> stk;
        vector<int> layer;
        stk.push_back(root);
        while(!stk.empty()){
            int cnt = stk.size();
            layer.clear();
            while(cnt--){
                TreeNode* node = stk.front();
                stk.pop_front();
                layer.push_back(node->val);
                if(node->left){
                    stk.push_back(node->left);
                } 
                if(node->right){
                    stk.push_back(node->right);
                }
            }
            ans.push_back(layer);
        }
        return ans;
    }
};
```

##### LC103.二叉树的锯齿形层序遍历

```C++
class Solution {
public:
    vector<vector<int>> zigzagLevelOrder(TreeNode* root) {
        vector<vector<int>> ans;
        if(!root) return ans;

        int layers = 0;
        TreeNode* node = nullptr;
        deque<TreeNode*> stk;
        vector<int> layer;
        stk.push_back(root);
        while(!stk.empty()){
            int cnt = stk.size();
            layer.clear();
            while(cnt--){
                if(layers % 2 == 0){
                    node = stk.front();
                    stk.pop_front();
                }else{
                    node = stk.back();
                    stk.pop_back();
                }
                layer.push_back(node->val);

                if(layers % 2 == 0){
                    if(node->left) stk.push_back(node->left);
                    if(node->right) stk.push_back(node->right);
                }else{
                    if(node->right) stk.push_front(node->right);
                    if(node->left) stk.push_front(node->left);
                }
        
            }
            ++layers;
            ans.push_back(layer);
        }
        return ans;
    }
};
```

##### LC104. 最大深度

```C++
class Solution {
public:
    // 层序
    int maxDepth1(TreeNode* root) {
        int depth = 0;
        if(!root) return depth;
        deque<TreeNode*> stk;
        stk.push_back(root);
        while(!stk.empty()){
            int cnt = stk.size();
            while(cnt--){
                TreeNode* node = stk.front();
                stk.pop_front();
                if(node->left){
                    stk.push_back(node->left);
                } 
                if(node->right){
                    stk.push_back(node->right);
                }
            }
            ++depth;
        }
        return depth;
    }
    // 递归
    int maxDepth(TreeNode* root){
        if(!root) return 0;
        return max(maxDepth(root->left), maxDepth(root->right)) + 1;
    }
};
```

##### LC129.求根节点到叶子点数字之和

```C++
class Solution {
public:
    int sumNumbers(TreeNode* root) {
        pathSum(root, 0);
        return cnt;
    }

private:
    int cnt = 0;
    void pathSum(TreeNode* node, int sum){
        if(!node) return;
        sum  = sum * 10 + node->val;
        if(!node->left && !node->right){
            cnt += sum;
            return;
        }
        pathSum(node->left, sum);
        pathSum(node->right, sum);
    }
};
```

##### LC173. 二叉树中序遍历迭代器

```C++
class BSTIterator {
public:
    BSTIterator(TreeNode* root) {
        push(root);
    }
    
    int next() {
        if(hasNext()){
            TreeNode* node = stk.top();
            stk.pop();
            push(node->right);
            return node->val;
        }
        return -1;
    }
    
    bool hasNext() {
        return !stk.empty();
    }
private:
    stack<TreeNode*> stk;
private:
    void push(TreeNode* node){
        while(node){
            stk.push(node);
            node = node->left;
        }
    }
};
```

##### LC199.二叉树的右视图

```C++
class Solution {
public:
    vector<int> rightSideView(TreeNode* root) {
        // 层序遍历吧
        queue<TreeNode*> mq;
        vector<int> ans;
        if(!root) return ans;
        mq.push(root);
        TreeNode* node;
        while(!mq.empty()){
            int cnt = mq.size();
            while(cnt--){
                node = mq.front();
                mq.pop();
                if(cnt == 0){
                    ans.push_back(node->val);
                }
                if(node->left){
                    mq.push(node->left);
                }
                if(node->right){
                    mq.push(node->right);
                }
            }
        }
        return ans;
    }
};
```

##### LC257.二叉树所有路径

```C++
class Solution {
public:
    vector<string> binaryTreePaths(TreeNode* root) {
        // 先序遍历
        vector<string> ans;
        if(!root) return ans;
        preFs(root, ans, "");
        return ans;
    }

private:
    void preFs(TreeNode* node, vector<string>& ans, string path){
        if(!node->left && !node->right){
            path += to_string(node->val);
            ans.push_back(path);
            return;
        }
        path += to_string(node->val) + "->";
        if(node->left){
            preFs(node->left, ans, path);
        }
        if(node->right){
            preFs(node->right, ans, path);
        }
    }
};
```

##### LC337.打家劫舍III

```C++
class Solution {
public:
    int rob(TreeNode* root) {
        // 打家劫舍问题--->确定什么遍历方式; DP结合
        if(!root) return 0;
        auto ans = _getMaxProfix(root);
        return max(ans.first, ans.second);
    }

private:
    // 节点偷和不偷的情况下最大利润; arr[0]表示不偷, arr[1]表示偷
    pair<int, int> _getMaxProfix(TreeNode* node){
        if(!node) return {0, 0};
        auto lp = _getMaxProfix(node->left);
        auto rp = _getMaxProfix(node->right);
        pair<int, int> ans = {0, 0};
        ans.first = max(lp.first, lp.second) + max(rp.first, rp.second);
        ans.second = node->val + lp.first + rp.first;
        return ans;
    }
};
```

##### LC341. 扁平化嵌套列表迭代器

```C++
class NestedIterator {
public:
    NestedIterator(vector<NestedInteger> &nestedList) {
        // 方法1完全解析
        parse(nestedList);
    }
    
    int next() {
        int tmp = vec.front();
        vec.pop_front();
        return tmp;
    }
    
    bool hasNext() {
        return !vec.empty();
    }
private:
    void parse(vector<NestedInteger> &nestedList){
        for(int i=0; i<nestedList.size(); ++i){
            if(nestedList[i].isInteger()){
                vec.push_back(nestedList[i].getInteger());
            }else{
                parse(nestedList[i].getList());
            }
        }
    }
private:
    list<int> vec; 
};
```

##### LC404.左叶子之和

递归写法

```C++
class Solution {
public:
    int sumOfLeftLeaves(TreeNode* root) {
        return LeafSum(root);
    }

private:
    int LeafSum(TreeNode* node){
        if(!node) return 0;
        if(node->left && (!node->left->left && !node->left->right)){
            return node->left->val + LeafSum(node->right);
        }else if(!node->left){
            return LeafSum(node->right);
        }else{
            return LeafSum(node->left) + LeafSum(node->right);
        }
    }
};
```

##### LC429.N叉树的层序遍历

```C++
// Definition for a Node.
/*
class Node {
public:
    int val;
    vector<Node*> children;  // N叉树的子节点用动态数组保存

    Node() {}

    Node(int _val) {
        val = _val;
    }

    Node(int _val, vector<Node*> _children) {
        val = _val;
        children = _children;
    }
};
*/

class Solution {
public:
    vector<vector<int>> levelOrder(Node* root) {
        vector<vector<int>> larr;
        vector<int> layer;
        if(!root) return larr;
        queue<Node*> mq;
        mq.push(root);
        Node* node;
        while(!mq.empty()){
            int cnt = mq.size();
            layer.clear();
            while(cnt--){
                node = mq.front();
                mq.pop();
                layer.push_back(node->val);
                for(int i=0; i<node->children.size(); ++i){
                    mq.push(node->children[i]);
                }
            }
            larr.push_back(layer);
        }
        return larr;
    }
};
```

##### LC508.出现次数最多的子树元素和

```C++
 /* 一个结点的 「子树元素和」 定义为以该结点为根的二叉树上所有结点的元素之和（包括结点本身）*/

class Solution {
public:
    vector<int> findFrequentTreeSum(TreeNode* root) {
        // 统计子树和---> 后序遍历
        lastFS(root);
        vector<int> ans;
        int maxCnt = 0;
        for(auto& beg : bmap){
            if(ans.empty()){
                ans.push_back(beg.first);
                maxCnt = beg.second;
            }else if(maxCnt == beg.second){
                ans.push_back(beg.first);
            }else if(maxCnt < beg.second){
                ans.clear();
                ans.push_back(beg.first);
                maxCnt = beg.second;
            }
        }
        return ans;
    }
private:
    unordered_map<int, int> bmap;
    int lastFS(TreeNode* root){
        if(!root) return 0;
        int lsum = lastFS(root->left);
        int rsum = lastFS(root->right);
        int sum = lsum + rsum + root->val;
        bmap[sum]++;
        return sum;
    }
};
```

##### LC530.BST二叉搜索树的最小绝对误差

```C++
class Solution {
public:
    int getMinimumDifference(TreeNode* root) {
        lfs(root);
        return res;
    }
private:
    int* ptr = nullptr;
    int res = 1e5 + 1;
private:
    void lfs(TreeNode* root){
        if(!root) return;
        lfs(root->left);
        if(ptr == nullptr){
            ptr = &(root->val);
        }else{
            res = min(res, root->val - *ptr);
            ptr = &(root->val);
        }
        lfs(root->right);
    }
};
```

##### LC538.把BST转化为累加树

```C++
class Solution {
public:
    TreeNode* convertBST(TreeNode* root) {
        rcl(root);
        return root;
    }
private:
    void rcl(TreeNode* root){
        if(!root) return;
        rcl(root->right);
        int tmp = root->val;
        root->val += sum;
        sum += tmp;
        rcl(root->left);
    }
private:
    int sum = 0;
};
```

##### LC543.二叉树的直径

```C++
class Solution {
public:
    int diameterOfBinaryTree(TreeNode* root) {
        getDepth(root);
        return maxd;
    }

private:
    int maxd = 0;
    int getDepth(TreeNode* root){
        if(!root) return 0;
        int lret = getDepth(root->left);
        int rret = getDepth(root->right);
        maxd = max(maxd, lret + rret);
        return max(lret, rret) + 1;
    }
};
```

##### LC563.二叉树的坡度

```C++
class Solution {
public:
    int findTilt(TreeNode* root) {
        DFS(root);
        return ans;
    }

private:
    int ans = 0;
    int DFS(TreeNode* root){
        if(!root) return 0;
        int lsum = DFS(root->left);
        int rsum = DFS(root->right);
        ans += abs(lsum - rsum);
        return lsum + rsum + root->val;
    }
};
```

## DP

​	TIPS: 动态规划是经常考察的一类；注意问题的拆分

##### LC32. 最长有效括号长度

```C++
class Solution {
public:
    int longestValidParentheses(string s) {
        int len = s.size();
        vector<int> dp(len, 0);
        // dp[i]表示以下标i结尾的有效子串长度
        int maxLen = 0;
        for(int i=1; i<len; ++i){
            if(s[i] == ')'){
                if(s[i-1] == '('){
                    dp[i] = (i >= 2 ? dp[i-2] : 0) + 2;
                }else if(i - dp[i-1] > 0 && s[i-dp[i-1]-1] == '('){
                    dp[i] = dp[i-1] + ((i - dp[i-1]) >= 2 ? dp[i-dp[i-1]-2] : 0) + 2;
                }
            }
            maxLen = max(maxLen, dp[i]);
        }
        return maxLen;
    }
};
```

##### LC198.打家劫舍

```C++
class Solution {
public:
    int rob(vector<int>& nums) {
        // dp[i][0]不偷 dp[i][1]偷
        dp[0][1] = nums[0];
        maxProfit = dp[0][1];
        for(int i=1; i<nums.size(); ++i){
            // 可以降低空间复杂度
            dp[i][0] = max(dp[i-1][0], dp[i-1][1]);
            dp[i][1] = max(dp[i-1][1], dp[i-1][0] + nums[i]);
            maxProfit = max(maxProfit, max(dp[i][0], dp[i][1]));
        }
        return maxProfit;
    }

private:
    int dp[101][2] = {0};
    int maxProfit = 0;
};
```

##### LC329.矩阵中的最长递增路径

```C++
// 定义store[i][j]表示包含matrix[i][j]值的最长串.
class Solution {
public:
    int longestIncreasingPath(vector<vector<int>>& matrix) {
        // 记忆法的dfs
        m = matrix.size(), n = matrix[0].size();
        store = vector<vector<int>>(m, vector<int>(n, 0));
        
        int res = 0;
        // 开始dfs
        for (int i=0; i<m; ++i){
            for(int j=0; j<n; ++j){
                res = max(getLen(matrix, i, j), res);
            }
        }
        return res;
    }

private:
    int m, n;
    vector<vector<int>> store;
    int dir[4][2] = {-1, 0, 0, 1, 1, 0, 0, -1};

private:
    bool indexInvalid(int i, int j){
        return i < 0 || i >= m || j < 0 || j >= n;
    }

    int getLen(const vector<vector<int>>& matrix, int i, int j){
        if(store[i][j]) return store[i][j];     // 记忆化, 过滤非极大长度
        // 从没有开始的地方dfs
        int res = 1, cur = matrix[i][j];
        for(int k=0; k<4; ++k){
            int ridx = i + dir[k][0];
            int cidx = j + dir[k][1];
            if(indexInvalid(ridx, cidx)) continue; // 下标不合法
            if(matrix[ridx][cidx] <= cur) continue; // 不是严格递增的
            res = max(res, getLen(matrix, ridx, cidx) + 1); // 递归方式寻找最长len
        }
        return store[i][j] = res;
    }
};
```

##### LC338.比特位计数

```C++
class Solution {
public:
    // nlogn
    vector<int> countBits1(int n) {
        vector<int> dp(n + 1, 0);
        for(int i=0; i<=n; ++i){
            dp[i] = _count(i);
        }
        return dp;
    }

    vector<int> countBits(int n) {
        vector<int> dp(n + 1, 0);
        for(int i=1; i<=n; ++i){
            dp[i] = dp[i & i - 1] + 1;
        }
        return dp;
    }

private:
    int _count(int i){
        int cnt = 0;
        while(i){
            ++cnt;
            i &= i - 1;
        }
        return cnt;
    }
};
```

##### LC343.整数拆分

```C++
class Solution {
public:
    int integerBreak(int n) {
        // 定义dp[i]表示整数i可以拆分的最大乘积
        vector<int> dp(n + 1, 0);
        dp[1] = 1;
        for(int i=2; i<=n; ++i){
            for(int j=1; j<=i/2; ++j){
                dp[i] = max(dp[i], max(j * (i - j), j * dp[i-j]));
            }
        }
        return dp[n];
    }
};
```

##### LC354.俄罗斯套娃问题

```

```



# 图论代码随想录

## 1.dfs和bfs的区别

​	dfs：深度优先搜索，一直往一边，不到黄河不回头。

```C++
// 要注意已经遍历的节点是否重复遍历问题，因此需要一个状态记忆
void dfs(参数){
    处理节点
    dfs(图, 选择的节点);
    回溯，撤销过程
}
// 图的dfs，其本质和回溯是一样的。
// 深搜三部曲
1.确认递归函数和参数;
void dfs(参数);
-- 一般深搜中使用二维数组保存所有路径，使用一维数组保存单一路径;
2.确认终止条件，不然会一直递归导致栈溢出;
if (终止条件) {
    存放结果;
    return;
}
3.处理目前搜索节点所能到达的节点;
for (选择：本节点所连接的其他节点) {
    处理节点;
    dfs(图，选择的节点); // 递归
    回溯，撤销处理结果
}
    
```

##### lc797:所有可能的路径

```C++
class Solution {
public:
    vector<vector<int>> allPathsSourceTarget(vector<vector<int>>& graph) {
        // graph[i] 是一个从节点 i 可以访问的所有节点的列表（即从节点 i 到节点 graph[i][j]存在一条有向边）
        dfs(graph, 0);
        return ans;
    }
private:
    void dfs(vector<vector<int>>& graph, int i){
        if(i == graph.size()-1){
            path.push_back(i);
            ans.push_back(path);
            path.pop_back();
            return;
        }
        if(graph[i].empty()) return; // 没有必要继续dfs了, 因为走到死路了

        path.push_back(i);
        // 图遍历当前节点的相邻节点
        for(auto& node : graph[i]){
            dfs(graph, node);
        }
        path.pop_back();
    }
private:
    vector<vector<int>> ans;
    vector<int> path;
};
```

bfs：

广搜有点类似于二叉树的层序遍历。bfs适用的场景主要是两个节点之间的最短路径问题。

![image-20230909095624859](I:\U盘内容\Primer\数据结构与算法\代码随想录\pic\image-20230909095624859.png)

![image-20230909095751354](I:\U盘内容\Primer\数据结构与算法\代码随想录\pic\image-20230909095751354.png)

// bfs通常使用队列来实现，可以保证搜索的时针方向是一致的。也可以用栈和数组，因为广搜对方向没有要求，

##### LC200 岛屿数量问题

bfs

```C++
class Solution {
public:
    bool visited[300][300] = {false};
    int dir[4][2] = {0, 1, 1, 0, 0, -1, -1, 0};
    int numIslands(vector<vector<char>>& grid) {
        int cnt = 0;
        for(int i=0; i<grid.size(); ++i){
            for(int j=0; j<grid[0].size(); ++j){
                if(grid[i][j] == '1' && !visited[i][j]){
                    ++cnt;
                    bfs(grid, i, j);
                }
            }
        }
        return cnt;
    }

private:
    void bfs(vector<vector<char>>& grid, int i, int j){
        queue<pair<int, int>> mq;
        mq.push({i, j});
        visited[i][j] = true;
        while(!mq.empty()){
            auto lpair = mq.front(); mq.pop();
            // 上下左右四个方向
            for(int i=0; i<4; ++i){
                int hidx = lpair.first + dir[i][0];
                int vidx = lpair.second + dir[i][1];
                if(hidx < 0 || hidx >= grid.size() || vidx < 0 || vidx >= grid[0].size()) continue;
                if(!visited[hidx][vidx] && grid[hidx][vidx] == '1'){
                    mq.push({hidx, vidx});
                    visited[hidx][vidx] = true; // 在这里加入，不能在外面。否则仍会出现多次遍历的情况
                }
            }
        }
    }
};
```

##### LC695岛屿最大面积, 其本质还是岛屿数量题目的基础上扩展的

```C++
// 比如广搜的时候，每加入一个进入队列或弹出一个，就是收割答案的时候
class Solution {
public:
    int maxAreaOfIsland(vector<vector<int>>& grid) {
        int ans = 0;
        for(int i=0; i<grid.size(); ++i){
            for(int j=0; j<grid[0].size(); ++j){
                if(!visited[i][j] && grid[i][j] == 1){
                    ans = max(ans, bfs(grid, i, j));
                }
            }
        }
        return ans;
    }

private:
    bool visited[50][50] = {false};
    int dir[4][2] = {0, 1, 1, 0, 0, -1, -1, 0};
    int bfs(vector<vector<int>>& grid, int i, int j){
        int area = 0;
        queue<pair<int, int>> mq;
        mq.push({i, j});
        visited[i][j] = true;
        while(!mq.empty()){
            auto lpair = mq.front(); mq.pop(); // 弹出一个就+1
            ++area;
            // 上下左右四个方向
            for(int i=0; i<4; ++i){
                int hidx = lpair.first + dir[i][0];
                int vidx = lpair.second + dir[i][1];
                if(hidx < 0 || hidx >= grid.size() || vidx < 0 || vidx >= grid[0].size()) continue;
                if(!visited[hidx][vidx] && grid[hidx][vidx] == 1){
                    mq.push({hidx, vidx});
                    visited[hidx][vidx] = true; // 在这里加入，不能在外面。否则仍会出现多次遍历的情况
                }
            }
        }
        return area;
    }
};
```

##### LC1020飞地的数量

```C++
// 实际上就是去除和边界相连的
class Solution {
public:
    // 超时了，应为bfs中的状态矩阵没有复用
    int numEnclaves1(vector<vector<int>>& grid) {
        int m = grid.size(), n = grid[0].size();
        int cnt = 0;
        for(int i=0; i<m; ++i){
            for(int j=0; j<n; ++j){
                if(grid[i][j] == 1 && !bfs(grid, i, j)){
                     ++cnt;
                }
            }
        }
        return cnt;
    }

    // 从边缘进行dfs或bfs, 将陆地都变为海洋
     int numEnclaves(vector<vector<int>>& grid){
         // 上侧
         int m = grid.size(), n = grid[0].size();
         for(int i=0; i<n; ++i){
             if(grid[0][i] == 1)
                 _dfs(grid, 0, i);
             if(grid[m-1][i] == 1)
                _dfs(grid, m-1, i);
         }

         for(int j=1; j<m; ++j){
             if(grid[j][0] == 1)
                 _dfs(grid, j, 0);
             if(grid[j][n-1] == 1)
                _dfs(grid, j, n-1);
         }


         int cnt = 0;
         for(int i=0; i<m; ++i){
             for(int j=0; j<n; ++j){
                 if(grid[i][j] == 1){
                     ++cnt;
                 }  
             }
         }
         return cnt;
     }


private:
    int dir[4][2] = {0, 1, 1, 0, 0, -1, -1, 0};
    
    void _dfs(vector<vector<int>>& grid, int i, int j){
        grid[i][j] = 0;
        for(int k=0; k<4; ++k){
            int ridx = i + dir[k][0];
            int cidx = j + dir[k][1];
            if(ridx < 0 || ridx >= grid.size() || cidx < 0 || cidx >= grid[0].size()) continue;  
            if(grid[ridx][cidx] == 0) continue;
            _dfs(grid, ridx, cidx);
        }
        return;
    }

    
    bool bfs(vector<vector<int>>& grid, int i, int j){
        vector<vector<bool>> visited(grid.size(), vector<bool>(grid[0].size(), false));
        queue<pair<int, int>> mq;
        mq.push({i, j});
        visited[i][j] = true;
        while(!mq.empty()){
            auto lpair = mq.front();  mq.pop();
            if(lpair.first <= 0 || lpair.first >= grid.size()-1 || lpair.second <= 0 || lpair.second >= grid[0].size() - 1) return true;
            for(int i=0; i<4; ++i){
                int fidx = lpair.first + dir[i][0];
                int vidx = lpair.second + dir[i][1];
                if(grid[fidx][vidx] == 0 || visited[fidx][vidx]) continue;
                visited[fidx][vidx] = true;
                mq.push({fidx, vidx});
            }
        }
        return false;
    }
};
```

##### LC130被围绕的区域

​	与LC1020的思路类似

```C++
class Solution {
public:
    void solve(vector<vector<char>>& board) {
        // 从边缘出发; 与边缘相连的用'Y'表示
        int m = board.size(), n = board[0].size();
        for(int i=0; i<n; ++i){
            if(board[0][i] == 'O')
                _bfs(board, 0, i);
            if(board[m-1][i] == 'O')
                _bfs(board, m-1, i);
        }

        for(int j=1; j<m; j++){
            if(board[j][0] == 'O')
                _bfs(board, j, 0);
            if(board[j][n-1] == 'O')
                _bfs(board, j, n-1);
        }

        // 填充
        for(int i=0; i<m; ++i){
            for(int j=0; j<n; ++j){
                if(board[i][j] == 'Y')
                    board[i][j] = 'O';
                else if(board[i][j] == 'O')
                    board[i][j] = 'X';
            }
        }
        return;
    }

private:
    int dir[4][2] = {0, 1, 1, 0, 0, -1, -1, 0};
    void _bfs(vector<vector<char>>& board, int i, int j){
        board[i][j] = 'Y';
        queue<pair<int, int>> mq;
        mq.push({i, j});
        while(!mq.empty()){
            auto lp = mq.front(); mq.pop();
            for(int k=0; k<4; ++k){
                int ridx = lp.first + dir[k][0];
                int cidx = lp.second + dir[k][1];
                if(ridx < 0 || ridx >= board.size() || cidx < 0 || cidx >= board[0].size()) continue;
                if(board[ridx][cidx] == 'X' || board[ridx][cidx] == 'Y') continue;
                board[ridx][cidx] = 'Y'; //标志位及时设置
                mq.push({ridx, cidx});
            }
        }
    }
};
```

##### LC417太平洋大西洋水流问题

​	和前面的题目思想一致，倒着来。从四周将水逆流而上，不能顺着下

```C++
class Solution {
public:
    // 暴力解法
    vector<vector<int>> pacificAtlantic(vector<vector<int>>& heights) {
        int m = heights.size(), n = heights[0].size();
        // 倒灌太平洋
        for(int i=0; i<n; ++i){
            if(visited[0][i] == 0) _bfs(heights, 0, i);
        }
        for(int i=0; i<m; ++i){
            if(visited[i][0] == 0) _bfs(heights, i, 0);
        }

        // 倒灌大西洋
        for(int i=0; i<n; ++i){
            if(visited[m-1][i] >= -1) __bfs(heights, m-1, i);
        }
        for(int i=0; i<m; ++i){
            if(visited[i][n-1] >= -1) __bfs(heights, i, n-1);
        }
        vector<vector<int>> ans;
        for(int i=0; i<m; ++i){
            for(int j=0; j<n; ++j){
                if(visited[i][j] == -3) ans.push_back({i, j});
            }
        }
        return ans;
    }

private:
    int dir[4][2] = {0, 1, 1, 0, 0, -1, -1, 0};
    struct point{
        int x;
        int y;
        point(int hidx, int cidx) : x(hidx), y(cidx){}
    };
    // 海水倒灌思想
    int visited[200][200] = {0}; // 太平洋可以访问的记为-1， 大西洋可以访问的记为-2, 两者都可访问的记为-3， 0表示还未访问
    // 太平洋
    void _bfs(vector<vector<int>>& heights, int x, int y){
        visited[x][y] = -1;
        queue<point> mq;
        mq.push(point(x, y));
        while(!mq.empty()){
            auto p = mq.front(); mq.pop();
            for(int i=0; i<4; ++i){
                int ridx = p.x + dir[i][0];
                int cidx = p.y + dir[i][1];
                if(ridx < 0 || ridx >= heights.size() || cidx < 0 || cidx >= heights[0].size()) continue;
                if(visited[ridx][cidx] != 0 || heights[ridx][cidx] < heights[p.x][p.y]) continue;
                mq.push(point(ridx, cidx));
                visited[ridx][cidx] = -1;
            }
        }
    }

    // 大西洋
    void __bfs(vector<vector<int>>& heights, int x, int y){
        if(visited[x][y] == -1) visited[x][y] = -3;
        else if(visited[x][y] == 0) visited[x][y] = -2;

        queue<point> mq;
        mq.push(point(x, y));
        while(!mq.empty()){
            auto p = mq.front(); mq.pop();
            for(int i=0; i<4; ++i){
                int ridx = p.x + dir[i][0];
                int cidx = p.y + dir[i][1];
                if(ridx < 0 || ridx >= heights.size() || cidx < 0 || cidx >= heights[0].size()) continue;
                if(visited[ridx][cidx] == -2 || visited[ridx][cidx] == -3 || heights[ridx][cidx] < heights[p.x][p.y]) continue;
                if(visited[ridx][cidx] == 0) visited[ridx][cidx] = -2;
                else if(visited[ridx][cidx] == -1) visited[ridx][cidx] = -3;
                mq.push(point(ridx, cidx));
            }
        }
    }
};
```

##### LC827最大人工岛

```C++
class Solution {
private:
    int count;
    int dir[4][2] = {0, 1, 1, 0, -1, 0, 0, -1}; // 四个方向
    void dfs(vector<vector<int>>& grid, vector<vector<bool>>& visited, int x, int y, int mark) {
        if (visited[x][y] || grid[x][y] == 0) return; // 终止条件：访问过的节点 或者 遇到海水
        visited[x][y] = true; // 标记访问过
        grid[x][y] = mark; // 给陆地标记新标签
        count++;
        for (int i = 0; i < 4; i++) {
            int nextx = x + dir[i][0];
            int nexty = y + dir[i][1];
            if (nextx < 0 || nextx >= grid.size() || nexty < 0 || nexty >= grid[0].size()) continue;  // 越界了，直接跳过
            dfs(grid, visited, nextx, nexty, mark);
        }
    }

public:
    int largestIsland(vector<vector<int>>& grid) {
        int n = grid.size(), m = grid[0].size();
        vector<vector<bool>> visited = vector<vector<bool>>(n, vector<bool>(m, false)); // 标记访问过的点
        unordered_map<int ,int> gridNum;
        int mark = 2; // 记录每个岛屿的编号
        bool isAllGrid = true; // 标记是否整个地图都是陆地
        for (int i = 0; i < n; i++) {
            for (int j = 0; j < m; j++) {
                if (grid[i][j] == 0) isAllGrid = false;
                if (!visited[i][j] && grid[i][j] == 1) {
                    count = 0;
                    dfs(grid, visited, i, j, mark); // 将与其链接的陆地都标记上 true
                    gridNum[mark] = count; // 记录每一个岛屿的面积
                    mark++; // 记录下一个岛屿编号
                }
            }
        }
        if (isAllGrid) return n * m; // 如果都是陆地，返回全面积

        // 以下逻辑是根据添加陆地的位置，计算周边岛屿面积之和
        int result = 0; // 记录最后结果
        unordered_set<int> visitedGrid; // 标记访问过的岛屿
        for (int i = 0; i < n; i++) {
            for (int j = 0; j < m; j++) {
                int count = 1; // 记录连接之后的岛屿数量
                visitedGrid.clear(); // 每次使用时，清空
                if (grid[i][j] == 0) {
                    for (int k = 0; k < 4; k++) {
                        int neari = i + dir[k][1]; // 计算相邻坐标
                        int nearj = j + dir[k][0];
                        if (neari < 0 || neari >= grid.size() || nearj < 0 || nearj >= grid[0].size()) continue;
                        if (visitedGrid.count(grid[neari][nearj])) continue; // 添加过的岛屿不要重复添加
                        // 把相邻四面的岛屿数量加起来
                        count += gridNum[grid[neari][nearj]];
                        visitedGrid.insert(grid[neari][nearj]); // 标记该岛屿已经添加过
                    }
                }
                result = max(result, count);
            }
        }
        return result;
    }
};
```

##### LC127 单词接龙

```C++
class Solution {
public:
    // bfs算法解决最短路径问题
    int ladderLength(string beginWord, string endWord, vector<string>& wordList) {
        unordered_set<string> uset(wordList.begin(), wordList.end());
        if(uset.find(endWord) == uset.end()) return 0;
        // 记录word是否被访问过
        unordered_map<string, int> visitMap; // <word,查询到这个word路径长度>
        // 初始化队列
        queue<string> que;
        que.push(beginWord);
        visitMap.insert({beginWord, 1});
        while(!que.empty()){
            string word = que.front();
            que.pop();
            int path = visitMap[word];
            for(int i=0; i<word.size(); ++i){
                string newWord = word;
                for(int j=0; j<26; ++j){
                    newWord[i] = j + 'a';
                    if(newWord == endWord) return path + 1;
                    //wordSet出现了newWord，并且newWord没有被访问过
                    if(uset.find(newWord) != uset.end() && visitMap.find(newWord) == visitMap.end()){
                        que.push(newWord);
                        visitMap[newWord] = path + 1;
                    }
                }
            }
        }
        return 0;
    }
};
```

##### LC463.岛屿的周长

```C++
class Solution {
public:
    int islandPerimeter(vector<vector<int>>& grid) {
        for(int i=0; i<grid.size(); ++i){
            for(int j=0; j<grid[0].size(); ++j){
                if(grid[i][j] == 1){
                    return bfs(grid, i, j);
                }
            }
        }
        return 0;
    }

private:
    bool visited[100][100] = {false};
    int dir[4][2] = {0, 1, 1, 0, 0, -1, -1, 0};
    int bfs(vector<vector<int>>& grid, int i, int j){
        visited[i][j] = true;
        queue<pair<int, int>> mq;
        mq.push({i, j});
        int cnt = 0;
        while(!mq.empty()){
            auto lp = mq.front(); mq.pop();
            cnt += len(grid, lp.first, lp.second);
            for(int i=0; i<4; ++i){
                int hidx = lp.first + dir[i][0];
                int vidx = lp.second + dir[i][1];
                if(hidx < 0 || hidx >= grid.size() || vidx < 0 ||vidx >= grid[0].size()) continue;
                if(visited[hidx][vidx] || !grid[hidx][vidx]) continue;
                mq.push({hidx, vidx});
                visited[hidx][vidx] = true;
            }
        }
        return cnt;
    }

    int len(vector<vector<int>>& grid, int i, int j){
        int cnt = 0;
        if(i == 0) ++cnt;
        if(i == grid.size() - 1) ++cnt;
        if(j == 0) ++cnt;
        if(j == grid[0].size() - 1) ++cnt;

        if(i > 0) cnt += (grid[i-1][j] == 0);
        if(i < grid.size() - 1) cnt += (grid[i+1][j] == 0);
        if(j > 0) cnt += (grid[i][j-1] == 0);
        if(j < grid[0].size() - 1) cnt += (grid[i][j+1] == 0);

        return cnt;
    }
};
```

